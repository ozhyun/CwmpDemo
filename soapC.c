/* soapC.c
   Generated by gSOAP 2.8.44 for tr069.h

gSOAP XML Web services tools
Copyright (C) 2000-2017, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC.c ver 2.8.44 2017-03-11 04:50:58 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, ""))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = (struct SOAP_ENV__Header*)soap_malloc(soap, sizeof(struct SOAP_ENV__Header))))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = (struct SOAP_ENV__Fault*)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault));
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = (struct SOAP_ENV__Reason*)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason));
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", "");
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if ((soap->error && soap->error != SOAP_TAG_MISMATCH) || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_unsignedByte:
		return soap_in_unsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_dateTime:
		return soap_in_dateTime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE__cwmp__UploadResponse_Status:
		return soap_in__cwmp__UploadResponse_Status(soap, NULL, NULL, "cwmp:UploadResponse-Status");
	case SOAP_TYPE__cwmp__DownloadResponse_Status:
		return soap_in__cwmp__DownloadResponse_Status(soap, NULL, NULL, "cwmp:DownloadResponse-Status");
	case SOAP_TYPE__cwmp__DeleteObjectResponse_Status:
		return soap_in__cwmp__DeleteObjectResponse_Status(soap, NULL, NULL, "cwmp:DeleteObjectResponse-Status");
	case SOAP_TYPE__cwmp__AddObjectResponse_Status:
		return soap_in__cwmp__AddObjectResponse_Status(soap, NULL, NULL, "cwmp:AddObjectResponse-Status");
	case SOAP_TYPE__cwmp__SetParameterValuesResponse_Status:
		return soap_in__cwmp__SetParameterValuesResponse_Status(soap, NULL, NULL, "cwmp:SetParameterValuesResponse-Status");
	case SOAP_TYPE__cwmp__OptionStruct_IsTransferable:
		return soap_in__cwmp__OptionStruct_IsTransferable(soap, NULL, NULL, "cwmp:OptionStruct-IsTransferable");
	case SOAP_TYPE__cwmp__OptionStruct_Mode:
		return soap_in__cwmp__OptionStruct_Mode(soap, NULL, NULL, "cwmp:OptionStruct-Mode");
	case SOAP_TYPE__cwmp__OptionStruct_State:
		return soap_in__cwmp__OptionStruct_State(soap, NULL, NULL, "cwmp:OptionStruct-State");
	case SOAP_TYPE__cwmp__QueuedTransferStruct_State:
		return soap_in__cwmp__QueuedTransferStruct_State(soap, NULL, NULL, "cwmp:QueuedTransferStruct-State");
	case SOAP_TYPE__cwmp__ParameterAttributeStruct_Notification:
		return soap_in__cwmp__ParameterAttributeStruct_Notification(soap, NULL, NULL, "cwmp:ParameterAttributeStruct-Notification");
	case SOAP_TYPE__cwmp__SetParameterAttributesStruct_Notification:
		return soap_in__cwmp__SetParameterAttributesStruct_Notification(soap, NULL, NULL, "cwmp:SetParameterAttributesStruct-Notification");
	case SOAP_TYPE__cwmp__FaultStruct_FaultCode:
		return soap_in__cwmp__FaultStruct_FaultCode(soap, NULL, NULL, "cwmp:FaultStruct-FaultCode");
	case SOAP_TYPE_xsd__boolean:
		return soap_in_xsd__boolean(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_cwmp__Inform:
		return soap_in_cwmp__Inform(soap, NULL, NULL, "cwmp:Inform");
	case SOAP_TYPE_cwmp__InformResponse:
		return soap_in_cwmp__InformResponse(soap, NULL, NULL, "cwmp:InformResponse");
	case SOAP_TYPE_FileTypeArg:
		return soap_in_FileTypeArg(soap, NULL, NULL, "cwmp:ArgStruct");
	case SOAP_TYPE_EventList:
		return soap_in_EventList(soap, NULL, NULL, "cwmp:EventStruct");
	case SOAP_TYPE_OptionList:
		return soap_in_OptionList(soap, NULL, NULL, "cwmp:OptionStruct");
	case SOAP_TYPE_VoucherList:
		return soap_in_VoucherList(soap, NULL, NULL, "SOAP-ENC:base64");
	case SOAP_TYPE_TransferList:
		return soap_in_TransferList(soap, NULL, NULL, "cwmp:QueuedTransferStruct");
	case SOAP_TYPE_ParameterAttributeList:
		return soap_in_ParameterAttributeList(soap, NULL, NULL, "cwmp:ParameterAttributeStruct");
	case SOAP_TYPE_SetParameterAttributesList:
		return soap_in_SetParameterAttributesList(soap, NULL, NULL, "cwmp:SetParameterAttributesStruct");
	case SOAP_TYPE_ParameterInfoList:
		return soap_in_ParameterInfoList(soap, NULL, NULL, "cwmp:ParameterInfoStruct");
	case SOAP_TYPE_ParameterNames:
		return soap_in_ParameterNames(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_ParameterValueList:
		return soap_in_ParameterValueList(soap, NULL, NULL, "cwmp:ParameterValueStruct");
	case SOAP_TYPE_MethodList:
		return soap_in_MethodList(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_cwmp__ArgStruct:
		return soap_in_cwmp__ArgStruct(soap, NULL, NULL, "cwmp:ArgStruct");
	case SOAP_TYPE_cwmp__OptionStruct:
		return soap_in_cwmp__OptionStruct(soap, NULL, NULL, "cwmp:OptionStruct");
	case SOAP_TYPE_cwmp__QueuedTransferStruct:
		return soap_in_cwmp__QueuedTransferStruct(soap, NULL, NULL, "cwmp:QueuedTransferStruct");
	case SOAP_TYPE_cwmp__ParameterAttributeStruct:
		return soap_in_cwmp__ParameterAttributeStruct(soap, NULL, NULL, "cwmp:ParameterAttributeStruct");
	case SOAP_TYPE_AccessList:
		return soap_in_AccessList(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_cwmp__SetParameterAttributesStruct:
		return soap_in_cwmp__SetParameterAttributesStruct(soap, NULL, NULL, "cwmp:SetParameterAttributesStruct");
	case SOAP_TYPE_cwmp__ParameterInfoStruct:
		return soap_in_cwmp__ParameterInfoStruct(soap, NULL, NULL, "cwmp:ParameterInfoStruct");
	case SOAP_TYPE_cwmp__ParameterValueStruct:
		return soap_in_cwmp__ParameterValueStruct(soap, NULL, NULL, "cwmp:ParameterValueStruct");
	case SOAP_TYPE_cwmp__EventStruct:
		return soap_in_cwmp__EventStruct(soap, NULL, NULL, "cwmp:EventStruct");
	case SOAP_TYPE_cwmp__DeviceIdStruct:
		return soap_in_cwmp__DeviceIdStruct(soap, NULL, NULL, "cwmp:DeviceIdStruct");
	case SOAP_TYPE_cwmp__FaultStruct:
		return soap_in_cwmp__FaultStruct(soap, NULL, NULL, "cwmp:FaultStruct");
	case SOAP_TYPE_SOAP_ENC__base64:
		return soap_in_SOAP_ENC__base64(soap, NULL, NULL, "SOAP-ENC:base64");
	case SOAP_TYPE_PointerTocwmp__InformResponse:
		return soap_in_PointerTocwmp__InformResponse(soap, NULL, NULL, "cwmp:InformResponse");
	case SOAP_TYPE_PointerToPointerTocwmp__ArgStruct:
		return soap_in_PointerToPointerTocwmp__ArgStruct(soap, NULL, NULL, "cwmp:ArgStruct");
	case SOAP_TYPE_PointerTocwmp__ArgStruct:
		return soap_in_PointerTocwmp__ArgStruct(soap, NULL, NULL, "cwmp:ArgStruct");
	case SOAP_TYPE_PointerToPointerTocwmp__OptionStruct:
		return soap_in_PointerToPointerTocwmp__OptionStruct(soap, NULL, NULL, "cwmp:OptionStruct");
	case SOAP_TYPE_PointerTocwmp__OptionStruct:
		return soap_in_PointerTocwmp__OptionStruct(soap, NULL, NULL, "cwmp:OptionStruct");
	case SOAP_TYPE_PointerToSOAP_ENC__base64:
		return soap_in_PointerToSOAP_ENC__base64(soap, NULL, NULL, "SOAP-ENC:base64");
	case SOAP_TYPE_PointerToPointerTocwmp__QueuedTransferStruct:
		return soap_in_PointerToPointerTocwmp__QueuedTransferStruct(soap, NULL, NULL, "cwmp:QueuedTransferStruct");
	case SOAP_TYPE_PointerTocwmp__QueuedTransferStruct:
		return soap_in_PointerTocwmp__QueuedTransferStruct(soap, NULL, NULL, "cwmp:QueuedTransferStruct");
	case SOAP_TYPE_PointerToPointerTocwmp__ParameterAttributeStruct:
		return soap_in_PointerToPointerTocwmp__ParameterAttributeStruct(soap, NULL, NULL, "cwmp:ParameterAttributeStruct");
	case SOAP_TYPE_PointerTocwmp__ParameterAttributeStruct:
		return soap_in_PointerTocwmp__ParameterAttributeStruct(soap, NULL, NULL, "cwmp:ParameterAttributeStruct");
	case SOAP_TYPE_PointerToPointerTocwmp__SetParameterAttributesStruct:
		return soap_in_PointerToPointerTocwmp__SetParameterAttributesStruct(soap, NULL, NULL, "cwmp:SetParameterAttributesStruct");
	case SOAP_TYPE_PointerTocwmp__SetParameterAttributesStruct:
		return soap_in_PointerTocwmp__SetParameterAttributesStruct(soap, NULL, NULL, "cwmp:SetParameterAttributesStruct");
	case SOAP_TYPE_PointerToPointerTocwmp__ParameterInfoStruct:
		return soap_in_PointerToPointerTocwmp__ParameterInfoStruct(soap, NULL, NULL, "cwmp:ParameterInfoStruct");
	case SOAP_TYPE_PointerTocwmp__ParameterInfoStruct:
		return soap_in_PointerTocwmp__ParameterInfoStruct(soap, NULL, NULL, "cwmp:ParameterInfoStruct");
	case SOAP_TYPE_PointerToPointerTocwmp__ParameterValueStruct:
		return soap_in_PointerToPointerTocwmp__ParameterValueStruct(soap, NULL, NULL, "cwmp:ParameterValueStruct");
	case SOAP_TYPE_PointerTocwmp__ParameterValueStruct:
		return soap_in_PointerTocwmp__ParameterValueStruct(soap, NULL, NULL, "cwmp:ParameterValueStruct");
	case SOAP_TYPE_PointerToPointerTocwmp__EventStruct:
		return soap_in_PointerToPointerTocwmp__EventStruct(soap, NULL, NULL, "cwmp:EventStruct");
	case SOAP_TYPE_PointerTocwmp__EventStruct:
		return soap_in_PointerTocwmp__EventStruct(soap, NULL, NULL, "cwmp:EventStruct");
	case SOAP_TYPE_PointerToFileTypeArg:
		return soap_in_PointerToFileTypeArg(soap, NULL, NULL, "cwmp:ArgStruct");
	case SOAP_TYPE_PointerTocwmp__FaultStruct:
		return soap_in_PointerTocwmp__FaultStruct(soap, NULL, NULL, "cwmp:FaultStruct");
	case SOAP_TYPE_PointerToEventList:
		return soap_in_PointerToEventList(soap, NULL, NULL, "cwmp:EventStruct");
	case SOAP_TYPE_PointerTocwmp__DeviceIdStruct:
		return soap_in_PointerTocwmp__DeviceIdStruct(soap, NULL, NULL, "cwmp:DeviceIdStruct");
	case SOAP_TYPE_PointerToOptionList:
		return soap_in_PointerToOptionList(soap, NULL, NULL, "cwmp:OptionStruct");
	case SOAP_TYPE_PointerToVoucherList:
		return soap_in_PointerToVoucherList(soap, NULL, NULL, "SOAP-ENC:base64");
	case SOAP_TYPE_PointerToTransferList:
		return soap_in_PointerToTransferList(soap, NULL, NULL, "cwmp:QueuedTransferStruct");
	case SOAP_TYPE_PointerToParameterAttributeList:
		return soap_in_PointerToParameterAttributeList(soap, NULL, NULL, "cwmp:ParameterAttributeStruct");
	case SOAP_TYPE_PointerToSetParameterAttributesList:
		return soap_in_PointerToSetParameterAttributesList(soap, NULL, NULL, "cwmp:SetParameterAttributesStruct");
	case SOAP_TYPE_PointerToParameterInfoList:
		return soap_in_PointerToParameterInfoList(soap, NULL, NULL, "cwmp:ParameterInfoStruct");
	case SOAP_TYPE_PointerToParameterNames:
		return soap_in_PointerToParameterNames(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerToParameterValueList:
		return soap_in_PointerToParameterValueList(soap, NULL, NULL, "cwmp:ParameterValueStruct");
	case SOAP_TYPE_PointerToMethodList:
		return soap_in_PointerToMethodList(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTo_cwmp__Fault_SetParameterValuesFault:
		return soap_in_PointerTo_cwmp__Fault_SetParameterValuesFault(soap, NULL, NULL, "cwmp:Fault-SetParameterValuesFault");
	case SOAP_TYPE_PointerTodateTime:
		return soap_in_PointerTodateTime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_PointerToAccessList:
		return soap_in_PointerToAccessList(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTostring:
		return soap_in_PointerTostring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_cwmp__ObjectNameType:
	{	char **s;
		s = soap_in_cwmp__ObjectNameType(soap, NULL, NULL, "cwmp:ObjectNameType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_cwmp__CommandKeyType:
	{	char **s;
		s = soap_in_cwmp__CommandKeyType(soap, NULL, NULL, "cwmp:CommandKeyType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_cwmp__ParameterKeyType:
	{	char **s;
		s = soap_in_cwmp__ParameterKeyType(soap, NULL, NULL, "cwmp:ParameterKeyType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_cwmp__FaultCodeType:
	{	char **s;
		s = soap_in_cwmp__FaultCodeType(soap, NULL, NULL, "cwmp:FaultCodeType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__anySimpleType:
	{	char **s;
		s = soap_in_xsd__anySimpleType(soap, NULL, NULL, "xsd:anySimpleType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_in_PointerTounsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_unsignedByte;
			return soap_in_unsignedByte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_dateTime;
			return soap_in_dateTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:UploadResponse-Status"))
		{	*type = SOAP_TYPE__cwmp__UploadResponse_Status;
			return soap_in__cwmp__UploadResponse_Status(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:DownloadResponse-Status"))
		{	*type = SOAP_TYPE__cwmp__DownloadResponse_Status;
			return soap_in__cwmp__DownloadResponse_Status(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:DeleteObjectResponse-Status"))
		{	*type = SOAP_TYPE__cwmp__DeleteObjectResponse_Status;
			return soap_in__cwmp__DeleteObjectResponse_Status(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:AddObjectResponse-Status"))
		{	*type = SOAP_TYPE__cwmp__AddObjectResponse_Status;
			return soap_in__cwmp__AddObjectResponse_Status(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:SetParameterValuesResponse-Status"))
		{	*type = SOAP_TYPE__cwmp__SetParameterValuesResponse_Status;
			return soap_in__cwmp__SetParameterValuesResponse_Status(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:OptionStruct-IsTransferable"))
		{	*type = SOAP_TYPE__cwmp__OptionStruct_IsTransferable;
			return soap_in__cwmp__OptionStruct_IsTransferable(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:OptionStruct-Mode"))
		{	*type = SOAP_TYPE__cwmp__OptionStruct_Mode;
			return soap_in__cwmp__OptionStruct_Mode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:OptionStruct-State"))
		{	*type = SOAP_TYPE__cwmp__OptionStruct_State;
			return soap_in__cwmp__OptionStruct_State(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:QueuedTransferStruct-State"))
		{	*type = SOAP_TYPE__cwmp__QueuedTransferStruct_State;
			return soap_in__cwmp__QueuedTransferStruct_State(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:ParameterAttributeStruct-Notification"))
		{	*type = SOAP_TYPE__cwmp__ParameterAttributeStruct_Notification;
			return soap_in__cwmp__ParameterAttributeStruct_Notification(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:SetParameterAttributesStruct-Notification"))
		{	*type = SOAP_TYPE__cwmp__SetParameterAttributesStruct_Notification;
			return soap_in__cwmp__SetParameterAttributesStruct_Notification(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:FaultStruct-FaultCode"))
		{	*type = SOAP_TYPE__cwmp__FaultStruct_FaultCode;
			return soap_in__cwmp__FaultStruct_FaultCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_xsd__boolean;
			return soap_in_xsd__boolean(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:Inform"))
		{	*type = SOAP_TYPE_cwmp__Inform;
			return soap_in_cwmp__Inform(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:InformResponse"))
		{	*type = SOAP_TYPE_cwmp__InformResponse;
			return soap_in_cwmp__InformResponse(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "cwmp:ArgStruct"))
		{	*type = SOAP_TYPE_FileTypeArg;
			return soap_in_FileTypeArg(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "cwmp:EventStruct"))
		{	*type = SOAP_TYPE_EventList;
			return soap_in_EventList(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "cwmp:OptionStruct"))
		{	*type = SOAP_TYPE_OptionList;
			return soap_in_OptionList(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "SOAP-ENC:base64"))
		{	*type = SOAP_TYPE_VoucherList;
			return soap_in_VoucherList(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "cwmp:QueuedTransferStruct"))
		{	*type = SOAP_TYPE_TransferList;
			return soap_in_TransferList(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "cwmp:ParameterAttributeStruct"))
		{	*type = SOAP_TYPE_ParameterAttributeList;
			return soap_in_ParameterAttributeList(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "cwmp:SetParameterAttributesStruct"))
		{	*type = SOAP_TYPE_SetParameterAttributesList;
			return soap_in_SetParameterAttributesList(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "cwmp:ParameterInfoStruct"))
		{	*type = SOAP_TYPE_ParameterInfoList;
			return soap_in_ParameterInfoList(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "xsd:string"))
		{	*type = SOAP_TYPE_ParameterNames;
			return soap_in_ParameterNames(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "cwmp:ParameterValueStruct"))
		{	*type = SOAP_TYPE_ParameterValueList;
			return soap_in_ParameterValueList(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "xsd:string"))
		{	*type = SOAP_TYPE_MethodList;
			return soap_in_MethodList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:ArgStruct"))
		{	*type = SOAP_TYPE_cwmp__ArgStruct;
			return soap_in_cwmp__ArgStruct(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:OptionStruct"))
		{	*type = SOAP_TYPE_cwmp__OptionStruct;
			return soap_in_cwmp__OptionStruct(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:QueuedTransferStruct"))
		{	*type = SOAP_TYPE_cwmp__QueuedTransferStruct;
			return soap_in_cwmp__QueuedTransferStruct(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:ParameterAttributeStruct"))
		{	*type = SOAP_TYPE_cwmp__ParameterAttributeStruct;
			return soap_in_cwmp__ParameterAttributeStruct(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "xsd:string"))
		{	*type = SOAP_TYPE_AccessList;
			return soap_in_AccessList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:SetParameterAttributesStruct"))
		{	*type = SOAP_TYPE_cwmp__SetParameterAttributesStruct;
			return soap_in_cwmp__SetParameterAttributesStruct(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:ParameterInfoStruct"))
		{	*type = SOAP_TYPE_cwmp__ParameterInfoStruct;
			return soap_in_cwmp__ParameterInfoStruct(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:ParameterValueStruct"))
		{	*type = SOAP_TYPE_cwmp__ParameterValueStruct;
			return soap_in_cwmp__ParameterValueStruct(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:EventStruct"))
		{	*type = SOAP_TYPE_cwmp__EventStruct;
			return soap_in_cwmp__EventStruct(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:DeviceIdStruct"))
		{	*type = SOAP_TYPE_cwmp__DeviceIdStruct;
			return soap_in_cwmp__DeviceIdStruct(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:FaultStruct"))
		{	*type = SOAP_TYPE_cwmp__FaultStruct;
			return soap_in_cwmp__FaultStruct(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "SOAP-ENC:base64"))
		{	*type = SOAP_TYPE_SOAP_ENC__base64;
			return soap_in_SOAP_ENC__base64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:ObjectNameType"))
		{	char **s;
			*type = SOAP_TYPE_cwmp__ObjectNameType;
			s = soap_in_cwmp__ObjectNameType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "cwmp:CommandKeyType"))
		{	char **s;
			*type = SOAP_TYPE_cwmp__CommandKeyType;
			s = soap_in_cwmp__CommandKeyType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "cwmp:ParameterKeyType"))
		{	char **s;
			*type = SOAP_TYPE_cwmp__ParameterKeyType;
			s = soap_in_cwmp__ParameterKeyType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "cwmp:FaultCodeType"))
		{	char **s;
			*type = SOAP_TYPE_cwmp__FaultCodeType;
			s = soap_in_cwmp__FaultCodeType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:anySimpleType"))
		{	char **s;
			*type = SOAP_TYPE_xsd__anySimpleType;
			s = soap_in_xsd__anySimpleType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "cwmp:HoldRequests"))
		{	*type = SOAP_TYPE__cwmp__HoldRequests;
			return soap_in__cwmp__HoldRequests(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:ID"))
		{	*type = SOAP_TYPE__cwmp__ID;
			return soap_in__cwmp__ID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:RequestDownloadResponse"))
		{	*type = SOAP_TYPE__cwmp__RequestDownloadResponse;
			return soap_in__cwmp__RequestDownloadResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:RequestDownload"))
		{	*type = SOAP_TYPE__cwmp__RequestDownload;
			return soap_in__cwmp__RequestDownload(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:KickedResponse"))
		{	*type = SOAP_TYPE__cwmp__KickedResponse;
			return soap_in__cwmp__KickedResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:Kicked"))
		{	*type = SOAP_TYPE__cwmp__Kicked;
			return soap_in__cwmp__Kicked(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:TransferCompleteResponse"))
		{	*type = SOAP_TYPE__cwmp__TransferCompleteResponse;
			return soap_in__cwmp__TransferCompleteResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:TransferComplete"))
		{	*type = SOAP_TYPE__cwmp__TransferComplete;
			return soap_in__cwmp__TransferComplete(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:InformResponse"))
		{	*type = SOAP_TYPE__cwmp__InformResponse;
			return soap_in__cwmp__InformResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:Inform"))
		{	*type = SOAP_TYPE__cwmp__Inform;
			return soap_in__cwmp__Inform(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:FactoryResetResponse"))
		{	*type = SOAP_TYPE__cwmp__FactoryResetResponse;
			return soap_in__cwmp__FactoryResetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:FactoryReset"))
		{	*type = SOAP_TYPE__cwmp__FactoryReset;
			return soap_in__cwmp__FactoryReset(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:UploadResponse"))
		{	*type = SOAP_TYPE__cwmp__UploadResponse;
			return soap_in__cwmp__UploadResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:Upload"))
		{	*type = SOAP_TYPE__cwmp__Upload;
			return soap_in__cwmp__Upload(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:GetOptionsResponse"))
		{	*type = SOAP_TYPE__cwmp__GetOptionsResponse;
			return soap_in__cwmp__GetOptionsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:GetOptions"))
		{	*type = SOAP_TYPE__cwmp__GetOptions;
			return soap_in__cwmp__GetOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:SetVouchersResponse"))
		{	*type = SOAP_TYPE__cwmp__SetVouchersResponse;
			return soap_in__cwmp__SetVouchersResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:SetVouchers"))
		{	*type = SOAP_TYPE__cwmp__SetVouchers;
			return soap_in__cwmp__SetVouchers(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:ScheduleInformResponse"))
		{	*type = SOAP_TYPE__cwmp__ScheduleInformResponse;
			return soap_in__cwmp__ScheduleInformResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:ScheduleInform"))
		{	*type = SOAP_TYPE__cwmp__ScheduleInform;
			return soap_in__cwmp__ScheduleInform(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:GetQueuedTransfersResponse"))
		{	*type = SOAP_TYPE__cwmp__GetQueuedTransfersResponse;
			return soap_in__cwmp__GetQueuedTransfersResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:GetQueuedTransfers"))
		{	*type = SOAP_TYPE__cwmp__GetQueuedTransfers;
			return soap_in__cwmp__GetQueuedTransfers(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:RebootResponse"))
		{	*type = SOAP_TYPE__cwmp__RebootResponse;
			return soap_in__cwmp__RebootResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:Reboot"))
		{	*type = SOAP_TYPE__cwmp__Reboot;
			return soap_in__cwmp__Reboot(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:DownloadResponse"))
		{	*type = SOAP_TYPE__cwmp__DownloadResponse;
			return soap_in__cwmp__DownloadResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:Download"))
		{	*type = SOAP_TYPE__cwmp__Download;
			return soap_in__cwmp__Download(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:DeleteObjectResponse"))
		{	*type = SOAP_TYPE__cwmp__DeleteObjectResponse;
			return soap_in__cwmp__DeleteObjectResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:DeleteObject"))
		{	*type = SOAP_TYPE__cwmp__DeleteObject;
			return soap_in__cwmp__DeleteObject(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:AddObjectResponse"))
		{	*type = SOAP_TYPE__cwmp__AddObjectResponse;
			return soap_in__cwmp__AddObjectResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:AddObject"))
		{	*type = SOAP_TYPE__cwmp__AddObject;
			return soap_in__cwmp__AddObject(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:GetParameterAttributesResponse"))
		{	*type = SOAP_TYPE__cwmp__GetParameterAttributesResponse;
			return soap_in__cwmp__GetParameterAttributesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:GetParameterAttributes"))
		{	*type = SOAP_TYPE__cwmp__GetParameterAttributes;
			return soap_in__cwmp__GetParameterAttributes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:SetParameterAttributesResponse"))
		{	*type = SOAP_TYPE__cwmp__SetParameterAttributesResponse;
			return soap_in__cwmp__SetParameterAttributesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:SetParameterAttributes"))
		{	*type = SOAP_TYPE__cwmp__SetParameterAttributes;
			return soap_in__cwmp__SetParameterAttributes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:GetParameterNamesResponse"))
		{	*type = SOAP_TYPE__cwmp__GetParameterNamesResponse;
			return soap_in__cwmp__GetParameterNamesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:GetParameterNames"))
		{	*type = SOAP_TYPE__cwmp__GetParameterNames;
			return soap_in__cwmp__GetParameterNames(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:GetParameterValuesResponse"))
		{	*type = SOAP_TYPE__cwmp__GetParameterValuesResponse;
			return soap_in__cwmp__GetParameterValuesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:GetParameterValues"))
		{	*type = SOAP_TYPE__cwmp__GetParameterValues;
			return soap_in__cwmp__GetParameterValues(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:SetParameterValuesResponse"))
		{	*type = SOAP_TYPE__cwmp__SetParameterValuesResponse;
			return soap_in__cwmp__SetParameterValuesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:SetParameterValues"))
		{	*type = SOAP_TYPE__cwmp__SetParameterValues;
			return soap_in__cwmp__SetParameterValues(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:GetRPCMethodsResponse"))
		{	*type = SOAP_TYPE__cwmp__GetRPCMethodsResponse;
			return soap_in__cwmp__GetRPCMethodsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:GetRPCMethods"))
		{	*type = SOAP_TYPE__cwmp__GetRPCMethods;
			return soap_in__cwmp__GetRPCMethods(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:Fault-SetParameterValuesFault"))
		{	*type = SOAP_TYPE__cwmp__Fault_SetParameterValuesFault;
			return soap_in__cwmp__Fault_SetParameterValuesFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cwmp:Fault"))
		{	*type = SOAP_TYPE__cwmp__Fault;
			return soap_in__cwmp__Fault(soap, NULL, NULL, NULL);
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level = %u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other && !soap->fignore)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				if (soap_ignore(soap) || soap_element_end_in(soap, NULL))
					return soap->error;
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_unsignedByte:
		return soap_out_unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_dateTime:
		return soap_out_dateTime(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE__cwmp__UploadResponse_Status:
		return soap_out__cwmp__UploadResponse_Status(soap, tag, id, (const enum _cwmp__UploadResponse_Status *)ptr, "cwmp:UploadResponse-Status");
	case SOAP_TYPE__cwmp__DownloadResponse_Status:
		return soap_out__cwmp__DownloadResponse_Status(soap, tag, id, (const enum _cwmp__DownloadResponse_Status *)ptr, "cwmp:DownloadResponse-Status");
	case SOAP_TYPE__cwmp__DeleteObjectResponse_Status:
		return soap_out__cwmp__DeleteObjectResponse_Status(soap, tag, id, (const enum _cwmp__DeleteObjectResponse_Status *)ptr, "cwmp:DeleteObjectResponse-Status");
	case SOAP_TYPE__cwmp__AddObjectResponse_Status:
		return soap_out__cwmp__AddObjectResponse_Status(soap, tag, id, (const enum _cwmp__AddObjectResponse_Status *)ptr, "cwmp:AddObjectResponse-Status");
	case SOAP_TYPE__cwmp__SetParameterValuesResponse_Status:
		return soap_out__cwmp__SetParameterValuesResponse_Status(soap, tag, id, (const enum _cwmp__SetParameterValuesResponse_Status *)ptr, "cwmp:SetParameterValuesResponse-Status");
	case SOAP_TYPE__cwmp__OptionStruct_IsTransferable:
		return soap_out__cwmp__OptionStruct_IsTransferable(soap, tag, id, (const enum _cwmp__OptionStruct_IsTransferable *)ptr, "cwmp:OptionStruct-IsTransferable");
	case SOAP_TYPE__cwmp__OptionStruct_Mode:
		return soap_out__cwmp__OptionStruct_Mode(soap, tag, id, (const enum _cwmp__OptionStruct_Mode *)ptr, "cwmp:OptionStruct-Mode");
	case SOAP_TYPE__cwmp__OptionStruct_State:
		return soap_out__cwmp__OptionStruct_State(soap, tag, id, (const enum _cwmp__OptionStruct_State *)ptr, "cwmp:OptionStruct-State");
	case SOAP_TYPE__cwmp__QueuedTransferStruct_State:
		return soap_out__cwmp__QueuedTransferStruct_State(soap, tag, id, (const enum _cwmp__QueuedTransferStruct_State *)ptr, "cwmp:QueuedTransferStruct-State");
	case SOAP_TYPE__cwmp__ParameterAttributeStruct_Notification:
		return soap_out__cwmp__ParameterAttributeStruct_Notification(soap, tag, id, (const enum _cwmp__ParameterAttributeStruct_Notification *)ptr, "cwmp:ParameterAttributeStruct-Notification");
	case SOAP_TYPE__cwmp__SetParameterAttributesStruct_Notification:
		return soap_out__cwmp__SetParameterAttributesStruct_Notification(soap, tag, id, (const enum _cwmp__SetParameterAttributesStruct_Notification *)ptr, "cwmp:SetParameterAttributesStruct-Notification");
	case SOAP_TYPE__cwmp__FaultStruct_FaultCode:
		return soap_out__cwmp__FaultStruct_FaultCode(soap, tag, id, (const enum _cwmp__FaultStruct_FaultCode *)ptr, "cwmp:FaultStruct-FaultCode");
	case SOAP_TYPE_xsd__boolean:
		return soap_out_xsd__boolean(soap, tag, id, (const enum xsd__boolean *)ptr, "xsd:boolean");
	case SOAP_TYPE_cwmp__Inform:
		return soap_out_cwmp__Inform(soap, tag, id, (const struct cwmp__Inform *)ptr, "cwmp:Inform");
	case SOAP_TYPE_cwmp__InformResponse:
		return soap_out_cwmp__InformResponse(soap, tag, id, (const struct cwmp__InformResponse *)ptr, "cwmp:InformResponse");
	case SOAP_TYPE__cwmp__HoldRequests:
		return soap_out__cwmp__HoldRequests(soap, "cwmp:HoldRequests", id, (const struct _cwmp__HoldRequests *)ptr, "");
	case SOAP_TYPE__cwmp__ID:
		return soap_out__cwmp__ID(soap, "cwmp:ID", id, (const struct _cwmp__ID *)ptr, "");
	case SOAP_TYPE__cwmp__RequestDownloadResponse:
		return soap_out__cwmp__RequestDownloadResponse(soap, "cwmp:RequestDownloadResponse", id, (const struct _cwmp__RequestDownloadResponse *)ptr, "");
	case SOAP_TYPE_FileTypeArg:
		return soap_out_FileTypeArg(soap, tag, id, (const struct FileTypeArg *)ptr, "cwmp:ArgStruct");
	case SOAP_TYPE__cwmp__RequestDownload:
		return soap_out__cwmp__RequestDownload(soap, "cwmp:RequestDownload", id, (const struct _cwmp__RequestDownload *)ptr, "");
	case SOAP_TYPE__cwmp__KickedResponse:
		return soap_out__cwmp__KickedResponse(soap, "cwmp:KickedResponse", id, (const struct _cwmp__KickedResponse *)ptr, "");
	case SOAP_TYPE__cwmp__Kicked:
		return soap_out__cwmp__Kicked(soap, "cwmp:Kicked", id, (const struct _cwmp__Kicked *)ptr, "");
	case SOAP_TYPE__cwmp__TransferCompleteResponse:
		return soap_out__cwmp__TransferCompleteResponse(soap, "cwmp:TransferCompleteResponse", id, (const struct _cwmp__TransferCompleteResponse *)ptr, "");
	case SOAP_TYPE__cwmp__TransferComplete:
		return soap_out__cwmp__TransferComplete(soap, "cwmp:TransferComplete", id, (const struct _cwmp__TransferComplete *)ptr, "");
	case SOAP_TYPE__cwmp__InformResponse:
		return soap_out__cwmp__InformResponse(soap, "cwmp:InformResponse", id, (const struct _cwmp__InformResponse *)ptr, "");
	case SOAP_TYPE_EventList:
		return soap_out_EventList(soap, tag, id, (const struct EventList *)ptr, "cwmp:EventStruct");
	case SOAP_TYPE__cwmp__Inform:
		return soap_out__cwmp__Inform(soap, "cwmp:Inform", id, (const struct _cwmp__Inform *)ptr, "");
	case SOAP_TYPE__cwmp__FactoryResetResponse:
		return soap_out__cwmp__FactoryResetResponse(soap, "cwmp:FactoryResetResponse", id, (const struct _cwmp__FactoryResetResponse *)ptr, "");
	case SOAP_TYPE__cwmp__FactoryReset:
		return soap_out__cwmp__FactoryReset(soap, "cwmp:FactoryReset", id, (const struct _cwmp__FactoryReset *)ptr, "");
	case SOAP_TYPE__cwmp__UploadResponse:
		return soap_out__cwmp__UploadResponse(soap, "cwmp:UploadResponse", id, (const struct _cwmp__UploadResponse *)ptr, "");
	case SOAP_TYPE__cwmp__Upload:
		return soap_out__cwmp__Upload(soap, "cwmp:Upload", id, (const struct _cwmp__Upload *)ptr, "");
	case SOAP_TYPE_OptionList:
		return soap_out_OptionList(soap, tag, id, (const struct OptionList *)ptr, "cwmp:OptionStruct");
	case SOAP_TYPE__cwmp__GetOptionsResponse:
		return soap_out__cwmp__GetOptionsResponse(soap, "cwmp:GetOptionsResponse", id, (const struct _cwmp__GetOptionsResponse *)ptr, "");
	case SOAP_TYPE__cwmp__GetOptions:
		return soap_out__cwmp__GetOptions(soap, "cwmp:GetOptions", id, (const struct _cwmp__GetOptions *)ptr, "");
	case SOAP_TYPE__cwmp__SetVouchersResponse:
		return soap_out__cwmp__SetVouchersResponse(soap, "cwmp:SetVouchersResponse", id, (const struct _cwmp__SetVouchersResponse *)ptr, "");
	case SOAP_TYPE_VoucherList:
		return soap_out_VoucherList(soap, tag, id, (const struct VoucherList *)ptr, "SOAP-ENC:base64");
	case SOAP_TYPE__cwmp__SetVouchers:
		return soap_out__cwmp__SetVouchers(soap, "cwmp:SetVouchers", id, (const struct _cwmp__SetVouchers *)ptr, "");
	case SOAP_TYPE__cwmp__ScheduleInformResponse:
		return soap_out__cwmp__ScheduleInformResponse(soap, "cwmp:ScheduleInformResponse", id, (const struct _cwmp__ScheduleInformResponse *)ptr, "");
	case SOAP_TYPE__cwmp__ScheduleInform:
		return soap_out__cwmp__ScheduleInform(soap, "cwmp:ScheduleInform", id, (const struct _cwmp__ScheduleInform *)ptr, "");
	case SOAP_TYPE_TransferList:
		return soap_out_TransferList(soap, tag, id, (const struct TransferList *)ptr, "cwmp:QueuedTransferStruct");
	case SOAP_TYPE__cwmp__GetQueuedTransfersResponse:
		return soap_out__cwmp__GetQueuedTransfersResponse(soap, "cwmp:GetQueuedTransfersResponse", id, (const struct _cwmp__GetQueuedTransfersResponse *)ptr, "");
	case SOAP_TYPE__cwmp__GetQueuedTransfers:
		return soap_out__cwmp__GetQueuedTransfers(soap, "cwmp:GetQueuedTransfers", id, (const struct _cwmp__GetQueuedTransfers *)ptr, "");
	case SOAP_TYPE__cwmp__RebootResponse:
		return soap_out__cwmp__RebootResponse(soap, "cwmp:RebootResponse", id, (const struct _cwmp__RebootResponse *)ptr, "");
	case SOAP_TYPE__cwmp__Reboot:
		return soap_out__cwmp__Reboot(soap, "cwmp:Reboot", id, (const struct _cwmp__Reboot *)ptr, "");
	case SOAP_TYPE__cwmp__DownloadResponse:
		return soap_out__cwmp__DownloadResponse(soap, "cwmp:DownloadResponse", id, (const struct _cwmp__DownloadResponse *)ptr, "");
	case SOAP_TYPE__cwmp__Download:
		return soap_out__cwmp__Download(soap, "cwmp:Download", id, (const struct _cwmp__Download *)ptr, "");
	case SOAP_TYPE__cwmp__DeleteObjectResponse:
		return soap_out__cwmp__DeleteObjectResponse(soap, "cwmp:DeleteObjectResponse", id, (const struct _cwmp__DeleteObjectResponse *)ptr, "");
	case SOAP_TYPE__cwmp__DeleteObject:
		return soap_out__cwmp__DeleteObject(soap, "cwmp:DeleteObject", id, (const struct _cwmp__DeleteObject *)ptr, "");
	case SOAP_TYPE__cwmp__AddObjectResponse:
		return soap_out__cwmp__AddObjectResponse(soap, "cwmp:AddObjectResponse", id, (const struct _cwmp__AddObjectResponse *)ptr, "");
	case SOAP_TYPE__cwmp__AddObject:
		return soap_out__cwmp__AddObject(soap, "cwmp:AddObject", id, (const struct _cwmp__AddObject *)ptr, "");
	case SOAP_TYPE_ParameterAttributeList:
		return soap_out_ParameterAttributeList(soap, tag, id, (const struct ParameterAttributeList *)ptr, "cwmp:ParameterAttributeStruct");
	case SOAP_TYPE__cwmp__GetParameterAttributesResponse:
		return soap_out__cwmp__GetParameterAttributesResponse(soap, "cwmp:GetParameterAttributesResponse", id, (const struct _cwmp__GetParameterAttributesResponse *)ptr, "");
	case SOAP_TYPE__cwmp__GetParameterAttributes:
		return soap_out__cwmp__GetParameterAttributes(soap, "cwmp:GetParameterAttributes", id, (const struct _cwmp__GetParameterAttributes *)ptr, "");
	case SOAP_TYPE__cwmp__SetParameterAttributesResponse:
		return soap_out__cwmp__SetParameterAttributesResponse(soap, "cwmp:SetParameterAttributesResponse", id, (const struct _cwmp__SetParameterAttributesResponse *)ptr, "");
	case SOAP_TYPE_SetParameterAttributesList:
		return soap_out_SetParameterAttributesList(soap, tag, id, (const struct SetParameterAttributesList *)ptr, "cwmp:SetParameterAttributesStruct");
	case SOAP_TYPE__cwmp__SetParameterAttributes:
		return soap_out__cwmp__SetParameterAttributes(soap, "cwmp:SetParameterAttributes", id, (const struct _cwmp__SetParameterAttributes *)ptr, "");
	case SOAP_TYPE_ParameterInfoList:
		return soap_out_ParameterInfoList(soap, tag, id, (const struct ParameterInfoList *)ptr, "cwmp:ParameterInfoStruct");
	case SOAP_TYPE__cwmp__GetParameterNamesResponse:
		return soap_out__cwmp__GetParameterNamesResponse(soap, "cwmp:GetParameterNamesResponse", id, (const struct _cwmp__GetParameterNamesResponse *)ptr, "");
	case SOAP_TYPE__cwmp__GetParameterNames:
		return soap_out__cwmp__GetParameterNames(soap, "cwmp:GetParameterNames", id, (const struct _cwmp__GetParameterNames *)ptr, "");
	case SOAP_TYPE__cwmp__GetParameterValuesResponse:
		return soap_out__cwmp__GetParameterValuesResponse(soap, "cwmp:GetParameterValuesResponse", id, (const struct _cwmp__GetParameterValuesResponse *)ptr, "");
	case SOAP_TYPE_ParameterNames:
		return soap_out_ParameterNames(soap, tag, id, (const struct ParameterNames *)ptr, "xsd:string");
	case SOAP_TYPE__cwmp__GetParameterValues:
		return soap_out__cwmp__GetParameterValues(soap, "cwmp:GetParameterValues", id, (const struct _cwmp__GetParameterValues *)ptr, "");
	case SOAP_TYPE__cwmp__SetParameterValuesResponse:
		return soap_out__cwmp__SetParameterValuesResponse(soap, "cwmp:SetParameterValuesResponse", id, (const struct _cwmp__SetParameterValuesResponse *)ptr, "");
	case SOAP_TYPE_ParameterValueList:
		return soap_out_ParameterValueList(soap, tag, id, (const struct ParameterValueList *)ptr, "cwmp:ParameterValueStruct");
	case SOAP_TYPE__cwmp__SetParameterValues:
		return soap_out__cwmp__SetParameterValues(soap, "cwmp:SetParameterValues", id, (const struct _cwmp__SetParameterValues *)ptr, "");
	case SOAP_TYPE_MethodList:
		return soap_out_MethodList(soap, tag, id, (const struct MethodList *)ptr, "xsd:string");
	case SOAP_TYPE__cwmp__GetRPCMethodsResponse:
		return soap_out__cwmp__GetRPCMethodsResponse(soap, "cwmp:GetRPCMethodsResponse", id, (const struct _cwmp__GetRPCMethodsResponse *)ptr, "");
	case SOAP_TYPE__cwmp__GetRPCMethods:
		return soap_out__cwmp__GetRPCMethods(soap, "cwmp:GetRPCMethods", id, (const struct _cwmp__GetRPCMethods *)ptr, "");
	case SOAP_TYPE__cwmp__Fault_SetParameterValuesFault:
		return soap_out__cwmp__Fault_SetParameterValuesFault(soap, "cwmp:Fault-SetParameterValuesFault", id, (const struct _cwmp__Fault_SetParameterValuesFault *)ptr, "");
	case SOAP_TYPE__cwmp__Fault:
		return soap_out__cwmp__Fault(soap, "cwmp:Fault", id, (const struct _cwmp__Fault *)ptr, "");
	case SOAP_TYPE_cwmp__ArgStruct:
		return soap_out_cwmp__ArgStruct(soap, tag, id, (const struct cwmp__ArgStruct *)ptr, "cwmp:ArgStruct");
	case SOAP_TYPE_cwmp__OptionStruct:
		return soap_out_cwmp__OptionStruct(soap, tag, id, (const struct cwmp__OptionStruct *)ptr, "cwmp:OptionStruct");
	case SOAP_TYPE_cwmp__QueuedTransferStruct:
		return soap_out_cwmp__QueuedTransferStruct(soap, tag, id, (const struct cwmp__QueuedTransferStruct *)ptr, "cwmp:QueuedTransferStruct");
	case SOAP_TYPE_cwmp__ParameterAttributeStruct:
		return soap_out_cwmp__ParameterAttributeStruct(soap, tag, id, (const struct cwmp__ParameterAttributeStruct *)ptr, "cwmp:ParameterAttributeStruct");
	case SOAP_TYPE_AccessList:
		return soap_out_AccessList(soap, tag, id, (const struct AccessList *)ptr, "xsd:string");
	case SOAP_TYPE_cwmp__SetParameterAttributesStruct:
		return soap_out_cwmp__SetParameterAttributesStruct(soap, tag, id, (const struct cwmp__SetParameterAttributesStruct *)ptr, "cwmp:SetParameterAttributesStruct");
	case SOAP_TYPE_cwmp__ParameterInfoStruct:
		return soap_out_cwmp__ParameterInfoStruct(soap, tag, id, (const struct cwmp__ParameterInfoStruct *)ptr, "cwmp:ParameterInfoStruct");
	case SOAP_TYPE_cwmp__ParameterValueStruct:
		return soap_out_cwmp__ParameterValueStruct(soap, tag, id, (const struct cwmp__ParameterValueStruct *)ptr, "cwmp:ParameterValueStruct");
	case SOAP_TYPE_cwmp__EventStruct:
		return soap_out_cwmp__EventStruct(soap, tag, id, (const struct cwmp__EventStruct *)ptr, "cwmp:EventStruct");
	case SOAP_TYPE_cwmp__DeviceIdStruct:
		return soap_out_cwmp__DeviceIdStruct(soap, tag, id, (const struct cwmp__DeviceIdStruct *)ptr, "cwmp:DeviceIdStruct");
	case SOAP_TYPE_cwmp__FaultStruct:
		return soap_out_cwmp__FaultStruct(soap, tag, id, (const struct cwmp__FaultStruct *)ptr, "cwmp:FaultStruct");
	case SOAP_TYPE_SOAP_ENC__base64:
		return soap_out_SOAP_ENC__base64(soap, tag, id, (const struct SOAP_ENC__base64 *)ptr, "SOAP-ENC:base64");
	case SOAP_TYPE_PointerTocwmp__InformResponse:
		return soap_out_PointerTocwmp__InformResponse(soap, tag, id, (struct cwmp__InformResponse *const*)ptr, "cwmp:InformResponse");
	case SOAP_TYPE_PointerToPointerTocwmp__ArgStruct:
		return soap_out_PointerToPointerTocwmp__ArgStruct(soap, tag, id, (struct cwmp__ArgStruct **const*)ptr, "cwmp:ArgStruct");
	case SOAP_TYPE_PointerTocwmp__ArgStruct:
		return soap_out_PointerTocwmp__ArgStruct(soap, tag, id, (struct cwmp__ArgStruct *const*)ptr, "cwmp:ArgStruct");
	case SOAP_TYPE_PointerToPointerTocwmp__OptionStruct:
		return soap_out_PointerToPointerTocwmp__OptionStruct(soap, tag, id, (struct cwmp__OptionStruct **const*)ptr, "cwmp:OptionStruct");
	case SOAP_TYPE_PointerTocwmp__OptionStruct:
		return soap_out_PointerTocwmp__OptionStruct(soap, tag, id, (struct cwmp__OptionStruct *const*)ptr, "cwmp:OptionStruct");
	case SOAP_TYPE_PointerToSOAP_ENC__base64:
		return soap_out_PointerToSOAP_ENC__base64(soap, tag, id, (struct SOAP_ENC__base64 *const*)ptr, "SOAP-ENC:base64");
	case SOAP_TYPE_PointerToPointerTocwmp__QueuedTransferStruct:
		return soap_out_PointerToPointerTocwmp__QueuedTransferStruct(soap, tag, id, (struct cwmp__QueuedTransferStruct **const*)ptr, "cwmp:QueuedTransferStruct");
	case SOAP_TYPE_PointerTocwmp__QueuedTransferStruct:
		return soap_out_PointerTocwmp__QueuedTransferStruct(soap, tag, id, (struct cwmp__QueuedTransferStruct *const*)ptr, "cwmp:QueuedTransferStruct");
	case SOAP_TYPE_PointerToPointerTocwmp__ParameterAttributeStruct:
		return soap_out_PointerToPointerTocwmp__ParameterAttributeStruct(soap, tag, id, (struct cwmp__ParameterAttributeStruct **const*)ptr, "cwmp:ParameterAttributeStruct");
	case SOAP_TYPE_PointerTocwmp__ParameterAttributeStruct:
		return soap_out_PointerTocwmp__ParameterAttributeStruct(soap, tag, id, (struct cwmp__ParameterAttributeStruct *const*)ptr, "cwmp:ParameterAttributeStruct");
	case SOAP_TYPE_PointerToPointerTocwmp__SetParameterAttributesStruct:
		return soap_out_PointerToPointerTocwmp__SetParameterAttributesStruct(soap, tag, id, (struct cwmp__SetParameterAttributesStruct **const*)ptr, "cwmp:SetParameterAttributesStruct");
	case SOAP_TYPE_PointerTocwmp__SetParameterAttributesStruct:
		return soap_out_PointerTocwmp__SetParameterAttributesStruct(soap, tag, id, (struct cwmp__SetParameterAttributesStruct *const*)ptr, "cwmp:SetParameterAttributesStruct");
	case SOAP_TYPE_PointerToPointerTocwmp__ParameterInfoStruct:
		return soap_out_PointerToPointerTocwmp__ParameterInfoStruct(soap, tag, id, (struct cwmp__ParameterInfoStruct **const*)ptr, "cwmp:ParameterInfoStruct");
	case SOAP_TYPE_PointerTocwmp__ParameterInfoStruct:
		return soap_out_PointerTocwmp__ParameterInfoStruct(soap, tag, id, (struct cwmp__ParameterInfoStruct *const*)ptr, "cwmp:ParameterInfoStruct");
	case SOAP_TYPE_PointerToPointerTocwmp__ParameterValueStruct:
		return soap_out_PointerToPointerTocwmp__ParameterValueStruct(soap, tag, id, (struct cwmp__ParameterValueStruct **const*)ptr, "cwmp:ParameterValueStruct");
	case SOAP_TYPE_PointerTocwmp__ParameterValueStruct:
		return soap_out_PointerTocwmp__ParameterValueStruct(soap, tag, id, (struct cwmp__ParameterValueStruct *const*)ptr, "cwmp:ParameterValueStruct");
	case SOAP_TYPE_PointerToPointerTocwmp__EventStruct:
		return soap_out_PointerToPointerTocwmp__EventStruct(soap, tag, id, (struct cwmp__EventStruct **const*)ptr, "cwmp:EventStruct");
	case SOAP_TYPE_PointerTocwmp__EventStruct:
		return soap_out_PointerTocwmp__EventStruct(soap, tag, id, (struct cwmp__EventStruct *const*)ptr, "cwmp:EventStruct");
	case SOAP_TYPE_PointerToFileTypeArg:
		return soap_out_PointerToFileTypeArg(soap, tag, id, (struct FileTypeArg *const*)ptr, "cwmp:ArgStruct");
	case SOAP_TYPE_PointerTocwmp__FaultStruct:
		return soap_out_PointerTocwmp__FaultStruct(soap, tag, id, (struct cwmp__FaultStruct *const*)ptr, "cwmp:FaultStruct");
	case SOAP_TYPE_PointerToEventList:
		return soap_out_PointerToEventList(soap, tag, id, (struct EventList *const*)ptr, "cwmp:EventStruct");
	case SOAP_TYPE_PointerTocwmp__DeviceIdStruct:
		return soap_out_PointerTocwmp__DeviceIdStruct(soap, tag, id, (struct cwmp__DeviceIdStruct *const*)ptr, "cwmp:DeviceIdStruct");
	case SOAP_TYPE_PointerToOptionList:
		return soap_out_PointerToOptionList(soap, tag, id, (struct OptionList *const*)ptr, "cwmp:OptionStruct");
	case SOAP_TYPE_PointerToVoucherList:
		return soap_out_PointerToVoucherList(soap, tag, id, (struct VoucherList *const*)ptr, "SOAP-ENC:base64");
	case SOAP_TYPE_PointerToTransferList:
		return soap_out_PointerToTransferList(soap, tag, id, (struct TransferList *const*)ptr, "cwmp:QueuedTransferStruct");
	case SOAP_TYPE_PointerToParameterAttributeList:
		return soap_out_PointerToParameterAttributeList(soap, tag, id, (struct ParameterAttributeList *const*)ptr, "cwmp:ParameterAttributeStruct");
	case SOAP_TYPE_PointerToSetParameterAttributesList:
		return soap_out_PointerToSetParameterAttributesList(soap, tag, id, (struct SetParameterAttributesList *const*)ptr, "cwmp:SetParameterAttributesStruct");
	case SOAP_TYPE_PointerToParameterInfoList:
		return soap_out_PointerToParameterInfoList(soap, tag, id, (struct ParameterInfoList *const*)ptr, "cwmp:ParameterInfoStruct");
	case SOAP_TYPE_PointerToParameterNames:
		return soap_out_PointerToParameterNames(soap, tag, id, (struct ParameterNames *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerToParameterValueList:
		return soap_out_PointerToParameterValueList(soap, tag, id, (struct ParameterValueList *const*)ptr, "cwmp:ParameterValueStruct");
	case SOAP_TYPE_PointerToMethodList:
		return soap_out_PointerToMethodList(soap, tag, id, (struct MethodList *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTo_cwmp__Fault_SetParameterValuesFault:
		return soap_out_PointerTo_cwmp__Fault_SetParameterValuesFault(soap, tag, id, (struct _cwmp__Fault_SetParameterValuesFault *const*)ptr, "cwmp:Fault-SetParameterValuesFault");
	case SOAP_TYPE_PointerTodateTime:
		return soap_out_PointerTodateTime(soap, tag, id, (time_t *const*)ptr, "xsd:dateTime");
	case SOAP_TYPE_PointerToAccessList:
		return soap_out_PointerToAccessList(soap, tag, id, (struct AccessList *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTostring:
		return soap_out_PointerTostring(soap, tag, id, (char **const*)ptr, "xsd:string");
	case SOAP_TYPE_cwmp__ObjectNameType:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "cwmp:ObjectNameType");
	case SOAP_TYPE_cwmp__CommandKeyType:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "cwmp:CommandKeyType");
	case SOAP_TYPE_cwmp__ParameterKeyType:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "cwmp:ParameterKeyType");
	case SOAP_TYPE_cwmp__FaultCodeType:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "cwmp:FaultCodeType");
	case SOAP_TYPE_xsd__anySimpleType:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:anySimpleType");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_out_PointerTounsignedByte(soap, tag, id, (unsigned char *const*)ptr, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_cwmp__Inform:
		soap_serialize_cwmp__Inform(soap, (const struct cwmp__Inform *)ptr);
		break;
	case SOAP_TYPE_cwmp__InformResponse:
		soap_serialize_cwmp__InformResponse(soap, (const struct cwmp__InformResponse *)ptr);
		break;
	case SOAP_TYPE__cwmp__HoldRequests:
		soap_serialize__cwmp__HoldRequests(soap, (const struct _cwmp__HoldRequests *)ptr);
		break;
	case SOAP_TYPE__cwmp__ID:
		soap_serialize__cwmp__ID(soap, (const struct _cwmp__ID *)ptr);
		break;
	case SOAP_TYPE__cwmp__RequestDownloadResponse:
		soap_serialize__cwmp__RequestDownloadResponse(soap, (const struct _cwmp__RequestDownloadResponse *)ptr);
		break;
	case SOAP_TYPE_FileTypeArg:
		soap_serialize_FileTypeArg(soap, (const struct FileTypeArg *)ptr);
		break;
	case SOAP_TYPE__cwmp__RequestDownload:
		soap_serialize__cwmp__RequestDownload(soap, (const struct _cwmp__RequestDownload *)ptr);
		break;
	case SOAP_TYPE__cwmp__KickedResponse:
		soap_serialize__cwmp__KickedResponse(soap, (const struct _cwmp__KickedResponse *)ptr);
		break;
	case SOAP_TYPE__cwmp__Kicked:
		soap_serialize__cwmp__Kicked(soap, (const struct _cwmp__Kicked *)ptr);
		break;
	case SOAP_TYPE__cwmp__TransferCompleteResponse:
		soap_serialize__cwmp__TransferCompleteResponse(soap, (const struct _cwmp__TransferCompleteResponse *)ptr);
		break;
	case SOAP_TYPE__cwmp__TransferComplete:
		soap_serialize__cwmp__TransferComplete(soap, (const struct _cwmp__TransferComplete *)ptr);
		break;
	case SOAP_TYPE__cwmp__InformResponse:
		soap_serialize__cwmp__InformResponse(soap, (const struct _cwmp__InformResponse *)ptr);
		break;
	case SOAP_TYPE_EventList:
		soap_serialize_EventList(soap, (const struct EventList *)ptr);
		break;
	case SOAP_TYPE__cwmp__Inform:
		soap_serialize__cwmp__Inform(soap, (const struct _cwmp__Inform *)ptr);
		break;
	case SOAP_TYPE__cwmp__FactoryResetResponse:
		soap_serialize__cwmp__FactoryResetResponse(soap, (const struct _cwmp__FactoryResetResponse *)ptr);
		break;
	case SOAP_TYPE__cwmp__FactoryReset:
		soap_serialize__cwmp__FactoryReset(soap, (const struct _cwmp__FactoryReset *)ptr);
		break;
	case SOAP_TYPE__cwmp__UploadResponse:
		soap_serialize__cwmp__UploadResponse(soap, (const struct _cwmp__UploadResponse *)ptr);
		break;
	case SOAP_TYPE__cwmp__Upload:
		soap_serialize__cwmp__Upload(soap, (const struct _cwmp__Upload *)ptr);
		break;
	case SOAP_TYPE_OptionList:
		soap_serialize_OptionList(soap, (const struct OptionList *)ptr);
		break;
	case SOAP_TYPE__cwmp__GetOptionsResponse:
		soap_serialize__cwmp__GetOptionsResponse(soap, (const struct _cwmp__GetOptionsResponse *)ptr);
		break;
	case SOAP_TYPE__cwmp__GetOptions:
		soap_serialize__cwmp__GetOptions(soap, (const struct _cwmp__GetOptions *)ptr);
		break;
	case SOAP_TYPE__cwmp__SetVouchersResponse:
		soap_serialize__cwmp__SetVouchersResponse(soap, (const struct _cwmp__SetVouchersResponse *)ptr);
		break;
	case SOAP_TYPE_VoucherList:
		soap_serialize_VoucherList(soap, (const struct VoucherList *)ptr);
		break;
	case SOAP_TYPE__cwmp__SetVouchers:
		soap_serialize__cwmp__SetVouchers(soap, (const struct _cwmp__SetVouchers *)ptr);
		break;
	case SOAP_TYPE__cwmp__ScheduleInformResponse:
		soap_serialize__cwmp__ScheduleInformResponse(soap, (const struct _cwmp__ScheduleInformResponse *)ptr);
		break;
	case SOAP_TYPE__cwmp__ScheduleInform:
		soap_serialize__cwmp__ScheduleInform(soap, (const struct _cwmp__ScheduleInform *)ptr);
		break;
	case SOAP_TYPE_TransferList:
		soap_serialize_TransferList(soap, (const struct TransferList *)ptr);
		break;
	case SOAP_TYPE__cwmp__GetQueuedTransfersResponse:
		soap_serialize__cwmp__GetQueuedTransfersResponse(soap, (const struct _cwmp__GetQueuedTransfersResponse *)ptr);
		break;
	case SOAP_TYPE__cwmp__GetQueuedTransfers:
		soap_serialize__cwmp__GetQueuedTransfers(soap, (const struct _cwmp__GetQueuedTransfers *)ptr);
		break;
	case SOAP_TYPE__cwmp__RebootResponse:
		soap_serialize__cwmp__RebootResponse(soap, (const struct _cwmp__RebootResponse *)ptr);
		break;
	case SOAP_TYPE__cwmp__Reboot:
		soap_serialize__cwmp__Reboot(soap, (const struct _cwmp__Reboot *)ptr);
		break;
	case SOAP_TYPE__cwmp__DownloadResponse:
		soap_serialize__cwmp__DownloadResponse(soap, (const struct _cwmp__DownloadResponse *)ptr);
		break;
	case SOAP_TYPE__cwmp__Download:
		soap_serialize__cwmp__Download(soap, (const struct _cwmp__Download *)ptr);
		break;
	case SOAP_TYPE__cwmp__DeleteObjectResponse:
		soap_serialize__cwmp__DeleteObjectResponse(soap, (const struct _cwmp__DeleteObjectResponse *)ptr);
		break;
	case SOAP_TYPE__cwmp__DeleteObject:
		soap_serialize__cwmp__DeleteObject(soap, (const struct _cwmp__DeleteObject *)ptr);
		break;
	case SOAP_TYPE__cwmp__AddObjectResponse:
		soap_serialize__cwmp__AddObjectResponse(soap, (const struct _cwmp__AddObjectResponse *)ptr);
		break;
	case SOAP_TYPE__cwmp__AddObject:
		soap_serialize__cwmp__AddObject(soap, (const struct _cwmp__AddObject *)ptr);
		break;
	case SOAP_TYPE_ParameterAttributeList:
		soap_serialize_ParameterAttributeList(soap, (const struct ParameterAttributeList *)ptr);
		break;
	case SOAP_TYPE__cwmp__GetParameterAttributesResponse:
		soap_serialize__cwmp__GetParameterAttributesResponse(soap, (const struct _cwmp__GetParameterAttributesResponse *)ptr);
		break;
	case SOAP_TYPE__cwmp__GetParameterAttributes:
		soap_serialize__cwmp__GetParameterAttributes(soap, (const struct _cwmp__GetParameterAttributes *)ptr);
		break;
	case SOAP_TYPE__cwmp__SetParameterAttributesResponse:
		soap_serialize__cwmp__SetParameterAttributesResponse(soap, (const struct _cwmp__SetParameterAttributesResponse *)ptr);
		break;
	case SOAP_TYPE_SetParameterAttributesList:
		soap_serialize_SetParameterAttributesList(soap, (const struct SetParameterAttributesList *)ptr);
		break;
	case SOAP_TYPE__cwmp__SetParameterAttributes:
		soap_serialize__cwmp__SetParameterAttributes(soap, (const struct _cwmp__SetParameterAttributes *)ptr);
		break;
	case SOAP_TYPE_ParameterInfoList:
		soap_serialize_ParameterInfoList(soap, (const struct ParameterInfoList *)ptr);
		break;
	case SOAP_TYPE__cwmp__GetParameterNamesResponse:
		soap_serialize__cwmp__GetParameterNamesResponse(soap, (const struct _cwmp__GetParameterNamesResponse *)ptr);
		break;
	case SOAP_TYPE__cwmp__GetParameterNames:
		soap_serialize__cwmp__GetParameterNames(soap, (const struct _cwmp__GetParameterNames *)ptr);
		break;
	case SOAP_TYPE__cwmp__GetParameterValuesResponse:
		soap_serialize__cwmp__GetParameterValuesResponse(soap, (const struct _cwmp__GetParameterValuesResponse *)ptr);
		break;
	case SOAP_TYPE_ParameterNames:
		soap_serialize_ParameterNames(soap, (const struct ParameterNames *)ptr);
		break;
	case SOAP_TYPE__cwmp__GetParameterValues:
		soap_serialize__cwmp__GetParameterValues(soap, (const struct _cwmp__GetParameterValues *)ptr);
		break;
	case SOAP_TYPE__cwmp__SetParameterValuesResponse:
		soap_serialize__cwmp__SetParameterValuesResponse(soap, (const struct _cwmp__SetParameterValuesResponse *)ptr);
		break;
	case SOAP_TYPE_ParameterValueList:
		soap_serialize_ParameterValueList(soap, (const struct ParameterValueList *)ptr);
		break;
	case SOAP_TYPE__cwmp__SetParameterValues:
		soap_serialize__cwmp__SetParameterValues(soap, (const struct _cwmp__SetParameterValues *)ptr);
		break;
	case SOAP_TYPE_MethodList:
		soap_serialize_MethodList(soap, (const struct MethodList *)ptr);
		break;
	case SOAP_TYPE__cwmp__GetRPCMethodsResponse:
		soap_serialize__cwmp__GetRPCMethodsResponse(soap, (const struct _cwmp__GetRPCMethodsResponse *)ptr);
		break;
	case SOAP_TYPE__cwmp__GetRPCMethods:
		soap_serialize__cwmp__GetRPCMethods(soap, (const struct _cwmp__GetRPCMethods *)ptr);
		break;
	case SOAP_TYPE__cwmp__Fault_SetParameterValuesFault:
		soap_serialize__cwmp__Fault_SetParameterValuesFault(soap, (const struct _cwmp__Fault_SetParameterValuesFault *)ptr);
		break;
	case SOAP_TYPE__cwmp__Fault:
		soap_serialize__cwmp__Fault(soap, (const struct _cwmp__Fault *)ptr);
		break;
	case SOAP_TYPE_cwmp__ArgStruct:
		soap_serialize_cwmp__ArgStruct(soap, (const struct cwmp__ArgStruct *)ptr);
		break;
	case SOAP_TYPE_cwmp__OptionStruct:
		soap_serialize_cwmp__OptionStruct(soap, (const struct cwmp__OptionStruct *)ptr);
		break;
	case SOAP_TYPE_cwmp__QueuedTransferStruct:
		soap_serialize_cwmp__QueuedTransferStruct(soap, (const struct cwmp__QueuedTransferStruct *)ptr);
		break;
	case SOAP_TYPE_cwmp__ParameterAttributeStruct:
		soap_serialize_cwmp__ParameterAttributeStruct(soap, (const struct cwmp__ParameterAttributeStruct *)ptr);
		break;
	case SOAP_TYPE_AccessList:
		soap_serialize_AccessList(soap, (const struct AccessList *)ptr);
		break;
	case SOAP_TYPE_cwmp__SetParameterAttributesStruct:
		soap_serialize_cwmp__SetParameterAttributesStruct(soap, (const struct cwmp__SetParameterAttributesStruct *)ptr);
		break;
	case SOAP_TYPE_cwmp__ParameterInfoStruct:
		soap_serialize_cwmp__ParameterInfoStruct(soap, (const struct cwmp__ParameterInfoStruct *)ptr);
		break;
	case SOAP_TYPE_cwmp__ParameterValueStruct:
		soap_serialize_cwmp__ParameterValueStruct(soap, (const struct cwmp__ParameterValueStruct *)ptr);
		break;
	case SOAP_TYPE_cwmp__EventStruct:
		soap_serialize_cwmp__EventStruct(soap, (const struct cwmp__EventStruct *)ptr);
		break;
	case SOAP_TYPE_cwmp__DeviceIdStruct:
		soap_serialize_cwmp__DeviceIdStruct(soap, (const struct cwmp__DeviceIdStruct *)ptr);
		break;
	case SOAP_TYPE_cwmp__FaultStruct:
		soap_serialize_cwmp__FaultStruct(soap, (const struct cwmp__FaultStruct *)ptr);
		break;
	case SOAP_TYPE_SOAP_ENC__base64:
		soap_serialize_SOAP_ENC__base64(soap, (const struct SOAP_ENC__base64 *)ptr);
		break;
	case SOAP_TYPE_PointerTocwmp__InformResponse:
		soap_serialize_PointerTocwmp__InformResponse(soap, (struct cwmp__InformResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTocwmp__ArgStruct:
		soap_serialize_PointerToPointerTocwmp__ArgStruct(soap, (struct cwmp__ArgStruct **const*)ptr);
		break;
	case SOAP_TYPE_PointerTocwmp__ArgStruct:
		soap_serialize_PointerTocwmp__ArgStruct(soap, (struct cwmp__ArgStruct *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTocwmp__OptionStruct:
		soap_serialize_PointerToPointerTocwmp__OptionStruct(soap, (struct cwmp__OptionStruct **const*)ptr);
		break;
	case SOAP_TYPE_PointerTocwmp__OptionStruct:
		soap_serialize_PointerTocwmp__OptionStruct(soap, (struct cwmp__OptionStruct *const*)ptr);
		break;
	case SOAP_TYPE_PointerToSOAP_ENC__base64:
		soap_serialize_PointerToSOAP_ENC__base64(soap, (struct SOAP_ENC__base64 *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTocwmp__QueuedTransferStruct:
		soap_serialize_PointerToPointerTocwmp__QueuedTransferStruct(soap, (struct cwmp__QueuedTransferStruct **const*)ptr);
		break;
	case SOAP_TYPE_PointerTocwmp__QueuedTransferStruct:
		soap_serialize_PointerTocwmp__QueuedTransferStruct(soap, (struct cwmp__QueuedTransferStruct *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTocwmp__ParameterAttributeStruct:
		soap_serialize_PointerToPointerTocwmp__ParameterAttributeStruct(soap, (struct cwmp__ParameterAttributeStruct **const*)ptr);
		break;
	case SOAP_TYPE_PointerTocwmp__ParameterAttributeStruct:
		soap_serialize_PointerTocwmp__ParameterAttributeStruct(soap, (struct cwmp__ParameterAttributeStruct *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTocwmp__SetParameterAttributesStruct:
		soap_serialize_PointerToPointerTocwmp__SetParameterAttributesStruct(soap, (struct cwmp__SetParameterAttributesStruct **const*)ptr);
		break;
	case SOAP_TYPE_PointerTocwmp__SetParameterAttributesStruct:
		soap_serialize_PointerTocwmp__SetParameterAttributesStruct(soap, (struct cwmp__SetParameterAttributesStruct *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTocwmp__ParameterInfoStruct:
		soap_serialize_PointerToPointerTocwmp__ParameterInfoStruct(soap, (struct cwmp__ParameterInfoStruct **const*)ptr);
		break;
	case SOAP_TYPE_PointerTocwmp__ParameterInfoStruct:
		soap_serialize_PointerTocwmp__ParameterInfoStruct(soap, (struct cwmp__ParameterInfoStruct *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTocwmp__ParameterValueStruct:
		soap_serialize_PointerToPointerTocwmp__ParameterValueStruct(soap, (struct cwmp__ParameterValueStruct **const*)ptr);
		break;
	case SOAP_TYPE_PointerTocwmp__ParameterValueStruct:
		soap_serialize_PointerTocwmp__ParameterValueStruct(soap, (struct cwmp__ParameterValueStruct *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTocwmp__EventStruct:
		soap_serialize_PointerToPointerTocwmp__EventStruct(soap, (struct cwmp__EventStruct **const*)ptr);
		break;
	case SOAP_TYPE_PointerTocwmp__EventStruct:
		soap_serialize_PointerTocwmp__EventStruct(soap, (struct cwmp__EventStruct *const*)ptr);
		break;
	case SOAP_TYPE_PointerToFileTypeArg:
		soap_serialize_PointerToFileTypeArg(soap, (struct FileTypeArg *const*)ptr);
		break;
	case SOAP_TYPE_PointerTocwmp__FaultStruct:
		soap_serialize_PointerTocwmp__FaultStruct(soap, (struct cwmp__FaultStruct *const*)ptr);
		break;
	case SOAP_TYPE_PointerToEventList:
		soap_serialize_PointerToEventList(soap, (struct EventList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTocwmp__DeviceIdStruct:
		soap_serialize_PointerTocwmp__DeviceIdStruct(soap, (struct cwmp__DeviceIdStruct *const*)ptr);
		break;
	case SOAP_TYPE_PointerToOptionList:
		soap_serialize_PointerToOptionList(soap, (struct OptionList *const*)ptr);
		break;
	case SOAP_TYPE_PointerToVoucherList:
		soap_serialize_PointerToVoucherList(soap, (struct VoucherList *const*)ptr);
		break;
	case SOAP_TYPE_PointerToTransferList:
		soap_serialize_PointerToTransferList(soap, (struct TransferList *const*)ptr);
		break;
	case SOAP_TYPE_PointerToParameterAttributeList:
		soap_serialize_PointerToParameterAttributeList(soap, (struct ParameterAttributeList *const*)ptr);
		break;
	case SOAP_TYPE_PointerToSetParameterAttributesList:
		soap_serialize_PointerToSetParameterAttributesList(soap, (struct SetParameterAttributesList *const*)ptr);
		break;
	case SOAP_TYPE_PointerToParameterInfoList:
		soap_serialize_PointerToParameterInfoList(soap, (struct ParameterInfoList *const*)ptr);
		break;
	case SOAP_TYPE_PointerToParameterNames:
		soap_serialize_PointerToParameterNames(soap, (struct ParameterNames *const*)ptr);
		break;
	case SOAP_TYPE_PointerToParameterValueList:
		soap_serialize_PointerToParameterValueList(soap, (struct ParameterValueList *const*)ptr);
		break;
	case SOAP_TYPE_PointerToMethodList:
		soap_serialize_PointerToMethodList(soap, (struct MethodList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_cwmp__Fault_SetParameterValuesFault:
		soap_serialize_PointerTo_cwmp__Fault_SetParameterValuesFault(soap, (struct _cwmp__Fault_SetParameterValuesFault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTodateTime:
		soap_serialize_PointerTodateTime(soap, (time_t *const*)ptr);
		break;
	case SOAP_TYPE_PointerToAccessList:
		soap_serialize_PointerToAccessList(soap, (struct AccessList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostring:
		soap_serialize_PointerTostring(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE_cwmp__ObjectNameType:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_cwmp__CommandKeyType:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_cwmp__ParameterKeyType:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_cwmp__FaultCodeType:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_xsd__anySimpleType:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_PointerTounsignedByte:
		soap_serialize_PointerTounsignedByte(soap, (unsigned char *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	if (!type)
		type = "xsd:byte";
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	a = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return a;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_new_byte(struct soap *soap, int n)
{
	char *p;
	char *a = (char*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(char));
	for (p = a; p && n--; p++)
		soap_default_byte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	if (soap_out_byte(soap, tag ? tag : "byte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	if (!type)
		type = "xsd:int";
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return a;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_new_int(struct soap *soap, int n)
{
	int *p;
	int *a = (int*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(int));
	for (p = a; p && n--; p++)
		soap_default_int(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_int(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{
	if (!type)
		type = "xsd:unsignedByte";
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{
	a = soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_unsignedByte);
	return a;
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_new_unsignedByte(struct soap *soap, int n)
{
	unsigned char *p;
	unsigned char *a = (unsigned char*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(unsigned char));
	for (p = a; p && n--; p++)
		soap_default_unsignedByte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	if (soap_out_unsignedByte(soap, tag ? tag : "unsignedByte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{
	if (!type)
		type = "xsd:unsignedInt";
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{
	a = soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
	return a;
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_new_unsignedInt(struct soap *soap, int n)
{
	unsigned int *p;
	unsigned int *a = (unsigned int*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(unsigned int));
	for (p = a; p && n--; p++)
		soap_default_unsignedInt(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	if (soap_out_unsignedInt(soap, tag ? tag : "unsignedInt", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dateTime(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	if (!type)
		type = "xsd:dateTime";
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_dateTime);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_dateTime(struct soap *soap, const char *tag, time_t *a, const char *type)
{
	a = soap_indateTime(soap, tag, a, type, SOAP_TYPE_dateTime);
	return a;
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_new_dateTime(struct soap *soap, int n)
{
	time_t *p;
	time_t *a = (time_t*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(time_t));
	for (p = a; p && n--; p++)
		soap_default_dateTime(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dateTime(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	if (soap_out_dateTime(soap, tag ? tag : "dateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_dateTime(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_dateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes__cwmp__UploadResponse_Status[] =
{	{ (LONG64)_cwmp__UploadResponse_Status__0, "0" },
	{ (LONG64)_cwmp__UploadResponse_Status__1, "1" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__cwmp__UploadResponse_Status2s(struct soap *soap, enum _cwmp__UploadResponse_Status n)
{	const char *s = soap_code_str(soap_codes__cwmp__UploadResponse_Status, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__cwmp__UploadResponse_Status(struct soap *soap, const char *tag, int id, const enum _cwmp__UploadResponse_Status *a, const char *type)
{
	if (!type)
		type = "cwmp:UploadResponse-Status";
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__cwmp__UploadResponse_Status), type) || soap_send(soap, soap__cwmp__UploadResponse_Status2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_cwmp__UploadResponse_Status(struct soap *soap, const char *s, enum _cwmp__UploadResponse_Status *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes__cwmp__UploadResponse_Status, s);
	if (map)
		*a = (enum _cwmp__UploadResponse_Status)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum _cwmp__UploadResponse_Status)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _cwmp__UploadResponse_Status * SOAP_FMAC4 soap_in__cwmp__UploadResponse_Status(struct soap *soap, const char *tag, enum _cwmp__UploadResponse_Status *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _cwmp__UploadResponse_Status *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__cwmp__UploadResponse_Status, sizeof(enum _cwmp__UploadResponse_Status), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2_cwmp__UploadResponse_Status(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _cwmp__UploadResponse_Status *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__cwmp__UploadResponse_Status, SOAP_TYPE__cwmp__UploadResponse_Status, sizeof(enum _cwmp__UploadResponse_Status), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum _cwmp__UploadResponse_Status * SOAP_FMAC4 soap_new__cwmp__UploadResponse_Status(struct soap *soap, int n)
{
	enum _cwmp__UploadResponse_Status *p;
	enum _cwmp__UploadResponse_Status *a = (enum _cwmp__UploadResponse_Status*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum _cwmp__UploadResponse_Status));
	for (p = a; p && n--; p++)
		soap_default__cwmp__UploadResponse_Status(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__cwmp__UploadResponse_Status(struct soap *soap, const enum _cwmp__UploadResponse_Status *a, const char *tag, const char *type)
{
	if (soap_out__cwmp__UploadResponse_Status(soap, tag ? tag : "cwmp:UploadResponse-Status", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _cwmp__UploadResponse_Status * SOAP_FMAC4 soap_get__cwmp__UploadResponse_Status(struct soap *soap, enum _cwmp__UploadResponse_Status *p, const char *tag, const char *type)
{
	if ((p = soap_in__cwmp__UploadResponse_Status(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes__cwmp__DownloadResponse_Status[] =
{	{ (LONG64)_cwmp__DownloadResponse_Status__0, "0" },
	{ (LONG64)_cwmp__DownloadResponse_Status__1, "1" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__cwmp__DownloadResponse_Status2s(struct soap *soap, enum _cwmp__DownloadResponse_Status n)
{	const char *s = soap_code_str(soap_codes__cwmp__DownloadResponse_Status, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__cwmp__DownloadResponse_Status(struct soap *soap, const char *tag, int id, const enum _cwmp__DownloadResponse_Status *a, const char *type)
{
	if (!type)
		type = "cwmp:DownloadResponse-Status";
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__cwmp__DownloadResponse_Status), type) || soap_send(soap, soap__cwmp__DownloadResponse_Status2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_cwmp__DownloadResponse_Status(struct soap *soap, const char *s, enum _cwmp__DownloadResponse_Status *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes__cwmp__DownloadResponse_Status, s);
	if (map)
		*a = (enum _cwmp__DownloadResponse_Status)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum _cwmp__DownloadResponse_Status)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _cwmp__DownloadResponse_Status * SOAP_FMAC4 soap_in__cwmp__DownloadResponse_Status(struct soap *soap, const char *tag, enum _cwmp__DownloadResponse_Status *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _cwmp__DownloadResponse_Status *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__cwmp__DownloadResponse_Status, sizeof(enum _cwmp__DownloadResponse_Status), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2_cwmp__DownloadResponse_Status(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _cwmp__DownloadResponse_Status *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__cwmp__DownloadResponse_Status, SOAP_TYPE__cwmp__DownloadResponse_Status, sizeof(enum _cwmp__DownloadResponse_Status), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum _cwmp__DownloadResponse_Status * SOAP_FMAC4 soap_new__cwmp__DownloadResponse_Status(struct soap *soap, int n)
{
	enum _cwmp__DownloadResponse_Status *p;
	enum _cwmp__DownloadResponse_Status *a = (enum _cwmp__DownloadResponse_Status*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum _cwmp__DownloadResponse_Status));
	for (p = a; p && n--; p++)
		soap_default__cwmp__DownloadResponse_Status(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__cwmp__DownloadResponse_Status(struct soap *soap, const enum _cwmp__DownloadResponse_Status *a, const char *tag, const char *type)
{
	if (soap_out__cwmp__DownloadResponse_Status(soap, tag ? tag : "cwmp:DownloadResponse-Status", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _cwmp__DownloadResponse_Status * SOAP_FMAC4 soap_get__cwmp__DownloadResponse_Status(struct soap *soap, enum _cwmp__DownloadResponse_Status *p, const char *tag, const char *type)
{
	if ((p = soap_in__cwmp__DownloadResponse_Status(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes__cwmp__DeleteObjectResponse_Status[] =
{	{ (LONG64)_cwmp__DeleteObjectResponse_Status__0, "0" },
	{ (LONG64)_cwmp__DeleteObjectResponse_Status__1, "1" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__cwmp__DeleteObjectResponse_Status2s(struct soap *soap, enum _cwmp__DeleteObjectResponse_Status n)
{	const char *s = soap_code_str(soap_codes__cwmp__DeleteObjectResponse_Status, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__cwmp__DeleteObjectResponse_Status(struct soap *soap, const char *tag, int id, const enum _cwmp__DeleteObjectResponse_Status *a, const char *type)
{
	if (!type)
		type = "cwmp:DeleteObjectResponse-Status";
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__cwmp__DeleteObjectResponse_Status), type) || soap_send(soap, soap__cwmp__DeleteObjectResponse_Status2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_cwmp__DeleteObjectResponse_Status(struct soap *soap, const char *s, enum _cwmp__DeleteObjectResponse_Status *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes__cwmp__DeleteObjectResponse_Status, s);
	if (map)
		*a = (enum _cwmp__DeleteObjectResponse_Status)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum _cwmp__DeleteObjectResponse_Status)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _cwmp__DeleteObjectResponse_Status * SOAP_FMAC4 soap_in__cwmp__DeleteObjectResponse_Status(struct soap *soap, const char *tag, enum _cwmp__DeleteObjectResponse_Status *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _cwmp__DeleteObjectResponse_Status *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__cwmp__DeleteObjectResponse_Status, sizeof(enum _cwmp__DeleteObjectResponse_Status), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2_cwmp__DeleteObjectResponse_Status(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _cwmp__DeleteObjectResponse_Status *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__cwmp__DeleteObjectResponse_Status, SOAP_TYPE__cwmp__DeleteObjectResponse_Status, sizeof(enum _cwmp__DeleteObjectResponse_Status), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum _cwmp__DeleteObjectResponse_Status * SOAP_FMAC4 soap_new__cwmp__DeleteObjectResponse_Status(struct soap *soap, int n)
{
	enum _cwmp__DeleteObjectResponse_Status *p;
	enum _cwmp__DeleteObjectResponse_Status *a = (enum _cwmp__DeleteObjectResponse_Status*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum _cwmp__DeleteObjectResponse_Status));
	for (p = a; p && n--; p++)
		soap_default__cwmp__DeleteObjectResponse_Status(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__cwmp__DeleteObjectResponse_Status(struct soap *soap, const enum _cwmp__DeleteObjectResponse_Status *a, const char *tag, const char *type)
{
	if (soap_out__cwmp__DeleteObjectResponse_Status(soap, tag ? tag : "cwmp:DeleteObjectResponse-Status", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _cwmp__DeleteObjectResponse_Status * SOAP_FMAC4 soap_get__cwmp__DeleteObjectResponse_Status(struct soap *soap, enum _cwmp__DeleteObjectResponse_Status *p, const char *tag, const char *type)
{
	if ((p = soap_in__cwmp__DeleteObjectResponse_Status(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes__cwmp__AddObjectResponse_Status[] =
{	{ (LONG64)_cwmp__AddObjectResponse_Status__0, "0" },
	{ (LONG64)_cwmp__AddObjectResponse_Status__1, "1" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__cwmp__AddObjectResponse_Status2s(struct soap *soap, enum _cwmp__AddObjectResponse_Status n)
{	const char *s = soap_code_str(soap_codes__cwmp__AddObjectResponse_Status, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__cwmp__AddObjectResponse_Status(struct soap *soap, const char *tag, int id, const enum _cwmp__AddObjectResponse_Status *a, const char *type)
{
	if (!type)
		type = "cwmp:AddObjectResponse-Status";
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__cwmp__AddObjectResponse_Status), type) || soap_send(soap, soap__cwmp__AddObjectResponse_Status2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_cwmp__AddObjectResponse_Status(struct soap *soap, const char *s, enum _cwmp__AddObjectResponse_Status *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes__cwmp__AddObjectResponse_Status, s);
	if (map)
		*a = (enum _cwmp__AddObjectResponse_Status)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum _cwmp__AddObjectResponse_Status)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _cwmp__AddObjectResponse_Status * SOAP_FMAC4 soap_in__cwmp__AddObjectResponse_Status(struct soap *soap, const char *tag, enum _cwmp__AddObjectResponse_Status *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _cwmp__AddObjectResponse_Status *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__cwmp__AddObjectResponse_Status, sizeof(enum _cwmp__AddObjectResponse_Status), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2_cwmp__AddObjectResponse_Status(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _cwmp__AddObjectResponse_Status *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__cwmp__AddObjectResponse_Status, SOAP_TYPE__cwmp__AddObjectResponse_Status, sizeof(enum _cwmp__AddObjectResponse_Status), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum _cwmp__AddObjectResponse_Status * SOAP_FMAC4 soap_new__cwmp__AddObjectResponse_Status(struct soap *soap, int n)
{
	enum _cwmp__AddObjectResponse_Status *p;
	enum _cwmp__AddObjectResponse_Status *a = (enum _cwmp__AddObjectResponse_Status*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum _cwmp__AddObjectResponse_Status));
	for (p = a; p && n--; p++)
		soap_default__cwmp__AddObjectResponse_Status(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__cwmp__AddObjectResponse_Status(struct soap *soap, const enum _cwmp__AddObjectResponse_Status *a, const char *tag, const char *type)
{
	if (soap_out__cwmp__AddObjectResponse_Status(soap, tag ? tag : "cwmp:AddObjectResponse-Status", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _cwmp__AddObjectResponse_Status * SOAP_FMAC4 soap_get__cwmp__AddObjectResponse_Status(struct soap *soap, enum _cwmp__AddObjectResponse_Status *p, const char *tag, const char *type)
{
	if ((p = soap_in__cwmp__AddObjectResponse_Status(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes__cwmp__SetParameterValuesResponse_Status[] =
{	{ (LONG64)_cwmp__SetParameterValuesResponse_Status__0, "0" },
	{ (LONG64)_cwmp__SetParameterValuesResponse_Status__1, "1" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__cwmp__SetParameterValuesResponse_Status2s(struct soap *soap, enum _cwmp__SetParameterValuesResponse_Status n)
{	const char *s = soap_code_str(soap_codes__cwmp__SetParameterValuesResponse_Status, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__cwmp__SetParameterValuesResponse_Status(struct soap *soap, const char *tag, int id, const enum _cwmp__SetParameterValuesResponse_Status *a, const char *type)
{
	if (!type)
		type = "cwmp:SetParameterValuesResponse-Status";
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__cwmp__SetParameterValuesResponse_Status), type) || soap_send(soap, soap__cwmp__SetParameterValuesResponse_Status2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_cwmp__SetParameterValuesResponse_Status(struct soap *soap, const char *s, enum _cwmp__SetParameterValuesResponse_Status *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes__cwmp__SetParameterValuesResponse_Status, s);
	if (map)
		*a = (enum _cwmp__SetParameterValuesResponse_Status)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum _cwmp__SetParameterValuesResponse_Status)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _cwmp__SetParameterValuesResponse_Status * SOAP_FMAC4 soap_in__cwmp__SetParameterValuesResponse_Status(struct soap *soap, const char *tag, enum _cwmp__SetParameterValuesResponse_Status *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _cwmp__SetParameterValuesResponse_Status *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__cwmp__SetParameterValuesResponse_Status, sizeof(enum _cwmp__SetParameterValuesResponse_Status), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2_cwmp__SetParameterValuesResponse_Status(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _cwmp__SetParameterValuesResponse_Status *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__cwmp__SetParameterValuesResponse_Status, SOAP_TYPE__cwmp__SetParameterValuesResponse_Status, sizeof(enum _cwmp__SetParameterValuesResponse_Status), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum _cwmp__SetParameterValuesResponse_Status * SOAP_FMAC4 soap_new__cwmp__SetParameterValuesResponse_Status(struct soap *soap, int n)
{
	enum _cwmp__SetParameterValuesResponse_Status *p;
	enum _cwmp__SetParameterValuesResponse_Status *a = (enum _cwmp__SetParameterValuesResponse_Status*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum _cwmp__SetParameterValuesResponse_Status));
	for (p = a; p && n--; p++)
		soap_default__cwmp__SetParameterValuesResponse_Status(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__cwmp__SetParameterValuesResponse_Status(struct soap *soap, const enum _cwmp__SetParameterValuesResponse_Status *a, const char *tag, const char *type)
{
	if (soap_out__cwmp__SetParameterValuesResponse_Status(soap, tag ? tag : "cwmp:SetParameterValuesResponse-Status", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _cwmp__SetParameterValuesResponse_Status * SOAP_FMAC4 soap_get__cwmp__SetParameterValuesResponse_Status(struct soap *soap, enum _cwmp__SetParameterValuesResponse_Status *p, const char *tag, const char *type)
{
	if ((p = soap_in__cwmp__SetParameterValuesResponse_Status(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes__cwmp__OptionStruct_IsTransferable[] =
{	{ (LONG64)_cwmp__OptionStruct_IsTransferable__0, "0" },
	{ (LONG64)_cwmp__OptionStruct_IsTransferable__1, "1" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__cwmp__OptionStruct_IsTransferable2s(struct soap *soap, enum _cwmp__OptionStruct_IsTransferable n)
{	const char *s = soap_code_str(soap_codes__cwmp__OptionStruct_IsTransferable, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__cwmp__OptionStruct_IsTransferable(struct soap *soap, const char *tag, int id, const enum _cwmp__OptionStruct_IsTransferable *a, const char *type)
{
	if (!type)
		type = "cwmp:OptionStruct-IsTransferable";
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__cwmp__OptionStruct_IsTransferable), type) || soap_send(soap, soap__cwmp__OptionStruct_IsTransferable2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_cwmp__OptionStruct_IsTransferable(struct soap *soap, const char *s, enum _cwmp__OptionStruct_IsTransferable *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes__cwmp__OptionStruct_IsTransferable, s);
	if (map)
		*a = (enum _cwmp__OptionStruct_IsTransferable)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum _cwmp__OptionStruct_IsTransferable)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _cwmp__OptionStruct_IsTransferable * SOAP_FMAC4 soap_in__cwmp__OptionStruct_IsTransferable(struct soap *soap, const char *tag, enum _cwmp__OptionStruct_IsTransferable *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _cwmp__OptionStruct_IsTransferable *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__cwmp__OptionStruct_IsTransferable, sizeof(enum _cwmp__OptionStruct_IsTransferable), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2_cwmp__OptionStruct_IsTransferable(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _cwmp__OptionStruct_IsTransferable *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__cwmp__OptionStruct_IsTransferable, SOAP_TYPE__cwmp__OptionStruct_IsTransferable, sizeof(enum _cwmp__OptionStruct_IsTransferable), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum _cwmp__OptionStruct_IsTransferable * SOAP_FMAC4 soap_new__cwmp__OptionStruct_IsTransferable(struct soap *soap, int n)
{
	enum _cwmp__OptionStruct_IsTransferable *p;
	enum _cwmp__OptionStruct_IsTransferable *a = (enum _cwmp__OptionStruct_IsTransferable*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum _cwmp__OptionStruct_IsTransferable));
	for (p = a; p && n--; p++)
		soap_default__cwmp__OptionStruct_IsTransferable(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__cwmp__OptionStruct_IsTransferable(struct soap *soap, const enum _cwmp__OptionStruct_IsTransferable *a, const char *tag, const char *type)
{
	if (soap_out__cwmp__OptionStruct_IsTransferable(soap, tag ? tag : "cwmp:OptionStruct-IsTransferable", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _cwmp__OptionStruct_IsTransferable * SOAP_FMAC4 soap_get__cwmp__OptionStruct_IsTransferable(struct soap *soap, enum _cwmp__OptionStruct_IsTransferable *p, const char *tag, const char *type)
{
	if ((p = soap_in__cwmp__OptionStruct_IsTransferable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes__cwmp__OptionStruct_Mode[] =
{	{ (LONG64)_cwmp__OptionStruct_Mode__0, "0" },
	{ (LONG64)_cwmp__OptionStruct_Mode__1, "1" },
	{ (LONG64)_cwmp__OptionStruct_Mode__2, "2" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__cwmp__OptionStruct_Mode2s(struct soap *soap, enum _cwmp__OptionStruct_Mode n)
{	const char *s = soap_code_str(soap_codes__cwmp__OptionStruct_Mode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__cwmp__OptionStruct_Mode(struct soap *soap, const char *tag, int id, const enum _cwmp__OptionStruct_Mode *a, const char *type)
{
	if (!type)
		type = "cwmp:OptionStruct-Mode";
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__cwmp__OptionStruct_Mode), type) || soap_send(soap, soap__cwmp__OptionStruct_Mode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_cwmp__OptionStruct_Mode(struct soap *soap, const char *s, enum _cwmp__OptionStruct_Mode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes__cwmp__OptionStruct_Mode, s);
	if (map)
		*a = (enum _cwmp__OptionStruct_Mode)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum _cwmp__OptionStruct_Mode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _cwmp__OptionStruct_Mode * SOAP_FMAC4 soap_in__cwmp__OptionStruct_Mode(struct soap *soap, const char *tag, enum _cwmp__OptionStruct_Mode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _cwmp__OptionStruct_Mode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__cwmp__OptionStruct_Mode, sizeof(enum _cwmp__OptionStruct_Mode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2_cwmp__OptionStruct_Mode(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _cwmp__OptionStruct_Mode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__cwmp__OptionStruct_Mode, SOAP_TYPE__cwmp__OptionStruct_Mode, sizeof(enum _cwmp__OptionStruct_Mode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum _cwmp__OptionStruct_Mode * SOAP_FMAC4 soap_new__cwmp__OptionStruct_Mode(struct soap *soap, int n)
{
	enum _cwmp__OptionStruct_Mode *p;
	enum _cwmp__OptionStruct_Mode *a = (enum _cwmp__OptionStruct_Mode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum _cwmp__OptionStruct_Mode));
	for (p = a; p && n--; p++)
		soap_default__cwmp__OptionStruct_Mode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__cwmp__OptionStruct_Mode(struct soap *soap, const enum _cwmp__OptionStruct_Mode *a, const char *tag, const char *type)
{
	if (soap_out__cwmp__OptionStruct_Mode(soap, tag ? tag : "cwmp:OptionStruct-Mode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _cwmp__OptionStruct_Mode * SOAP_FMAC4 soap_get__cwmp__OptionStruct_Mode(struct soap *soap, enum _cwmp__OptionStruct_Mode *p, const char *tag, const char *type)
{
	if ((p = soap_in__cwmp__OptionStruct_Mode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes__cwmp__OptionStruct_State[] =
{	{ (LONG64)_cwmp__OptionStruct_State__0, "0" },
	{ (LONG64)_cwmp__OptionStruct_State__1, "1" },
	{ (LONG64)_cwmp__OptionStruct_State__2, "2" },
	{ (LONG64)_cwmp__OptionStruct_State__3, "3" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__cwmp__OptionStruct_State2s(struct soap *soap, enum _cwmp__OptionStruct_State n)
{	const char *s = soap_code_str(soap_codes__cwmp__OptionStruct_State, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__cwmp__OptionStruct_State(struct soap *soap, const char *tag, int id, const enum _cwmp__OptionStruct_State *a, const char *type)
{
	if (!type)
		type = "cwmp:OptionStruct-State";
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__cwmp__OptionStruct_State), type) || soap_send(soap, soap__cwmp__OptionStruct_State2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_cwmp__OptionStruct_State(struct soap *soap, const char *s, enum _cwmp__OptionStruct_State *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes__cwmp__OptionStruct_State, s);
	if (map)
		*a = (enum _cwmp__OptionStruct_State)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum _cwmp__OptionStruct_State)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _cwmp__OptionStruct_State * SOAP_FMAC4 soap_in__cwmp__OptionStruct_State(struct soap *soap, const char *tag, enum _cwmp__OptionStruct_State *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _cwmp__OptionStruct_State *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__cwmp__OptionStruct_State, sizeof(enum _cwmp__OptionStruct_State), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2_cwmp__OptionStruct_State(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _cwmp__OptionStruct_State *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__cwmp__OptionStruct_State, SOAP_TYPE__cwmp__OptionStruct_State, sizeof(enum _cwmp__OptionStruct_State), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum _cwmp__OptionStruct_State * SOAP_FMAC4 soap_new__cwmp__OptionStruct_State(struct soap *soap, int n)
{
	enum _cwmp__OptionStruct_State *p;
	enum _cwmp__OptionStruct_State *a = (enum _cwmp__OptionStruct_State*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum _cwmp__OptionStruct_State));
	for (p = a; p && n--; p++)
		soap_default__cwmp__OptionStruct_State(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__cwmp__OptionStruct_State(struct soap *soap, const enum _cwmp__OptionStruct_State *a, const char *tag, const char *type)
{
	if (soap_out__cwmp__OptionStruct_State(soap, tag ? tag : "cwmp:OptionStruct-State", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _cwmp__OptionStruct_State * SOAP_FMAC4 soap_get__cwmp__OptionStruct_State(struct soap *soap, enum _cwmp__OptionStruct_State *p, const char *tag, const char *type)
{
	if ((p = soap_in__cwmp__OptionStruct_State(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes__cwmp__QueuedTransferStruct_State[] =
{	{ (LONG64)_cwmp__QueuedTransferStruct_State__1, "1" },
	{ (LONG64)_cwmp__QueuedTransferStruct_State__2, "2" },
	{ (LONG64)_cwmp__QueuedTransferStruct_State__3, "3" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__cwmp__QueuedTransferStruct_State2s(struct soap *soap, enum _cwmp__QueuedTransferStruct_State n)
{	const char *s = soap_code_str(soap_codes__cwmp__QueuedTransferStruct_State, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__cwmp__QueuedTransferStruct_State(struct soap *soap, const char *tag, int id, const enum _cwmp__QueuedTransferStruct_State *a, const char *type)
{
	if (!type)
		type = "cwmp:QueuedTransferStruct-State";
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__cwmp__QueuedTransferStruct_State), type) || soap_send(soap, soap__cwmp__QueuedTransferStruct_State2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_cwmp__QueuedTransferStruct_State(struct soap *soap, const char *s, enum _cwmp__QueuedTransferStruct_State *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes__cwmp__QueuedTransferStruct_State, s);
	if (map)
		*a = (enum _cwmp__QueuedTransferStruct_State)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum _cwmp__QueuedTransferStruct_State)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _cwmp__QueuedTransferStruct_State * SOAP_FMAC4 soap_in__cwmp__QueuedTransferStruct_State(struct soap *soap, const char *tag, enum _cwmp__QueuedTransferStruct_State *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _cwmp__QueuedTransferStruct_State *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__cwmp__QueuedTransferStruct_State, sizeof(enum _cwmp__QueuedTransferStruct_State), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2_cwmp__QueuedTransferStruct_State(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _cwmp__QueuedTransferStruct_State *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__cwmp__QueuedTransferStruct_State, SOAP_TYPE__cwmp__QueuedTransferStruct_State, sizeof(enum _cwmp__QueuedTransferStruct_State), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum _cwmp__QueuedTransferStruct_State * SOAP_FMAC4 soap_new__cwmp__QueuedTransferStruct_State(struct soap *soap, int n)
{
	enum _cwmp__QueuedTransferStruct_State *p;
	enum _cwmp__QueuedTransferStruct_State *a = (enum _cwmp__QueuedTransferStruct_State*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum _cwmp__QueuedTransferStruct_State));
	for (p = a; p && n--; p++)
		soap_default__cwmp__QueuedTransferStruct_State(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__cwmp__QueuedTransferStruct_State(struct soap *soap, const enum _cwmp__QueuedTransferStruct_State *a, const char *tag, const char *type)
{
	if (soap_out__cwmp__QueuedTransferStruct_State(soap, tag ? tag : "cwmp:QueuedTransferStruct-State", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _cwmp__QueuedTransferStruct_State * SOAP_FMAC4 soap_get__cwmp__QueuedTransferStruct_State(struct soap *soap, enum _cwmp__QueuedTransferStruct_State *p, const char *tag, const char *type)
{
	if ((p = soap_in__cwmp__QueuedTransferStruct_State(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes__cwmp__ParameterAttributeStruct_Notification[] =
{	{ (LONG64)_cwmp__ParameterAttributeStruct_Notification__0, "0" },
	{ (LONG64)_cwmp__ParameterAttributeStruct_Notification__1, "1" },
	{ (LONG64)_cwmp__ParameterAttributeStruct_Notification__2, "2" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__cwmp__ParameterAttributeStruct_Notification2s(struct soap *soap, enum _cwmp__ParameterAttributeStruct_Notification n)
{	const char *s = soap_code_str(soap_codes__cwmp__ParameterAttributeStruct_Notification, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__cwmp__ParameterAttributeStruct_Notification(struct soap *soap, const char *tag, int id, const enum _cwmp__ParameterAttributeStruct_Notification *a, const char *type)
{
	if (!type)
		type = "cwmp:ParameterAttributeStruct-Notification";
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__cwmp__ParameterAttributeStruct_Notification), type) || soap_send(soap, soap__cwmp__ParameterAttributeStruct_Notification2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_cwmp__ParameterAttributeStruct_Notification(struct soap *soap, const char *s, enum _cwmp__ParameterAttributeStruct_Notification *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes__cwmp__ParameterAttributeStruct_Notification, s);
	if (map)
		*a = (enum _cwmp__ParameterAttributeStruct_Notification)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum _cwmp__ParameterAttributeStruct_Notification)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _cwmp__ParameterAttributeStruct_Notification * SOAP_FMAC4 soap_in__cwmp__ParameterAttributeStruct_Notification(struct soap *soap, const char *tag, enum _cwmp__ParameterAttributeStruct_Notification *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _cwmp__ParameterAttributeStruct_Notification *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__cwmp__ParameterAttributeStruct_Notification, sizeof(enum _cwmp__ParameterAttributeStruct_Notification), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2_cwmp__ParameterAttributeStruct_Notification(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _cwmp__ParameterAttributeStruct_Notification *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__cwmp__ParameterAttributeStruct_Notification, SOAP_TYPE__cwmp__ParameterAttributeStruct_Notification, sizeof(enum _cwmp__ParameterAttributeStruct_Notification), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum _cwmp__ParameterAttributeStruct_Notification * SOAP_FMAC4 soap_new__cwmp__ParameterAttributeStruct_Notification(struct soap *soap, int n)
{
	enum _cwmp__ParameterAttributeStruct_Notification *p;
	enum _cwmp__ParameterAttributeStruct_Notification *a = (enum _cwmp__ParameterAttributeStruct_Notification*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum _cwmp__ParameterAttributeStruct_Notification));
	for (p = a; p && n--; p++)
		soap_default__cwmp__ParameterAttributeStruct_Notification(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__cwmp__ParameterAttributeStruct_Notification(struct soap *soap, const enum _cwmp__ParameterAttributeStruct_Notification *a, const char *tag, const char *type)
{
	if (soap_out__cwmp__ParameterAttributeStruct_Notification(soap, tag ? tag : "cwmp:ParameterAttributeStruct-Notification", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _cwmp__ParameterAttributeStruct_Notification * SOAP_FMAC4 soap_get__cwmp__ParameterAttributeStruct_Notification(struct soap *soap, enum _cwmp__ParameterAttributeStruct_Notification *p, const char *tag, const char *type)
{
	if ((p = soap_in__cwmp__ParameterAttributeStruct_Notification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes__cwmp__SetParameterAttributesStruct_Notification[] =
{	{ (LONG64)_cwmp__SetParameterAttributesStruct_Notification__0, "0" },
	{ (LONG64)_cwmp__SetParameterAttributesStruct_Notification__1, "1" },
	{ (LONG64)_cwmp__SetParameterAttributesStruct_Notification__2, "2" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__cwmp__SetParameterAttributesStruct_Notification2s(struct soap *soap, enum _cwmp__SetParameterAttributesStruct_Notification n)
{	const char *s = soap_code_str(soap_codes__cwmp__SetParameterAttributesStruct_Notification, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__cwmp__SetParameterAttributesStruct_Notification(struct soap *soap, const char *tag, int id, const enum _cwmp__SetParameterAttributesStruct_Notification *a, const char *type)
{
	if (!type)
		type = "cwmp:SetParameterAttributesStruct-Notification";
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__cwmp__SetParameterAttributesStruct_Notification), type) || soap_send(soap, soap__cwmp__SetParameterAttributesStruct_Notification2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_cwmp__SetParameterAttributesStruct_Notification(struct soap *soap, const char *s, enum _cwmp__SetParameterAttributesStruct_Notification *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes__cwmp__SetParameterAttributesStruct_Notification, s);
	if (map)
		*a = (enum _cwmp__SetParameterAttributesStruct_Notification)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum _cwmp__SetParameterAttributesStruct_Notification)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _cwmp__SetParameterAttributesStruct_Notification * SOAP_FMAC4 soap_in__cwmp__SetParameterAttributesStruct_Notification(struct soap *soap, const char *tag, enum _cwmp__SetParameterAttributesStruct_Notification *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _cwmp__SetParameterAttributesStruct_Notification *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__cwmp__SetParameterAttributesStruct_Notification, sizeof(enum _cwmp__SetParameterAttributesStruct_Notification), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2_cwmp__SetParameterAttributesStruct_Notification(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _cwmp__SetParameterAttributesStruct_Notification *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__cwmp__SetParameterAttributesStruct_Notification, SOAP_TYPE__cwmp__SetParameterAttributesStruct_Notification, sizeof(enum _cwmp__SetParameterAttributesStruct_Notification), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum _cwmp__SetParameterAttributesStruct_Notification * SOAP_FMAC4 soap_new__cwmp__SetParameterAttributesStruct_Notification(struct soap *soap, int n)
{
	enum _cwmp__SetParameterAttributesStruct_Notification *p;
	enum _cwmp__SetParameterAttributesStruct_Notification *a = (enum _cwmp__SetParameterAttributesStruct_Notification*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum _cwmp__SetParameterAttributesStruct_Notification));
	for (p = a; p && n--; p++)
		soap_default__cwmp__SetParameterAttributesStruct_Notification(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__cwmp__SetParameterAttributesStruct_Notification(struct soap *soap, const enum _cwmp__SetParameterAttributesStruct_Notification *a, const char *tag, const char *type)
{
	if (soap_out__cwmp__SetParameterAttributesStruct_Notification(soap, tag ? tag : "cwmp:SetParameterAttributesStruct-Notification", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _cwmp__SetParameterAttributesStruct_Notification * SOAP_FMAC4 soap_get__cwmp__SetParameterAttributesStruct_Notification(struct soap *soap, enum _cwmp__SetParameterAttributesStruct_Notification *p, const char *tag, const char *type)
{
	if ((p = soap_in__cwmp__SetParameterAttributesStruct_Notification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes__cwmp__FaultStruct_FaultCode[] =
{	{ (LONG64)_cwmp__FaultStruct_FaultCode__0, "0" },
	{ (LONG64)_cwmp__FaultStruct_FaultCode__9001, "9001" },
	{ (LONG64)_cwmp__FaultStruct_FaultCode__9002, "9002" },
	{ (LONG64)_cwmp__FaultStruct_FaultCode__9010, "9010" },
	{ (LONG64)_cwmp__FaultStruct_FaultCode__9011, "9011" },
	{ (LONG64)_cwmp__FaultStruct_FaultCode__9012, "9012" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__cwmp__FaultStruct_FaultCode2s(struct soap *soap, enum _cwmp__FaultStruct_FaultCode n)
{	const char *s = soap_code_str(soap_codes__cwmp__FaultStruct_FaultCode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__cwmp__FaultStruct_FaultCode(struct soap *soap, const char *tag, int id, const enum _cwmp__FaultStruct_FaultCode *a, const char *type)
{
	if (!type)
		type = "cwmp:FaultStruct-FaultCode";
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__cwmp__FaultStruct_FaultCode), type) || soap_send(soap, soap__cwmp__FaultStruct_FaultCode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_cwmp__FaultStruct_FaultCode(struct soap *soap, const char *s, enum _cwmp__FaultStruct_FaultCode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes__cwmp__FaultStruct_FaultCode, s);
	if (map)
		*a = (enum _cwmp__FaultStruct_FaultCode)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 9012)
			return soap->error = SOAP_TYPE;
		*a = (enum _cwmp__FaultStruct_FaultCode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _cwmp__FaultStruct_FaultCode * SOAP_FMAC4 soap_in__cwmp__FaultStruct_FaultCode(struct soap *soap, const char *tag, enum _cwmp__FaultStruct_FaultCode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _cwmp__FaultStruct_FaultCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__cwmp__FaultStruct_FaultCode, sizeof(enum _cwmp__FaultStruct_FaultCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2_cwmp__FaultStruct_FaultCode(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _cwmp__FaultStruct_FaultCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__cwmp__FaultStruct_FaultCode, SOAP_TYPE__cwmp__FaultStruct_FaultCode, sizeof(enum _cwmp__FaultStruct_FaultCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum _cwmp__FaultStruct_FaultCode * SOAP_FMAC4 soap_new__cwmp__FaultStruct_FaultCode(struct soap *soap, int n)
{
	enum _cwmp__FaultStruct_FaultCode *p;
	enum _cwmp__FaultStruct_FaultCode *a = (enum _cwmp__FaultStruct_FaultCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum _cwmp__FaultStruct_FaultCode));
	for (p = a; p && n--; p++)
		soap_default__cwmp__FaultStruct_FaultCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__cwmp__FaultStruct_FaultCode(struct soap *soap, const enum _cwmp__FaultStruct_FaultCode *a, const char *tag, const char *type)
{
	if (soap_out__cwmp__FaultStruct_FaultCode(soap, tag ? tag : "cwmp:FaultStruct-FaultCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _cwmp__FaultStruct_FaultCode * SOAP_FMAC4 soap_get__cwmp__FaultStruct_FaultCode(struct soap *soap, enum _cwmp__FaultStruct_FaultCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__cwmp__FaultStruct_FaultCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_xsd__boolean[] =
{	{ (LONG64)xsd__boolean__false_, "false" },
	{ (LONG64)xsd__boolean__true_, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_xsd__boolean2s(struct soap *soap, enum xsd__boolean n)
{
	(void)soap; /* appease -Wall -Werror */
	return soap_code_str(soap_codes_xsd__boolean, n != 0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__boolean(struct soap *soap, const char *tag, int id, const enum xsd__boolean *a, const char *type)
{
	if (!type)
		type = "xsd:boolean";
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xsd__boolean), type) || soap_send(soap, soap_xsd__boolean2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2xsd__boolean(struct soap *soap, const char *s, enum xsd__boolean *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_xsd__boolean, s);
	if (map)
		*a = (enum xsd__boolean)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum xsd__boolean)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_in_xsd__boolean(struct soap *soap, const char *tag, enum xsd__boolean *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (enum xsd__boolean *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__boolean, sizeof(enum xsd__boolean), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2xsd__boolean(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum xsd__boolean *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__boolean, SOAP_TYPE_xsd__boolean, sizeof(enum xsd__boolean), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_new_xsd__boolean(struct soap *soap, int n)
{
	enum xsd__boolean *p;
	enum xsd__boolean *a = (enum xsd__boolean*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(enum xsd__boolean));
	for (p = a; p && n--; p++)
		soap_default_xsd__boolean(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__boolean(struct soap *soap, const enum xsd__boolean *a, const char *tag, const char *type)
{
	if (soap_out_xsd__boolean(soap, tag ? tag : "xsd:boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum xsd__boolean * SOAP_FMAC4 soap_get_xsd__boolean(struct soap *soap, enum xsd__boolean *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__boolean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->faultcode);
	soap_serialize_string(soap, (char*const*)&a->faultstring);
	soap_serialize_string(soap, (char*const*)&a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Node);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, "xsd:QName"))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, (char*const*)&a->faultstring, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, (char*const*)&a->faultactor, "xsd:string"))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, (char*const*)&a->SOAP_ENV__Node, "xsd:string"))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, (char*const*)&a->SOAP_ENV__Role, "xsd:string"))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", (char**)&a->faultcode, "xsd:QName"))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", (char**)&a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", (char**)&a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", (char**)&a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", (char**)&a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_new_SOAP_ENV__Fault(struct soap *soap, int n)
{
	struct SOAP_ENV__Fault *p;
	struct SOAP_ENV__Fault *a = (struct SOAP_ENV__Fault*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct SOAP_ENV__Fault));
	for (p = a; p && n--; p++)
		soap_default_SOAP_ENV__Fault(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Fault(soap, tag ? tag : "SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, (char*const*)&a->SOAP_ENV__Text, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", (char**)&a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_new_SOAP_ENV__Reason(struct soap *soap, int n)
{
	struct SOAP_ENV__Reason *p;
	struct SOAP_ENV__Reason *a = (struct SOAP_ENV__Reason*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct SOAP_ENV__Reason));
	for (p = a; p && n--; p++)
		soap_default_SOAP_ENV__Reason(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_new_SOAP_ENV__Detail(struct soap *soap, int n)
{
	struct SOAP_ENV__Detail *p;
	struct SOAP_ENV__Detail *a = (struct SOAP_ENV__Detail*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct SOAP_ENV__Detail));
	for (p = a; p && n--; p++)
		soap_default_SOAP_ENV__Detail(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, "xsd:QName"))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", (char**)&a->SOAP_ENV__Value, "xsd:QName"))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_new_SOAP_ENV__Code(struct soap *soap, int n)
{
	struct SOAP_ENV__Code *p;
	struct SOAP_ENV__Code *a = (struct SOAP_ENV__Code*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct SOAP_ENV__Code));
	for (p = a; p && n--; p++)
		soap_default_SOAP_ENV__Code(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_cwmp__Inform(struct soap *soap, struct cwmp__Inform *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->DeviceId = NULL;
	a->Event = NULL;
	soap_default_unsignedInt(soap, &a->MaxEnvelopes);
	soap_default_dateTime(soap, &a->CurrentTime);
	soap_default_unsignedInt(soap, &a->RetryCount);
	a->ParameterList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_cwmp__Inform(struct soap *soap, const struct cwmp__Inform *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTocwmp__DeviceIdStruct(soap, &a->DeviceId);
	soap_serialize_PointerToEventList(soap, &a->Event);
	soap_embedded(soap, &a->CurrentTime, SOAP_TYPE_dateTime);
	soap_serialize_PointerToParameterValueList(soap, &a->ParameterList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_cwmp__Inform(struct soap *soap, const char *tag, int id, const struct cwmp__Inform *a, const char *type)
{
	if (!type)
		type = "cwmp:Inform";
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cwmp__Inform), type))
		return soap->error;
	if (soap_out_PointerTocwmp__DeviceIdStruct(soap, "DeviceId", -1, &a->DeviceId, "cwmp:DeviceIdStruct"))
		return soap->error;
	if (soap_out_PointerToEventList(soap, "Event", -1, &a->Event, "cwmp:EventStruct"))
		return soap->error;
	if (soap_out_unsignedInt(soap, "MaxEnvelopes", -1, &a->MaxEnvelopes, "xsd:unsignedInt"))
		return soap->error;
	if (soap_out_dateTime(soap, "CurrentTime", -1, &a->CurrentTime, "xsd:dateTime"))
		return soap->error;
	if (soap_out_unsignedInt(soap, "RetryCount", -1, &a->RetryCount, "xsd:unsignedInt"))
		return soap->error;
	if (soap_out_PointerToParameterValueList(soap, "ParameterList", -1, &a->ParameterList, "cwmp:ParameterValueStruct"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct cwmp__Inform * SOAP_FMAC4 soap_in_cwmp__Inform(struct soap *soap, const char *tag, struct cwmp__Inform *a, const char *type)
{
	size_t soap_flag_DeviceId = 1;
	size_t soap_flag_Event = 1;
	size_t soap_flag_MaxEnvelopes = 1;
	size_t soap_flag_CurrentTime = 1;
	size_t soap_flag_RetryCount = 1;
	size_t soap_flag_ParameterList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct cwmp__Inform *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cwmp__Inform, sizeof(struct cwmp__Inform), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_cwmp__Inform(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DeviceId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTocwmp__DeviceIdStruct(soap, "DeviceId", &a->DeviceId, "cwmp:DeviceIdStruct"))
				{	soap_flag_DeviceId--;
					continue;
				}
			if (soap_flag_Event && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToEventList(soap, "Event", &a->Event, "cwmp:EventStruct"))
				{	soap_flag_Event--;
					continue;
				}
			if (soap_flag_MaxEnvelopes && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "MaxEnvelopes", &a->MaxEnvelopes, "xsd:unsignedInt"))
				{	soap_flag_MaxEnvelopes--;
					continue;
				}
			if (soap_flag_CurrentTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_dateTime(soap, "CurrentTime", &a->CurrentTime, "xsd:dateTime"))
				{	soap_flag_CurrentTime--;
					continue;
				}
			if (soap_flag_RetryCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "RetryCount", &a->RetryCount, "xsd:unsignedInt"))
				{	soap_flag_RetryCount--;
					continue;
				}
			if (soap_flag_ParameterList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToParameterValueList(soap, "ParameterList", &a->ParameterList, "cwmp:ParameterValueStruct"))
				{	soap_flag_ParameterList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_MaxEnvelopes > 0 || soap_flag_CurrentTime > 0 || soap_flag_RetryCount > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct cwmp__Inform *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_cwmp__Inform, SOAP_TYPE_cwmp__Inform, sizeof(struct cwmp__Inform), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct cwmp__Inform * SOAP_FMAC4 soap_new_cwmp__Inform(struct soap *soap, int n)
{
	struct cwmp__Inform *p;
	struct cwmp__Inform *a = (struct cwmp__Inform*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct cwmp__Inform));
	for (p = a; p && n--; p++)
		soap_default_cwmp__Inform(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_cwmp__Inform(struct soap *soap, const struct cwmp__Inform *a, const char *tag, const char *type)
{
	if (soap_out_cwmp__Inform(soap, tag ? tag : "cwmp:Inform", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct cwmp__Inform * SOAP_FMAC4 soap_get_cwmp__Inform(struct soap *soap, struct cwmp__Inform *p, const char *tag, const char *type)
{
	if ((p = soap_in_cwmp__Inform(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_cwmp__InformResponse(struct soap *soap, struct cwmp__InformResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_unsignedInt(soap, &a->MaxEnvelopes);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_cwmp__InformResponse(struct soap *soap, const struct cwmp__InformResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_cwmp__InformResponse(struct soap *soap, const char *tag, int id, const struct cwmp__InformResponse *a, const char *type)
{
	if (!type)
		type = "cwmp:InformResponse";
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cwmp__InformResponse), type))
		return soap->error;
	if (soap_out_unsignedInt(soap, "MaxEnvelopes", -1, &a->MaxEnvelopes, "xsd:unsignedInt"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct cwmp__InformResponse * SOAP_FMAC4 soap_in_cwmp__InformResponse(struct soap *soap, const char *tag, struct cwmp__InformResponse *a, const char *type)
{
	size_t soap_flag_MaxEnvelopes = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct cwmp__InformResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cwmp__InformResponse, sizeof(struct cwmp__InformResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_cwmp__InformResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MaxEnvelopes && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "MaxEnvelopes", &a->MaxEnvelopes, "xsd:unsignedInt"))
				{	soap_flag_MaxEnvelopes--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_MaxEnvelopes > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct cwmp__InformResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_cwmp__InformResponse, SOAP_TYPE_cwmp__InformResponse, sizeof(struct cwmp__InformResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct cwmp__InformResponse * SOAP_FMAC4 soap_new_cwmp__InformResponse(struct soap *soap, int n)
{
	struct cwmp__InformResponse *p;
	struct cwmp__InformResponse *a = (struct cwmp__InformResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct cwmp__InformResponse));
	for (p = a; p && n--; p++)
		soap_default_cwmp__InformResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_cwmp__InformResponse(struct soap *soap, const struct cwmp__InformResponse *a, const char *tag, const char *type)
{
	if (soap_out_cwmp__InformResponse(soap, tag ? tag : "cwmp:InformResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct cwmp__InformResponse * SOAP_FMAC4 soap_get_cwmp__InformResponse(struct soap *soap, struct cwmp__InformResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_cwmp__InformResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->cwmp__ID);
	soap_default_xsd__boolean(soap, &a->cwmp__HoldRequests);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->cwmp__ID);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_string(soap, "cwmp:ID", -1, (char*const*)&a->cwmp__ID, "xsd:string"))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_xsd__boolean(soap, "cwmp:HoldRequests", -1, &a->cwmp__HoldRequests, "xsd:boolean"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	size_t soap_flag_cwmp__ID = 1;
	size_t soap_flag_cwmp__HoldRequests = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cwmp__ID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "cwmp:ID", (char**)&a->cwmp__ID, "xsd:string"))
				{	soap_flag_cwmp__ID--;
					continue;
				}
			if (soap_flag_cwmp__HoldRequests && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "cwmp:HoldRequests", &a->cwmp__HoldRequests, "xsd:boolean"))
				{	soap_flag_cwmp__HoldRequests--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cwmp__HoldRequests > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_new_SOAP_ENV__Header(struct soap *soap, int n)
{
	struct SOAP_ENV__Header *p;
	struct SOAP_ENV__Header *a = (struct SOAP_ENV__Header*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct SOAP_ENV__Header));
	for (p = a; p && n--; p++)
		soap_default_SOAP_ENV__Header(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default__cwmp__HoldRequests(struct soap *soap, struct _cwmp__HoldRequests *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->__item);
	soap_default_string(soap, &a->SOAP_ENV__mustUnderstand);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__cwmp__HoldRequests(struct soap *soap, const struct _cwmp__HoldRequests *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__cwmp__HoldRequests(struct soap *soap, const char *tag, int id, const struct _cwmp__HoldRequests *a, const char *type)
{
	if (a->SOAP_ENV__mustUnderstand)
		soap_set_attr(soap, "SOAP-ENV:mustUnderstand", soap_string2s(soap, a->SOAP_ENV__mustUnderstand), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_xsd__boolean(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct _cwmp__HoldRequests * SOAP_FMAC4 soap_in__cwmp__HoldRequests(struct soap *soap, const char *tag, struct _cwmp__HoldRequests *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct _cwmp__HoldRequests *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__cwmp__HoldRequests, sizeof(struct _cwmp__HoldRequests), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__cwmp__HoldRequests(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "SOAP-ENV:mustUnderstand", 1), &a->SOAP_ENV__mustUnderstand))
		return NULL;
	if (!soap_in_xsd__boolean(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _cwmp__HoldRequests * SOAP_FMAC4 soap_new__cwmp__HoldRequests(struct soap *soap, int n)
{
	struct _cwmp__HoldRequests *p;
	struct _cwmp__HoldRequests *a = (struct _cwmp__HoldRequests*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _cwmp__HoldRequests));
	for (p = a; p && n--; p++)
		soap_default__cwmp__HoldRequests(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__cwmp__HoldRequests(struct soap *soap, const struct _cwmp__HoldRequests *a, const char *tag, const char *type)
{
	if (soap_out__cwmp__HoldRequests(soap, tag ? tag : "cwmp:HoldRequests", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _cwmp__HoldRequests * SOAP_FMAC4 soap_get__cwmp__HoldRequests(struct soap *soap, struct _cwmp__HoldRequests *p, const char *tag, const char *type)
{
	if ((p = soap_in__cwmp__HoldRequests(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__cwmp__ID(struct soap *soap, struct _cwmp__ID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->SOAP_ENV__mustUnderstand);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__cwmp__ID(struct soap *soap, const struct _cwmp__ID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__cwmp__ID(struct soap *soap, const char *tag, int id, const struct _cwmp__ID *a, const char *type)
{
	if (a->SOAP_ENV__mustUnderstand)
		soap_set_attr(soap, "SOAP-ENV:mustUnderstand", soap_string2s(soap, a->SOAP_ENV__mustUnderstand), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _cwmp__ID * SOAP_FMAC4 soap_in__cwmp__ID(struct soap *soap, const char *tag, struct _cwmp__ID *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct _cwmp__ID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__cwmp__ID, sizeof(struct _cwmp__ID), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__cwmp__ID(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "SOAP-ENV:mustUnderstand", 1), &a->SOAP_ENV__mustUnderstand))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _cwmp__ID * SOAP_FMAC4 soap_new__cwmp__ID(struct soap *soap, int n)
{
	struct _cwmp__ID *p;
	struct _cwmp__ID *a = (struct _cwmp__ID*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _cwmp__ID));
	for (p = a; p && n--; p++)
		soap_default__cwmp__ID(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__cwmp__ID(struct soap *soap, const struct _cwmp__ID *a, const char *tag, const char *type)
{
	if (soap_out__cwmp__ID(soap, tag ? tag : "cwmp:ID", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _cwmp__ID * SOAP_FMAC4 soap_get__cwmp__ID(struct soap *soap, struct _cwmp__ID *p, const char *tag, const char *type)
{
	if ((p = soap_in__cwmp__ID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__cwmp__RequestDownloadResponse(struct soap *soap, struct _cwmp__RequestDownloadResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__cwmp__RequestDownloadResponse(struct soap *soap, const struct _cwmp__RequestDownloadResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__cwmp__RequestDownloadResponse(struct soap *soap, const char *tag, int id, const struct _cwmp__RequestDownloadResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__cwmp__RequestDownloadResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _cwmp__RequestDownloadResponse * SOAP_FMAC4 soap_in__cwmp__RequestDownloadResponse(struct soap *soap, const char *tag, struct _cwmp__RequestDownloadResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _cwmp__RequestDownloadResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__cwmp__RequestDownloadResponse, sizeof(struct _cwmp__RequestDownloadResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__cwmp__RequestDownloadResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _cwmp__RequestDownloadResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__cwmp__RequestDownloadResponse, SOAP_TYPE__cwmp__RequestDownloadResponse, sizeof(struct _cwmp__RequestDownloadResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _cwmp__RequestDownloadResponse * SOAP_FMAC4 soap_new__cwmp__RequestDownloadResponse(struct soap *soap, int n)
{
	struct _cwmp__RequestDownloadResponse *p;
	struct _cwmp__RequestDownloadResponse *a = (struct _cwmp__RequestDownloadResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _cwmp__RequestDownloadResponse));
	for (p = a; p && n--; p++)
		soap_default__cwmp__RequestDownloadResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__cwmp__RequestDownloadResponse(struct soap *soap, const struct _cwmp__RequestDownloadResponse *a, const char *tag, const char *type)
{
	if (soap_out__cwmp__RequestDownloadResponse(soap, tag ? tag : "cwmp:RequestDownloadResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _cwmp__RequestDownloadResponse * SOAP_FMAC4 soap_get__cwmp__RequestDownloadResponse(struct soap *soap, struct _cwmp__RequestDownloadResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__cwmp__RequestDownloadResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_FileTypeArg(struct soap *soap, struct FileTypeArg *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__ptrArgStruct = NULL;
	a->__size = 0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_FileTypeArg(struct soap *soap, const struct FileTypeArg *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__ptrArgStruct && !soap_array_reference(soap, a, a->__ptrArgStruct, a->__size, SOAP_TYPE_FileTypeArg))
	{	int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTocwmp__ArgStruct(soap, a->__ptrArgStruct + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_FileTypeArg(struct soap *soap, const char *tag, int id, const struct FileTypeArg *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptrArgStruct ? soap_putsizesoffsets(soap, "cwmp:ArgStruct", &a->__size, NULL, 1) : NULL;
	id = soap_element_id(soap, tag, id, a, a->__ptrArgStruct, a->__size, type, SOAP_TYPE_FileTypeArg, NULL);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTocwmp__ArgStruct(soap, "ArgStruct", -1, &a->__ptrArgStruct[i], "cwmp:ArgStruct");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct FileTypeArg * SOAP_FMAC4 soap_in_FileTypeArg(struct soap *soap, const char *tag, struct FileTypeArg *a, const char *type)
{	int i, j;
	struct cwmp__ArgStruct **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct FileTypeArg *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_FileTypeArg, sizeof(struct FileTypeArg), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_FileTypeArg(soap, a);
	if (soap->body && !*soap->href)
	{
		if (*soap->arraySize)
		{
			soap_getsizes(soap->arraySize, &a->__size, 1);
			a->__size -= j = soap_getoffsets(soap->arrayOffset, &a->__size, NULL, 1);
			if ((size_t)a->__size > soap->maxoccurs)
			{	soap->error = SOAP_OCCURS;
				return NULL;
			}
			a->__ptrArgStruct = (struct cwmp__ArgStruct **)soap_malloc(soap, sizeof(struct cwmp__ArgStruct *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptrArgStruct[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTocwmp__ArgStruct(soap, NULL, a->__ptrArgStruct + i, "cwmp:ArgStruct"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_alloc_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct cwmp__ArgStruct **)soap_push_block(soap, NULL, sizeof(struct cwmp__ArgStruct *));
				if (!p)
					break;
				*p = NULL;
				if (!soap_in_PointerTocwmp__ArgStruct(soap, NULL, p, "cwmp:ArgStruct"))
				{	if (soap->error == SOAP_NO_TAG)
						soap->error = SOAP_OK;
					soap_pop_block(soap, NULL);
					break;
				}
				if ((size_t)a->__size > soap->maxoccurs)
				{	soap->error = SOAP_OCCURS;
					return NULL;
				}
			}
			a->__ptrArgStruct = (struct cwmp__ArgStruct **)soap_save_block(soap, NULL, NULL, 1);
		}
		if (soap->error || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct FileTypeArg *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_FileTypeArg, SOAP_TYPE_FileTypeArg, sizeof(struct FileTypeArg), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct FileTypeArg * SOAP_FMAC4 soap_new_FileTypeArg(struct soap *soap, int n)
{
	struct FileTypeArg *p;
	struct FileTypeArg *a = (struct FileTypeArg*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct FileTypeArg));
	for (p = a; p && n--; p++)
		soap_default_FileTypeArg(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_FileTypeArg(struct soap *soap, const struct FileTypeArg *a, const char *tag, const char *type)
{
	if (soap_out_FileTypeArg(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct FileTypeArg * SOAP_FMAC4 soap_get_FileTypeArg(struct soap *soap, struct FileTypeArg *p, const char *tag, const char *type)
{
	if ((p = soap_in_FileTypeArg(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__cwmp__RequestDownload(struct soap *soap, struct _cwmp__RequestDownload *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->FileType);
	a->FileTypeArg = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__cwmp__RequestDownload(struct soap *soap, const struct _cwmp__RequestDownload *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->FileType);
	soap_serialize_PointerToFileTypeArg(soap, &a->FileTypeArg);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__cwmp__RequestDownload(struct soap *soap, const char *tag, int id, const struct _cwmp__RequestDownload *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__cwmp__RequestDownload), type))
		return soap->error;
	if (!a->FileType)
	{	if (soap_element_empty(soap, "FileType"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "FileType", -1, (char*const*)&a->FileType, "xsd:string"))
		return soap->error;
	if (!a->FileTypeArg)
	{	if (soap_element_empty(soap, "FileTypeArg"))
			return soap->error;
	}
	else
	if (soap_out_PointerToFileTypeArg(soap, "FileTypeArg", -1, &a->FileTypeArg, "cwmp:ArgStruct"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _cwmp__RequestDownload * SOAP_FMAC4 soap_in__cwmp__RequestDownload(struct soap *soap, const char *tag, struct _cwmp__RequestDownload *a, const char *type)
{
	size_t soap_flag_FileType = 1;
	size_t soap_flag_FileTypeArg = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _cwmp__RequestDownload *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__cwmp__RequestDownload, sizeof(struct _cwmp__RequestDownload), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__cwmp__RequestDownload(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FileType && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "FileType", (char**)&a->FileType, "xsd:string"))
				{	soap_flag_FileType--;
					continue;
				}
			if (soap_flag_FileTypeArg && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToFileTypeArg(soap, "FileTypeArg", &a->FileTypeArg, "cwmp:ArgStruct"))
				{	soap_flag_FileTypeArg--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->FileType || !a->FileTypeArg))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _cwmp__RequestDownload *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__cwmp__RequestDownload, SOAP_TYPE__cwmp__RequestDownload, sizeof(struct _cwmp__RequestDownload), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _cwmp__RequestDownload * SOAP_FMAC4 soap_new__cwmp__RequestDownload(struct soap *soap, int n)
{
	struct _cwmp__RequestDownload *p;
	struct _cwmp__RequestDownload *a = (struct _cwmp__RequestDownload*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _cwmp__RequestDownload));
	for (p = a; p && n--; p++)
		soap_default__cwmp__RequestDownload(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__cwmp__RequestDownload(struct soap *soap, const struct _cwmp__RequestDownload *a, const char *tag, const char *type)
{
	if (soap_out__cwmp__RequestDownload(soap, tag ? tag : "cwmp:RequestDownload", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _cwmp__RequestDownload * SOAP_FMAC4 soap_get__cwmp__RequestDownload(struct soap *soap, struct _cwmp__RequestDownload *p, const char *tag, const char *type)
{
	if ((p = soap_in__cwmp__RequestDownload(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__cwmp__KickedResponse(struct soap *soap, struct _cwmp__KickedResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->NextURL);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__cwmp__KickedResponse(struct soap *soap, const struct _cwmp__KickedResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->NextURL);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__cwmp__KickedResponse(struct soap *soap, const char *tag, int id, const struct _cwmp__KickedResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__cwmp__KickedResponse), type))
		return soap->error;
	if (!a->NextURL)
	{	if (soap_element_empty(soap, "NextURL"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "NextURL", -1, (char*const*)&a->NextURL, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _cwmp__KickedResponse * SOAP_FMAC4 soap_in__cwmp__KickedResponse(struct soap *soap, const char *tag, struct _cwmp__KickedResponse *a, const char *type)
{
	size_t soap_flag_NextURL = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _cwmp__KickedResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__cwmp__KickedResponse, sizeof(struct _cwmp__KickedResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__cwmp__KickedResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NextURL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "NextURL", (char**)&a->NextURL, "xsd:string"))
				{	soap_flag_NextURL--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->NextURL))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _cwmp__KickedResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__cwmp__KickedResponse, SOAP_TYPE__cwmp__KickedResponse, sizeof(struct _cwmp__KickedResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _cwmp__KickedResponse * SOAP_FMAC4 soap_new__cwmp__KickedResponse(struct soap *soap, int n)
{
	struct _cwmp__KickedResponse *p;
	struct _cwmp__KickedResponse *a = (struct _cwmp__KickedResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _cwmp__KickedResponse));
	for (p = a; p && n--; p++)
		soap_default__cwmp__KickedResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__cwmp__KickedResponse(struct soap *soap, const struct _cwmp__KickedResponse *a, const char *tag, const char *type)
{
	if (soap_out__cwmp__KickedResponse(soap, tag ? tag : "cwmp:KickedResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _cwmp__KickedResponse * SOAP_FMAC4 soap_get__cwmp__KickedResponse(struct soap *soap, struct _cwmp__KickedResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__cwmp__KickedResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__cwmp__Kicked(struct soap *soap, struct _cwmp__Kicked *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Command);
	soap_default_string(soap, &a->Referer);
	soap_default_string(soap, &a->Arg);
	soap_default_string(soap, &a->Next);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__cwmp__Kicked(struct soap *soap, const struct _cwmp__Kicked *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Command);
	soap_serialize_string(soap, (char*const*)&a->Referer);
	soap_serialize_string(soap, (char*const*)&a->Arg);
	soap_serialize_string(soap, (char*const*)&a->Next);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__cwmp__Kicked(struct soap *soap, const char *tag, int id, const struct _cwmp__Kicked *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__cwmp__Kicked), type))
		return soap->error;
	if (!a->Command)
	{	if (soap_element_empty(soap, "Command"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "Command", -1, (char*const*)&a->Command, "xsd:string"))
		return soap->error;
	if (!a->Referer)
	{	if (soap_element_empty(soap, "Referer"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "Referer", -1, (char*const*)&a->Referer, "xsd:string"))
		return soap->error;
	if (!a->Arg)
	{	if (soap_element_empty(soap, "Arg"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "Arg", -1, (char*const*)&a->Arg, "xsd:string"))
		return soap->error;
	if (!a->Next)
	{	if (soap_element_empty(soap, "Next"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "Next", -1, (char*const*)&a->Next, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _cwmp__Kicked * SOAP_FMAC4 soap_in__cwmp__Kicked(struct soap *soap, const char *tag, struct _cwmp__Kicked *a, const char *type)
{
	size_t soap_flag_Command = 1;
	size_t soap_flag_Referer = 1;
	size_t soap_flag_Arg = 1;
	size_t soap_flag_Next = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _cwmp__Kicked *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__cwmp__Kicked, sizeof(struct _cwmp__Kicked), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__cwmp__Kicked(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Command && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Command", (char**)&a->Command, "xsd:string"))
				{	soap_flag_Command--;
					continue;
				}
			if (soap_flag_Referer && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Referer", (char**)&a->Referer, "xsd:string"))
				{	soap_flag_Referer--;
					continue;
				}
			if (soap_flag_Arg && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Arg", (char**)&a->Arg, "xsd:string"))
				{	soap_flag_Arg--;
					continue;
				}
			if (soap_flag_Next && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Next", (char**)&a->Next, "xsd:string"))
				{	soap_flag_Next--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Command || !a->Referer || !a->Arg || !a->Next))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _cwmp__Kicked *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__cwmp__Kicked, SOAP_TYPE__cwmp__Kicked, sizeof(struct _cwmp__Kicked), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _cwmp__Kicked * SOAP_FMAC4 soap_new__cwmp__Kicked(struct soap *soap, int n)
{
	struct _cwmp__Kicked *p;
	struct _cwmp__Kicked *a = (struct _cwmp__Kicked*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _cwmp__Kicked));
	for (p = a; p && n--; p++)
		soap_default__cwmp__Kicked(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__cwmp__Kicked(struct soap *soap, const struct _cwmp__Kicked *a, const char *tag, const char *type)
{
	if (soap_out__cwmp__Kicked(soap, tag ? tag : "cwmp:Kicked", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _cwmp__Kicked * SOAP_FMAC4 soap_get__cwmp__Kicked(struct soap *soap, struct _cwmp__Kicked *p, const char *tag, const char *type)
{
	if ((p = soap_in__cwmp__Kicked(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__cwmp__TransferCompleteResponse(struct soap *soap, struct _cwmp__TransferCompleteResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__cwmp__TransferCompleteResponse(struct soap *soap, const struct _cwmp__TransferCompleteResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__cwmp__TransferCompleteResponse(struct soap *soap, const char *tag, int id, const struct _cwmp__TransferCompleteResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__cwmp__TransferCompleteResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _cwmp__TransferCompleteResponse * SOAP_FMAC4 soap_in__cwmp__TransferCompleteResponse(struct soap *soap, const char *tag, struct _cwmp__TransferCompleteResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _cwmp__TransferCompleteResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__cwmp__TransferCompleteResponse, sizeof(struct _cwmp__TransferCompleteResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__cwmp__TransferCompleteResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _cwmp__TransferCompleteResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__cwmp__TransferCompleteResponse, SOAP_TYPE__cwmp__TransferCompleteResponse, sizeof(struct _cwmp__TransferCompleteResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _cwmp__TransferCompleteResponse * SOAP_FMAC4 soap_new__cwmp__TransferCompleteResponse(struct soap *soap, int n)
{
	struct _cwmp__TransferCompleteResponse *p;
	struct _cwmp__TransferCompleteResponse *a = (struct _cwmp__TransferCompleteResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _cwmp__TransferCompleteResponse));
	for (p = a; p && n--; p++)
		soap_default__cwmp__TransferCompleteResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__cwmp__TransferCompleteResponse(struct soap *soap, const struct _cwmp__TransferCompleteResponse *a, const char *tag, const char *type)
{
	if (soap_out__cwmp__TransferCompleteResponse(soap, tag ? tag : "cwmp:TransferCompleteResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _cwmp__TransferCompleteResponse * SOAP_FMAC4 soap_get__cwmp__TransferCompleteResponse(struct soap *soap, struct _cwmp__TransferCompleteResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__cwmp__TransferCompleteResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__cwmp__TransferComplete(struct soap *soap, struct _cwmp__TransferComplete *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_cwmp__CommandKeyType(soap, &a->CommandKey);
	a->FaultStruct = NULL;
	soap_default_dateTime(soap, &a->StartTime);
	soap_default_dateTime(soap, &a->CompleteTime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__cwmp__TransferComplete(struct soap *soap, const struct _cwmp__TransferComplete *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_cwmp__CommandKeyType(soap, (char*const*)&a->CommandKey);
	soap_serialize_PointerTocwmp__FaultStruct(soap, &a->FaultStruct);
	soap_embedded(soap, &a->StartTime, SOAP_TYPE_dateTime);
	soap_embedded(soap, &a->CompleteTime, SOAP_TYPE_dateTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__cwmp__TransferComplete(struct soap *soap, const char *tag, int id, const struct _cwmp__TransferComplete *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__cwmp__TransferComplete), type))
		return soap->error;
	if (!a->CommandKey)
	{	if (soap_element_empty(soap, "CommandKey"))
			return soap->error;
	}
	else
	if (soap_out_cwmp__CommandKeyType(soap, "CommandKey", -1, (char*const*)&a->CommandKey, "cwmp:CommandKeyType"))
		return soap->error;
	if (!a->FaultStruct)
	{	if (soap_element_empty(soap, "FaultStruct"))
			return soap->error;
	}
	else
	if (soap_out_PointerTocwmp__FaultStruct(soap, "FaultStruct", -1, &a->FaultStruct, "cwmp:FaultStruct"))
		return soap->error;
	if (soap_out_dateTime(soap, "StartTime", -1, &a->StartTime, "xsd:dateTime"))
		return soap->error;
	if (soap_out_dateTime(soap, "CompleteTime", -1, &a->CompleteTime, "xsd:dateTime"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _cwmp__TransferComplete * SOAP_FMAC4 soap_in__cwmp__TransferComplete(struct soap *soap, const char *tag, struct _cwmp__TransferComplete *a, const char *type)
{
	size_t soap_flag_CommandKey = 1;
	size_t soap_flag_FaultStruct = 1;
	size_t soap_flag_StartTime = 1;
	size_t soap_flag_CompleteTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _cwmp__TransferComplete *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__cwmp__TransferComplete, sizeof(struct _cwmp__TransferComplete), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__cwmp__TransferComplete(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CommandKey && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_cwmp__CommandKeyType(soap, "CommandKey", (char**)&a->CommandKey, "cwmp:CommandKeyType"))
				{	soap_flag_CommandKey--;
					continue;
				}
			if (soap_flag_FaultStruct && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTocwmp__FaultStruct(soap, "FaultStruct", &a->FaultStruct, "cwmp:FaultStruct"))
				{	soap_flag_FaultStruct--;
					continue;
				}
			if (soap_flag_StartTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_dateTime(soap, "StartTime", &a->StartTime, "xsd:dateTime"))
				{	soap_flag_StartTime--;
					continue;
				}
			if (soap_flag_CompleteTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_dateTime(soap, "CompleteTime", &a->CompleteTime, "xsd:dateTime"))
				{	soap_flag_CompleteTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->CommandKey || !a->FaultStruct || soap_flag_StartTime > 0 || soap_flag_CompleteTime > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _cwmp__TransferComplete *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__cwmp__TransferComplete, SOAP_TYPE__cwmp__TransferComplete, sizeof(struct _cwmp__TransferComplete), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _cwmp__TransferComplete * SOAP_FMAC4 soap_new__cwmp__TransferComplete(struct soap *soap, int n)
{
	struct _cwmp__TransferComplete *p;
	struct _cwmp__TransferComplete *a = (struct _cwmp__TransferComplete*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _cwmp__TransferComplete));
	for (p = a; p && n--; p++)
		soap_default__cwmp__TransferComplete(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__cwmp__TransferComplete(struct soap *soap, const struct _cwmp__TransferComplete *a, const char *tag, const char *type)
{
	if (soap_out__cwmp__TransferComplete(soap, tag ? tag : "cwmp:TransferComplete", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _cwmp__TransferComplete * SOAP_FMAC4 soap_get__cwmp__TransferComplete(struct soap *soap, struct _cwmp__TransferComplete *p, const char *tag, const char *type)
{
	if ((p = soap_in__cwmp__TransferComplete(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__cwmp__InformResponse(struct soap *soap, struct _cwmp__InformResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_unsignedInt(soap, &a->MaxEnvelopes);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__cwmp__InformResponse(struct soap *soap, const struct _cwmp__InformResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__cwmp__InformResponse(struct soap *soap, const char *tag, int id, const struct _cwmp__InformResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__cwmp__InformResponse), type))
		return soap->error;
	if (soap_out_unsignedInt(soap, "MaxEnvelopes", -1, &a->MaxEnvelopes, "xsd:unsignedInt"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _cwmp__InformResponse * SOAP_FMAC4 soap_in__cwmp__InformResponse(struct soap *soap, const char *tag, struct _cwmp__InformResponse *a, const char *type)
{
	size_t soap_flag_MaxEnvelopes = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _cwmp__InformResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__cwmp__InformResponse, sizeof(struct _cwmp__InformResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__cwmp__InformResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MaxEnvelopes && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "MaxEnvelopes", &a->MaxEnvelopes, "xsd:unsignedInt"))
				{	soap_flag_MaxEnvelopes--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_MaxEnvelopes > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _cwmp__InformResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__cwmp__InformResponse, SOAP_TYPE__cwmp__InformResponse, sizeof(struct _cwmp__InformResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _cwmp__InformResponse * SOAP_FMAC4 soap_new__cwmp__InformResponse(struct soap *soap, int n)
{
	struct _cwmp__InformResponse *p;
	struct _cwmp__InformResponse *a = (struct _cwmp__InformResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _cwmp__InformResponse));
	for (p = a; p && n--; p++)
		soap_default__cwmp__InformResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__cwmp__InformResponse(struct soap *soap, const struct _cwmp__InformResponse *a, const char *tag, const char *type)
{
	if (soap_out__cwmp__InformResponse(soap, tag ? tag : "cwmp:InformResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _cwmp__InformResponse * SOAP_FMAC4 soap_get__cwmp__InformResponse(struct soap *soap, struct _cwmp__InformResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__cwmp__InformResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_EventList(struct soap *soap, struct EventList *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__ptrEventStruct = NULL;
	a->__size = 0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_EventList(struct soap *soap, const struct EventList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__ptrEventStruct && !soap_array_reference(soap, a, a->__ptrEventStruct, a->__size, SOAP_TYPE_EventList))
	{	int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTocwmp__EventStruct(soap, a->__ptrEventStruct + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_EventList(struct soap *soap, const char *tag, int id, const struct EventList *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptrEventStruct ? soap_putsizesoffsets(soap, "cwmp:EventStruct", &a->__size, NULL, 1) : NULL;
	id = soap_element_id(soap, tag, id, a, a->__ptrEventStruct, a->__size, type, SOAP_TYPE_EventList, NULL);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTocwmp__EventStruct(soap, "EventStruct", -1, &a->__ptrEventStruct[i], "cwmp:EventStruct");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct EventList * SOAP_FMAC4 soap_in_EventList(struct soap *soap, const char *tag, struct EventList *a, const char *type)
{	int i, j;
	struct cwmp__EventStruct **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct EventList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_EventList, sizeof(struct EventList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_EventList(soap, a);
	if (soap->body && !*soap->href)
	{
		if (*soap->arraySize)
		{
			soap_getsizes(soap->arraySize, &a->__size, 1);
			a->__size -= j = soap_getoffsets(soap->arrayOffset, &a->__size, NULL, 1);
			if ((size_t)a->__size > soap->maxoccurs)
			{	soap->error = SOAP_OCCURS;
				return NULL;
			}
			a->__ptrEventStruct = (struct cwmp__EventStruct **)soap_malloc(soap, sizeof(struct cwmp__EventStruct *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptrEventStruct[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTocwmp__EventStruct(soap, NULL, a->__ptrEventStruct + i, "cwmp:EventStruct"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_alloc_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct cwmp__EventStruct **)soap_push_block(soap, NULL, sizeof(struct cwmp__EventStruct *));
				if (!p)
					break;
				*p = NULL;
				if (!soap_in_PointerTocwmp__EventStruct(soap, NULL, p, "cwmp:EventStruct"))
				{	if (soap->error == SOAP_NO_TAG)
						soap->error = SOAP_OK;
					soap_pop_block(soap, NULL);
					break;
				}
				if ((size_t)a->__size > soap->maxoccurs)
				{	soap->error = SOAP_OCCURS;
					return NULL;
				}
			}
			a->__ptrEventStruct = (struct cwmp__EventStruct **)soap_save_block(soap, NULL, NULL, 1);
		}
		if (soap->error || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct EventList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_EventList, SOAP_TYPE_EventList, sizeof(struct EventList), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct EventList * SOAP_FMAC4 soap_new_EventList(struct soap *soap, int n)
{
	struct EventList *p;
	struct EventList *a = (struct EventList*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct EventList));
	for (p = a; p && n--; p++)
		soap_default_EventList(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_EventList(struct soap *soap, const struct EventList *a, const char *tag, const char *type)
{
	if (soap_out_EventList(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct EventList * SOAP_FMAC4 soap_get_EventList(struct soap *soap, struct EventList *p, const char *tag, const char *type)
{
	if ((p = soap_in_EventList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__cwmp__Inform(struct soap *soap, struct _cwmp__Inform *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->DeviceId = NULL;
	a->Event = NULL;
	soap_default_unsignedInt(soap, &a->MaxEnvelopes);
	soap_default_dateTime(soap, &a->CurrentTime);
	soap_default_unsignedInt(soap, &a->RetryCount);
	a->ParameterList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__cwmp__Inform(struct soap *soap, const struct _cwmp__Inform *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTocwmp__DeviceIdStruct(soap, &a->DeviceId);
	soap_serialize_PointerToEventList(soap, &a->Event);
	soap_embedded(soap, &a->CurrentTime, SOAP_TYPE_dateTime);
	soap_serialize_PointerToParameterValueList(soap, &a->ParameterList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__cwmp__Inform(struct soap *soap, const char *tag, int id, const struct _cwmp__Inform *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__cwmp__Inform), type))
		return soap->error;
	if (!a->DeviceId)
	{	if (soap_element_empty(soap, "DeviceId"))
			return soap->error;
	}
	else
	if (soap_out_PointerTocwmp__DeviceIdStruct(soap, "DeviceId", -1, &a->DeviceId, "cwmp:DeviceIdStruct"))
		return soap->error;
	if (!a->Event)
	{	if (soap_element_empty(soap, "Event"))
			return soap->error;
	}
	else
	if (soap_out_PointerToEventList(soap, "Event", -1, &a->Event, "cwmp:EventStruct"))
		return soap->error;
	if (soap_out_unsignedInt(soap, "MaxEnvelopes", -1, &a->MaxEnvelopes, "xsd:unsignedInt"))
		return soap->error;
	if (soap_out_dateTime(soap, "CurrentTime", -1, &a->CurrentTime, "xsd:dateTime"))
		return soap->error;
	if (soap_out_unsignedInt(soap, "RetryCount", -1, &a->RetryCount, "xsd:unsignedInt"))
		return soap->error;
	if (!a->ParameterList)
	{	if (soap_element_empty(soap, "ParameterList"))
			return soap->error;
	}
	else
	if (soap_out_PointerToParameterValueList(soap, "ParameterList", -1, &a->ParameterList, "cwmp:ParameterValueStruct"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _cwmp__Inform * SOAP_FMAC4 soap_in__cwmp__Inform(struct soap *soap, const char *tag, struct _cwmp__Inform *a, const char *type)
{
	size_t soap_flag_DeviceId = 1;
	size_t soap_flag_Event = 1;
	size_t soap_flag_MaxEnvelopes = 1;
	size_t soap_flag_CurrentTime = 1;
	size_t soap_flag_RetryCount = 1;
	size_t soap_flag_ParameterList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _cwmp__Inform *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__cwmp__Inform, sizeof(struct _cwmp__Inform), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__cwmp__Inform(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DeviceId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTocwmp__DeviceIdStruct(soap, "DeviceId", &a->DeviceId, "cwmp:DeviceIdStruct"))
				{	soap_flag_DeviceId--;
					continue;
				}
			if (soap_flag_Event && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToEventList(soap, "Event", &a->Event, "cwmp:EventStruct"))
				{	soap_flag_Event--;
					continue;
				}
			if (soap_flag_MaxEnvelopes && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "MaxEnvelopes", &a->MaxEnvelopes, "xsd:unsignedInt"))
				{	soap_flag_MaxEnvelopes--;
					continue;
				}
			if (soap_flag_CurrentTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_dateTime(soap, "CurrentTime", &a->CurrentTime, "xsd:dateTime"))
				{	soap_flag_CurrentTime--;
					continue;
				}
			if (soap_flag_RetryCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "RetryCount", &a->RetryCount, "xsd:unsignedInt"))
				{	soap_flag_RetryCount--;
					continue;
				}
			if (soap_flag_ParameterList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToParameterValueList(soap, "ParameterList", &a->ParameterList, "cwmp:ParameterValueStruct"))
				{	soap_flag_ParameterList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->DeviceId || !a->Event || soap_flag_MaxEnvelopes > 0 || soap_flag_CurrentTime > 0 || soap_flag_RetryCount > 0 || !a->ParameterList))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _cwmp__Inform *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__cwmp__Inform, SOAP_TYPE__cwmp__Inform, sizeof(struct _cwmp__Inform), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _cwmp__Inform * SOAP_FMAC4 soap_new__cwmp__Inform(struct soap *soap, int n)
{
	struct _cwmp__Inform *p;
	struct _cwmp__Inform *a = (struct _cwmp__Inform*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _cwmp__Inform));
	for (p = a; p && n--; p++)
		soap_default__cwmp__Inform(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__cwmp__Inform(struct soap *soap, const struct _cwmp__Inform *a, const char *tag, const char *type)
{
	if (soap_out__cwmp__Inform(soap, tag ? tag : "cwmp:Inform", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _cwmp__Inform * SOAP_FMAC4 soap_get__cwmp__Inform(struct soap *soap, struct _cwmp__Inform *p, const char *tag, const char *type)
{
	if ((p = soap_in__cwmp__Inform(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__cwmp__FactoryResetResponse(struct soap *soap, struct _cwmp__FactoryResetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__cwmp__FactoryResetResponse(struct soap *soap, const struct _cwmp__FactoryResetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__cwmp__FactoryResetResponse(struct soap *soap, const char *tag, int id, const struct _cwmp__FactoryResetResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__cwmp__FactoryResetResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _cwmp__FactoryResetResponse * SOAP_FMAC4 soap_in__cwmp__FactoryResetResponse(struct soap *soap, const char *tag, struct _cwmp__FactoryResetResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _cwmp__FactoryResetResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__cwmp__FactoryResetResponse, sizeof(struct _cwmp__FactoryResetResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__cwmp__FactoryResetResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _cwmp__FactoryResetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__cwmp__FactoryResetResponse, SOAP_TYPE__cwmp__FactoryResetResponse, sizeof(struct _cwmp__FactoryResetResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _cwmp__FactoryResetResponse * SOAP_FMAC4 soap_new__cwmp__FactoryResetResponse(struct soap *soap, int n)
{
	struct _cwmp__FactoryResetResponse *p;
	struct _cwmp__FactoryResetResponse *a = (struct _cwmp__FactoryResetResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _cwmp__FactoryResetResponse));
	for (p = a; p && n--; p++)
		soap_default__cwmp__FactoryResetResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__cwmp__FactoryResetResponse(struct soap *soap, const struct _cwmp__FactoryResetResponse *a, const char *tag, const char *type)
{
	if (soap_out__cwmp__FactoryResetResponse(soap, tag ? tag : "cwmp:FactoryResetResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _cwmp__FactoryResetResponse * SOAP_FMAC4 soap_get__cwmp__FactoryResetResponse(struct soap *soap, struct _cwmp__FactoryResetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__cwmp__FactoryResetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__cwmp__FactoryReset(struct soap *soap, struct _cwmp__FactoryReset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__cwmp__FactoryReset(struct soap *soap, const struct _cwmp__FactoryReset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__cwmp__FactoryReset(struct soap *soap, const char *tag, int id, const struct _cwmp__FactoryReset *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__cwmp__FactoryReset), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _cwmp__FactoryReset * SOAP_FMAC4 soap_in__cwmp__FactoryReset(struct soap *soap, const char *tag, struct _cwmp__FactoryReset *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _cwmp__FactoryReset *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__cwmp__FactoryReset, sizeof(struct _cwmp__FactoryReset), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__cwmp__FactoryReset(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _cwmp__FactoryReset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__cwmp__FactoryReset, SOAP_TYPE__cwmp__FactoryReset, sizeof(struct _cwmp__FactoryReset), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _cwmp__FactoryReset * SOAP_FMAC4 soap_new__cwmp__FactoryReset(struct soap *soap, int n)
{
	struct _cwmp__FactoryReset *p;
	struct _cwmp__FactoryReset *a = (struct _cwmp__FactoryReset*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _cwmp__FactoryReset));
	for (p = a; p && n--; p++)
		soap_default__cwmp__FactoryReset(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__cwmp__FactoryReset(struct soap *soap, const struct _cwmp__FactoryReset *a, const char *tag, const char *type)
{
	if (soap_out__cwmp__FactoryReset(soap, tag ? tag : "cwmp:FactoryReset", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _cwmp__FactoryReset * SOAP_FMAC4 soap_get__cwmp__FactoryReset(struct soap *soap, struct _cwmp__FactoryReset *p, const char *tag, const char *type)
{
	if ((p = soap_in__cwmp__FactoryReset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__cwmp__UploadResponse(struct soap *soap, struct _cwmp__UploadResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__cwmp__UploadResponse_Status(soap, &a->Status);
	soap_default_dateTime(soap, &a->StartTime);
	soap_default_dateTime(soap, &a->CompleteTime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__cwmp__UploadResponse(struct soap *soap, const struct _cwmp__UploadResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->StartTime, SOAP_TYPE_dateTime);
	soap_embedded(soap, &a->CompleteTime, SOAP_TYPE_dateTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__cwmp__UploadResponse(struct soap *soap, const char *tag, int id, const struct _cwmp__UploadResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__cwmp__UploadResponse), type))
		return soap->error;
	if (soap_out__cwmp__UploadResponse_Status(soap, "Status", -1, &a->Status, "cwmp:UploadResponse-Status"))
		return soap->error;
	if (soap_out_dateTime(soap, "StartTime", -1, &a->StartTime, "xsd:dateTime"))
		return soap->error;
	if (soap_out_dateTime(soap, "CompleteTime", -1, &a->CompleteTime, "xsd:dateTime"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _cwmp__UploadResponse * SOAP_FMAC4 soap_in__cwmp__UploadResponse(struct soap *soap, const char *tag, struct _cwmp__UploadResponse *a, const char *type)
{
	size_t soap_flag_Status = 1;
	size_t soap_flag_StartTime = 1;
	size_t soap_flag_CompleteTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _cwmp__UploadResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__cwmp__UploadResponse, sizeof(struct _cwmp__UploadResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__cwmp__UploadResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__cwmp__UploadResponse_Status(soap, "Status", &a->Status, "cwmp:UploadResponse-Status"))
				{	soap_flag_Status--;
					continue;
				}
			if (soap_flag_StartTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_dateTime(soap, "StartTime", &a->StartTime, "xsd:dateTime"))
				{	soap_flag_StartTime--;
					continue;
				}
			if (soap_flag_CompleteTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_dateTime(soap, "CompleteTime", &a->CompleteTime, "xsd:dateTime"))
				{	soap_flag_CompleteTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Status > 0 || soap_flag_StartTime > 0 || soap_flag_CompleteTime > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _cwmp__UploadResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__cwmp__UploadResponse, SOAP_TYPE__cwmp__UploadResponse, sizeof(struct _cwmp__UploadResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _cwmp__UploadResponse * SOAP_FMAC4 soap_new__cwmp__UploadResponse(struct soap *soap, int n)
{
	struct _cwmp__UploadResponse *p;
	struct _cwmp__UploadResponse *a = (struct _cwmp__UploadResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _cwmp__UploadResponse));
	for (p = a; p && n--; p++)
		soap_default__cwmp__UploadResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__cwmp__UploadResponse(struct soap *soap, const struct _cwmp__UploadResponse *a, const char *tag, const char *type)
{
	if (soap_out__cwmp__UploadResponse(soap, tag ? tag : "cwmp:UploadResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _cwmp__UploadResponse * SOAP_FMAC4 soap_get__cwmp__UploadResponse(struct soap *soap, struct _cwmp__UploadResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__cwmp__UploadResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__cwmp__Upload(struct soap *soap, struct _cwmp__Upload *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_cwmp__CommandKeyType(soap, &a->CommandKey);
	soap_default_string(soap, &a->FileType);
	soap_default_string(soap, &a->URL);
	soap_default_string(soap, &a->Username);
	soap_default_string(soap, &a->Password);
	soap_default_unsignedInt(soap, &a->DelaySeconds);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__cwmp__Upload(struct soap *soap, const struct _cwmp__Upload *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_cwmp__CommandKeyType(soap, (char*const*)&a->CommandKey);
	soap_serialize_string(soap, (char*const*)&a->FileType);
	soap_serialize_string(soap, (char*const*)&a->URL);
	soap_serialize_string(soap, (char*const*)&a->Username);
	soap_serialize_string(soap, (char*const*)&a->Password);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__cwmp__Upload(struct soap *soap, const char *tag, int id, const struct _cwmp__Upload *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__cwmp__Upload), type))
		return soap->error;
	if (!a->CommandKey)
	{	if (soap_element_empty(soap, "CommandKey"))
			return soap->error;
	}
	else
	if (soap_out_cwmp__CommandKeyType(soap, "CommandKey", -1, (char*const*)&a->CommandKey, "cwmp:CommandKeyType"))
		return soap->error;
	if (!a->FileType)
	{	if (soap_element_empty(soap, "FileType"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "FileType", -1, (char*const*)&a->FileType, "xsd:string"))
		return soap->error;
	if (!a->URL)
	{	if (soap_element_empty(soap, "URL"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "URL", -1, (char*const*)&a->URL, "xsd:string"))
		return soap->error;
	if (!a->Username)
	{	if (soap_element_empty(soap, "Username"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "Username", -1, (char*const*)&a->Username, "xsd:string"))
		return soap->error;
	if (!a->Password)
	{	if (soap_element_empty(soap, "Password"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "Password", -1, (char*const*)&a->Password, "xsd:string"))
		return soap->error;
	if (soap_out_unsignedInt(soap, "DelaySeconds", -1, &a->DelaySeconds, "xsd:unsignedInt"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _cwmp__Upload * SOAP_FMAC4 soap_in__cwmp__Upload(struct soap *soap, const char *tag, struct _cwmp__Upload *a, const char *type)
{
	size_t soap_flag_CommandKey = 1;
	size_t soap_flag_FileType = 1;
	size_t soap_flag_URL = 1;
	size_t soap_flag_Username = 1;
	size_t soap_flag_Password = 1;
	size_t soap_flag_DelaySeconds = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _cwmp__Upload *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__cwmp__Upload, sizeof(struct _cwmp__Upload), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__cwmp__Upload(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CommandKey && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_cwmp__CommandKeyType(soap, "CommandKey", (char**)&a->CommandKey, "cwmp:CommandKeyType"))
				{	soap_flag_CommandKey--;
					continue;
				}
			if (soap_flag_FileType && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "FileType", (char**)&a->FileType, "xsd:string"))
				{	soap_flag_FileType--;
					continue;
				}
			if (soap_flag_URL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "URL", (char**)&a->URL, "xsd:string"))
				{	soap_flag_URL--;
					continue;
				}
			if (soap_flag_Username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Username", (char**)&a->Username, "xsd:string"))
				{	soap_flag_Username--;
					continue;
				}
			if (soap_flag_Password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Password", (char**)&a->Password, "xsd:string"))
				{	soap_flag_Password--;
					continue;
				}
			if (soap_flag_DelaySeconds && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "DelaySeconds", &a->DelaySeconds, "xsd:unsignedInt"))
				{	soap_flag_DelaySeconds--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->CommandKey || !a->FileType || !a->URL || !a->Username || !a->Password || soap_flag_DelaySeconds > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _cwmp__Upload *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__cwmp__Upload, SOAP_TYPE__cwmp__Upload, sizeof(struct _cwmp__Upload), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _cwmp__Upload * SOAP_FMAC4 soap_new__cwmp__Upload(struct soap *soap, int n)
{
	struct _cwmp__Upload *p;
	struct _cwmp__Upload *a = (struct _cwmp__Upload*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _cwmp__Upload));
	for (p = a; p && n--; p++)
		soap_default__cwmp__Upload(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__cwmp__Upload(struct soap *soap, const struct _cwmp__Upload *a, const char *tag, const char *type)
{
	if (soap_out__cwmp__Upload(soap, tag ? tag : "cwmp:Upload", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _cwmp__Upload * SOAP_FMAC4 soap_get__cwmp__Upload(struct soap *soap, struct _cwmp__Upload *p, const char *tag, const char *type)
{
	if ((p = soap_in__cwmp__Upload(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_OptionList(struct soap *soap, struct OptionList *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__ptrOptionStruct = NULL;
	a->__size = 0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_OptionList(struct soap *soap, const struct OptionList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__ptrOptionStruct && !soap_array_reference(soap, a, a->__ptrOptionStruct, a->__size, SOAP_TYPE_OptionList))
	{	int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTocwmp__OptionStruct(soap, a->__ptrOptionStruct + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_OptionList(struct soap *soap, const char *tag, int id, const struct OptionList *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptrOptionStruct ? soap_putsizesoffsets(soap, "cwmp:OptionStruct", &a->__size, NULL, 1) : NULL;
	id = soap_element_id(soap, tag, id, a, a->__ptrOptionStruct, a->__size, type, SOAP_TYPE_OptionList, NULL);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTocwmp__OptionStruct(soap, "OptionStruct", -1, &a->__ptrOptionStruct[i], "cwmp:OptionStruct");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct OptionList * SOAP_FMAC4 soap_in_OptionList(struct soap *soap, const char *tag, struct OptionList *a, const char *type)
{	int i, j;
	struct cwmp__OptionStruct **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct OptionList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_OptionList, sizeof(struct OptionList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_OptionList(soap, a);
	if (soap->body && !*soap->href)
	{
		if (*soap->arraySize)
		{
			soap_getsizes(soap->arraySize, &a->__size, 1);
			a->__size -= j = soap_getoffsets(soap->arrayOffset, &a->__size, NULL, 1);
			if ((size_t)a->__size > soap->maxoccurs)
			{	soap->error = SOAP_OCCURS;
				return NULL;
			}
			a->__ptrOptionStruct = (struct cwmp__OptionStruct **)soap_malloc(soap, sizeof(struct cwmp__OptionStruct *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptrOptionStruct[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTocwmp__OptionStruct(soap, NULL, a->__ptrOptionStruct + i, "cwmp:OptionStruct"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_alloc_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct cwmp__OptionStruct **)soap_push_block(soap, NULL, sizeof(struct cwmp__OptionStruct *));
				if (!p)
					break;
				*p = NULL;
				if (!soap_in_PointerTocwmp__OptionStruct(soap, NULL, p, "cwmp:OptionStruct"))
				{	if (soap->error == SOAP_NO_TAG)
						soap->error = SOAP_OK;
					soap_pop_block(soap, NULL);
					break;
				}
				if ((size_t)a->__size > soap->maxoccurs)
				{	soap->error = SOAP_OCCURS;
					return NULL;
				}
			}
			a->__ptrOptionStruct = (struct cwmp__OptionStruct **)soap_save_block(soap, NULL, NULL, 1);
		}
		if (soap->error || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct OptionList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_OptionList, SOAP_TYPE_OptionList, sizeof(struct OptionList), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct OptionList * SOAP_FMAC4 soap_new_OptionList(struct soap *soap, int n)
{
	struct OptionList *p;
	struct OptionList *a = (struct OptionList*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct OptionList));
	for (p = a; p && n--; p++)
		soap_default_OptionList(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_OptionList(struct soap *soap, const struct OptionList *a, const char *tag, const char *type)
{
	if (soap_out_OptionList(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct OptionList * SOAP_FMAC4 soap_get_OptionList(struct soap *soap, struct OptionList *p, const char *tag, const char *type)
{
	if ((p = soap_in_OptionList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__cwmp__GetOptionsResponse(struct soap *soap, struct _cwmp__GetOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->OptionList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__cwmp__GetOptionsResponse(struct soap *soap, const struct _cwmp__GetOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToOptionList(soap, &a->OptionList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__cwmp__GetOptionsResponse(struct soap *soap, const char *tag, int id, const struct _cwmp__GetOptionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__cwmp__GetOptionsResponse), type))
		return soap->error;
	if (!a->OptionList)
	{	if (soap_element_empty(soap, "OptionList"))
			return soap->error;
	}
	else
	if (soap_out_PointerToOptionList(soap, "OptionList", -1, &a->OptionList, "cwmp:OptionStruct"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _cwmp__GetOptionsResponse * SOAP_FMAC4 soap_in__cwmp__GetOptionsResponse(struct soap *soap, const char *tag, struct _cwmp__GetOptionsResponse *a, const char *type)
{
	size_t soap_flag_OptionList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _cwmp__GetOptionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__cwmp__GetOptionsResponse, sizeof(struct _cwmp__GetOptionsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__cwmp__GetOptionsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OptionList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToOptionList(soap, "OptionList", &a->OptionList, "cwmp:OptionStruct"))
				{	soap_flag_OptionList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->OptionList))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _cwmp__GetOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__cwmp__GetOptionsResponse, SOAP_TYPE__cwmp__GetOptionsResponse, sizeof(struct _cwmp__GetOptionsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _cwmp__GetOptionsResponse * SOAP_FMAC4 soap_new__cwmp__GetOptionsResponse(struct soap *soap, int n)
{
	struct _cwmp__GetOptionsResponse *p;
	struct _cwmp__GetOptionsResponse *a = (struct _cwmp__GetOptionsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _cwmp__GetOptionsResponse));
	for (p = a; p && n--; p++)
		soap_default__cwmp__GetOptionsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__cwmp__GetOptionsResponse(struct soap *soap, const struct _cwmp__GetOptionsResponse *a, const char *tag, const char *type)
{
	if (soap_out__cwmp__GetOptionsResponse(soap, tag ? tag : "cwmp:GetOptionsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _cwmp__GetOptionsResponse * SOAP_FMAC4 soap_get__cwmp__GetOptionsResponse(struct soap *soap, struct _cwmp__GetOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__cwmp__GetOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__cwmp__GetOptions(struct soap *soap, struct _cwmp__GetOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->OptionName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__cwmp__GetOptions(struct soap *soap, const struct _cwmp__GetOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->OptionName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__cwmp__GetOptions(struct soap *soap, const char *tag, int id, const struct _cwmp__GetOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__cwmp__GetOptions), type))
		return soap->error;
	if (!a->OptionName)
	{	if (soap_element_empty(soap, "OptionName"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "OptionName", -1, (char*const*)&a->OptionName, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _cwmp__GetOptions * SOAP_FMAC4 soap_in__cwmp__GetOptions(struct soap *soap, const char *tag, struct _cwmp__GetOptions *a, const char *type)
{
	size_t soap_flag_OptionName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _cwmp__GetOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__cwmp__GetOptions, sizeof(struct _cwmp__GetOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__cwmp__GetOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OptionName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "OptionName", (char**)&a->OptionName, "xsd:string"))
				{	soap_flag_OptionName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->OptionName))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _cwmp__GetOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__cwmp__GetOptions, SOAP_TYPE__cwmp__GetOptions, sizeof(struct _cwmp__GetOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _cwmp__GetOptions * SOAP_FMAC4 soap_new__cwmp__GetOptions(struct soap *soap, int n)
{
	struct _cwmp__GetOptions *p;
	struct _cwmp__GetOptions *a = (struct _cwmp__GetOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _cwmp__GetOptions));
	for (p = a; p && n--; p++)
		soap_default__cwmp__GetOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__cwmp__GetOptions(struct soap *soap, const struct _cwmp__GetOptions *a, const char *tag, const char *type)
{
	if (soap_out__cwmp__GetOptions(soap, tag ? tag : "cwmp:GetOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _cwmp__GetOptions * SOAP_FMAC4 soap_get__cwmp__GetOptions(struct soap *soap, struct _cwmp__GetOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in__cwmp__GetOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__cwmp__SetVouchersResponse(struct soap *soap, struct _cwmp__SetVouchersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__cwmp__SetVouchersResponse(struct soap *soap, const struct _cwmp__SetVouchersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__cwmp__SetVouchersResponse(struct soap *soap, const char *tag, int id, const struct _cwmp__SetVouchersResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__cwmp__SetVouchersResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _cwmp__SetVouchersResponse * SOAP_FMAC4 soap_in__cwmp__SetVouchersResponse(struct soap *soap, const char *tag, struct _cwmp__SetVouchersResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _cwmp__SetVouchersResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__cwmp__SetVouchersResponse, sizeof(struct _cwmp__SetVouchersResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__cwmp__SetVouchersResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _cwmp__SetVouchersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__cwmp__SetVouchersResponse, SOAP_TYPE__cwmp__SetVouchersResponse, sizeof(struct _cwmp__SetVouchersResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _cwmp__SetVouchersResponse * SOAP_FMAC4 soap_new__cwmp__SetVouchersResponse(struct soap *soap, int n)
{
	struct _cwmp__SetVouchersResponse *p;
	struct _cwmp__SetVouchersResponse *a = (struct _cwmp__SetVouchersResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _cwmp__SetVouchersResponse));
	for (p = a; p && n--; p++)
		soap_default__cwmp__SetVouchersResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__cwmp__SetVouchersResponse(struct soap *soap, const struct _cwmp__SetVouchersResponse *a, const char *tag, const char *type)
{
	if (soap_out__cwmp__SetVouchersResponse(soap, tag ? tag : "cwmp:SetVouchersResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _cwmp__SetVouchersResponse * SOAP_FMAC4 soap_get__cwmp__SetVouchersResponse(struct soap *soap, struct _cwmp__SetVouchersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__cwmp__SetVouchersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_VoucherList(struct soap *soap, struct VoucherList *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__ptrbase64 = NULL;
	a->__size = 0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_VoucherList(struct soap *soap, const struct VoucherList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__ptrbase64 && !soap_array_reference(soap, a, a->__ptrbase64, a->__size, SOAP_TYPE_VoucherList))
	{	int i;
		for (i = 0; i < a->__size; i++)
		{	soap_embedded(soap, a->__ptrbase64 + i, SOAP_TYPE_SOAP_ENC__base64);
			soap_serialize_SOAP_ENC__base64(soap, a->__ptrbase64 + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_VoucherList(struct soap *soap, const char *tag, int id, const struct VoucherList *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptrbase64 ? soap_putsizesoffsets(soap, "SOAP-ENC:base64", &a->__size, NULL, 1) : NULL;
	id = soap_element_id(soap, tag, id, a, a->__ptrbase64, a->__size, type, SOAP_TYPE_VoucherList, NULL);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_SOAP_ENC__base64(soap, "base64", -1, &a->__ptrbase64[i], "SOAP-ENC:base64");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct VoucherList * SOAP_FMAC4 soap_in_VoucherList(struct soap *soap, const char *tag, struct VoucherList *a, const char *type)
{	int i, j;
	struct SOAP_ENC__base64 *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct VoucherList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_VoucherList, sizeof(struct VoucherList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_VoucherList(soap, a);
	if (soap->body && !*soap->href)
	{
		if (*soap->arraySize)
		{
			soap_getsizes(soap->arraySize, &a->__size, 1);
			a->__size -= j = soap_getoffsets(soap->arrayOffset, &a->__size, NULL, 1);
			if ((size_t)a->__size > soap->maxoccurs)
			{	soap->error = SOAP_OCCURS;
				return NULL;
			}
			a->__ptrbase64 = (struct SOAP_ENC__base64 *)soap_malloc(soap, sizeof(struct SOAP_ENC__base64) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_SOAP_ENC__base64(soap, a->__ptrbase64+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_SOAP_ENC__base64(soap, NULL, a->__ptrbase64 + i, "SOAP-ENC:base64"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_alloc_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct SOAP_ENC__base64 *)soap_push_block(soap, NULL, sizeof(struct SOAP_ENC__base64));
				if (!p)
					break;
				soap_default_SOAP_ENC__base64(soap, p);
				if (!soap_in_SOAP_ENC__base64(soap, NULL, p, "SOAP-ENC:base64"))
				{	if (soap->error == SOAP_NO_TAG)
						soap->error = SOAP_OK;
					soap_pop_block(soap, NULL);
					break;
				}
				if ((size_t)a->__size > soap->maxoccurs)
				{	soap->error = SOAP_OCCURS;
					return NULL;
				}
			}
			a->__ptrbase64 = (struct SOAP_ENC__base64 *)soap_save_block(soap, NULL, NULL, 1);
		}
		if (soap->error || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct VoucherList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_VoucherList, SOAP_TYPE_VoucherList, sizeof(struct VoucherList), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct VoucherList * SOAP_FMAC4 soap_new_VoucherList(struct soap *soap, int n)
{
	struct VoucherList *p;
	struct VoucherList *a = (struct VoucherList*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct VoucherList));
	for (p = a; p && n--; p++)
		soap_default_VoucherList(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_VoucherList(struct soap *soap, const struct VoucherList *a, const char *tag, const char *type)
{
	if (soap_out_VoucherList(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct VoucherList * SOAP_FMAC4 soap_get_VoucherList(struct soap *soap, struct VoucherList *p, const char *tag, const char *type)
{
	if ((p = soap_in_VoucherList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__cwmp__SetVouchers(struct soap *soap, struct _cwmp__SetVouchers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->VoucherList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__cwmp__SetVouchers(struct soap *soap, const struct _cwmp__SetVouchers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToVoucherList(soap, &a->VoucherList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__cwmp__SetVouchers(struct soap *soap, const char *tag, int id, const struct _cwmp__SetVouchers *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__cwmp__SetVouchers), type))
		return soap->error;
	if (!a->VoucherList)
	{	if (soap_element_empty(soap, "VoucherList"))
			return soap->error;
	}
	else
	if (soap_out_PointerToVoucherList(soap, "VoucherList", -1, &a->VoucherList, "SOAP-ENC:base64"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _cwmp__SetVouchers * SOAP_FMAC4 soap_in__cwmp__SetVouchers(struct soap *soap, const char *tag, struct _cwmp__SetVouchers *a, const char *type)
{
	size_t soap_flag_VoucherList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _cwmp__SetVouchers *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__cwmp__SetVouchers, sizeof(struct _cwmp__SetVouchers), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__cwmp__SetVouchers(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VoucherList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToVoucherList(soap, "VoucherList", &a->VoucherList, "SOAP-ENC:base64"))
				{	soap_flag_VoucherList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->VoucherList))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _cwmp__SetVouchers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__cwmp__SetVouchers, SOAP_TYPE__cwmp__SetVouchers, sizeof(struct _cwmp__SetVouchers), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _cwmp__SetVouchers * SOAP_FMAC4 soap_new__cwmp__SetVouchers(struct soap *soap, int n)
{
	struct _cwmp__SetVouchers *p;
	struct _cwmp__SetVouchers *a = (struct _cwmp__SetVouchers*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _cwmp__SetVouchers));
	for (p = a; p && n--; p++)
		soap_default__cwmp__SetVouchers(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__cwmp__SetVouchers(struct soap *soap, const struct _cwmp__SetVouchers *a, const char *tag, const char *type)
{
	if (soap_out__cwmp__SetVouchers(soap, tag ? tag : "cwmp:SetVouchers", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _cwmp__SetVouchers * SOAP_FMAC4 soap_get__cwmp__SetVouchers(struct soap *soap, struct _cwmp__SetVouchers *p, const char *tag, const char *type)
{
	if ((p = soap_in__cwmp__SetVouchers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__cwmp__ScheduleInformResponse(struct soap *soap, struct _cwmp__ScheduleInformResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__cwmp__ScheduleInformResponse(struct soap *soap, const struct _cwmp__ScheduleInformResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__cwmp__ScheduleInformResponse(struct soap *soap, const char *tag, int id, const struct _cwmp__ScheduleInformResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__cwmp__ScheduleInformResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _cwmp__ScheduleInformResponse * SOAP_FMAC4 soap_in__cwmp__ScheduleInformResponse(struct soap *soap, const char *tag, struct _cwmp__ScheduleInformResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _cwmp__ScheduleInformResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__cwmp__ScheduleInformResponse, sizeof(struct _cwmp__ScheduleInformResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__cwmp__ScheduleInformResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _cwmp__ScheduleInformResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__cwmp__ScheduleInformResponse, SOAP_TYPE__cwmp__ScheduleInformResponse, sizeof(struct _cwmp__ScheduleInformResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _cwmp__ScheduleInformResponse * SOAP_FMAC4 soap_new__cwmp__ScheduleInformResponse(struct soap *soap, int n)
{
	struct _cwmp__ScheduleInformResponse *p;
	struct _cwmp__ScheduleInformResponse *a = (struct _cwmp__ScheduleInformResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _cwmp__ScheduleInformResponse));
	for (p = a; p && n--; p++)
		soap_default__cwmp__ScheduleInformResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__cwmp__ScheduleInformResponse(struct soap *soap, const struct _cwmp__ScheduleInformResponse *a, const char *tag, const char *type)
{
	if (soap_out__cwmp__ScheduleInformResponse(soap, tag ? tag : "cwmp:ScheduleInformResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _cwmp__ScheduleInformResponse * SOAP_FMAC4 soap_get__cwmp__ScheduleInformResponse(struct soap *soap, struct _cwmp__ScheduleInformResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__cwmp__ScheduleInformResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__cwmp__ScheduleInform(struct soap *soap, struct _cwmp__ScheduleInform *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_unsignedInt(soap, &a->DelaySeconds);
	soap_default_cwmp__CommandKeyType(soap, &a->CommandKey);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__cwmp__ScheduleInform(struct soap *soap, const struct _cwmp__ScheduleInform *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_cwmp__CommandKeyType(soap, (char*const*)&a->CommandKey);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__cwmp__ScheduleInform(struct soap *soap, const char *tag, int id, const struct _cwmp__ScheduleInform *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__cwmp__ScheduleInform), type))
		return soap->error;
	if (soap_out_unsignedInt(soap, "DelaySeconds", -1, &a->DelaySeconds, "xsd:unsignedInt"))
		return soap->error;
	if (!a->CommandKey)
	{	if (soap_element_empty(soap, "CommandKey"))
			return soap->error;
	}
	else
	if (soap_out_cwmp__CommandKeyType(soap, "CommandKey", -1, (char*const*)&a->CommandKey, "cwmp:CommandKeyType"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _cwmp__ScheduleInform * SOAP_FMAC4 soap_in__cwmp__ScheduleInform(struct soap *soap, const char *tag, struct _cwmp__ScheduleInform *a, const char *type)
{
	size_t soap_flag_DelaySeconds = 1;
	size_t soap_flag_CommandKey = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _cwmp__ScheduleInform *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__cwmp__ScheduleInform, sizeof(struct _cwmp__ScheduleInform), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__cwmp__ScheduleInform(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DelaySeconds && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "DelaySeconds", &a->DelaySeconds, "xsd:unsignedInt"))
				{	soap_flag_DelaySeconds--;
					continue;
				}
			if (soap_flag_CommandKey && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_cwmp__CommandKeyType(soap, "CommandKey", (char**)&a->CommandKey, "cwmp:CommandKeyType"))
				{	soap_flag_CommandKey--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DelaySeconds > 0 || !a->CommandKey))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _cwmp__ScheduleInform *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__cwmp__ScheduleInform, SOAP_TYPE__cwmp__ScheduleInform, sizeof(struct _cwmp__ScheduleInform), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _cwmp__ScheduleInform * SOAP_FMAC4 soap_new__cwmp__ScheduleInform(struct soap *soap, int n)
{
	struct _cwmp__ScheduleInform *p;
	struct _cwmp__ScheduleInform *a = (struct _cwmp__ScheduleInform*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _cwmp__ScheduleInform));
	for (p = a; p && n--; p++)
		soap_default__cwmp__ScheduleInform(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__cwmp__ScheduleInform(struct soap *soap, const struct _cwmp__ScheduleInform *a, const char *tag, const char *type)
{
	if (soap_out__cwmp__ScheduleInform(soap, tag ? tag : "cwmp:ScheduleInform", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _cwmp__ScheduleInform * SOAP_FMAC4 soap_get__cwmp__ScheduleInform(struct soap *soap, struct _cwmp__ScheduleInform *p, const char *tag, const char *type)
{
	if ((p = soap_in__cwmp__ScheduleInform(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TransferList(struct soap *soap, struct TransferList *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__ptrQueuedTransferStruct = NULL;
	a->__size = 0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TransferList(struct soap *soap, const struct TransferList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__ptrQueuedTransferStruct && !soap_array_reference(soap, a, a->__ptrQueuedTransferStruct, a->__size, SOAP_TYPE_TransferList))
	{	int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTocwmp__QueuedTransferStruct(soap, a->__ptrQueuedTransferStruct + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TransferList(struct soap *soap, const char *tag, int id, const struct TransferList *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptrQueuedTransferStruct ? soap_putsizesoffsets(soap, "cwmp:QueuedTransferStruct", &a->__size, NULL, 1) : NULL;
	id = soap_element_id(soap, tag, id, a, a->__ptrQueuedTransferStruct, a->__size, type, SOAP_TYPE_TransferList, NULL);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTocwmp__QueuedTransferStruct(soap, "QueuedTransferStruct", -1, &a->__ptrQueuedTransferStruct[i], "cwmp:QueuedTransferStruct");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TransferList * SOAP_FMAC4 soap_in_TransferList(struct soap *soap, const char *tag, struct TransferList *a, const char *type)
{	int i, j;
	struct cwmp__QueuedTransferStruct **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct TransferList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TransferList, sizeof(struct TransferList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_TransferList(soap, a);
	if (soap->body && !*soap->href)
	{
		if (*soap->arraySize)
		{
			soap_getsizes(soap->arraySize, &a->__size, 1);
			a->__size -= j = soap_getoffsets(soap->arrayOffset, &a->__size, NULL, 1);
			if ((size_t)a->__size > soap->maxoccurs)
			{	soap->error = SOAP_OCCURS;
				return NULL;
			}
			a->__ptrQueuedTransferStruct = (struct cwmp__QueuedTransferStruct **)soap_malloc(soap, sizeof(struct cwmp__QueuedTransferStruct *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptrQueuedTransferStruct[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTocwmp__QueuedTransferStruct(soap, NULL, a->__ptrQueuedTransferStruct + i, "cwmp:QueuedTransferStruct"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_alloc_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct cwmp__QueuedTransferStruct **)soap_push_block(soap, NULL, sizeof(struct cwmp__QueuedTransferStruct *));
				if (!p)
					break;
				*p = NULL;
				if (!soap_in_PointerTocwmp__QueuedTransferStruct(soap, NULL, p, "cwmp:QueuedTransferStruct"))
				{	if (soap->error == SOAP_NO_TAG)
						soap->error = SOAP_OK;
					soap_pop_block(soap, NULL);
					break;
				}
				if ((size_t)a->__size > soap->maxoccurs)
				{	soap->error = SOAP_OCCURS;
					return NULL;
				}
			}
			a->__ptrQueuedTransferStruct = (struct cwmp__QueuedTransferStruct **)soap_save_block(soap, NULL, NULL, 1);
		}
		if (soap->error || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct TransferList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TransferList, SOAP_TYPE_TransferList, sizeof(struct TransferList), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct TransferList * SOAP_FMAC4 soap_new_TransferList(struct soap *soap, int n)
{
	struct TransferList *p;
	struct TransferList *a = (struct TransferList*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct TransferList));
	for (p = a; p && n--; p++)
		soap_default_TransferList(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TransferList(struct soap *soap, const struct TransferList *a, const char *tag, const char *type)
{
	if (soap_out_TransferList(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct TransferList * SOAP_FMAC4 soap_get_TransferList(struct soap *soap, struct TransferList *p, const char *tag, const char *type)
{
	if ((p = soap_in_TransferList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__cwmp__GetQueuedTransfersResponse(struct soap *soap, struct _cwmp__GetQueuedTransfersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->TransferList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__cwmp__GetQueuedTransfersResponse(struct soap *soap, const struct _cwmp__GetQueuedTransfersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToTransferList(soap, &a->TransferList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__cwmp__GetQueuedTransfersResponse(struct soap *soap, const char *tag, int id, const struct _cwmp__GetQueuedTransfersResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__cwmp__GetQueuedTransfersResponse), type))
		return soap->error;
	if (!a->TransferList)
	{	if (soap_element_empty(soap, "TransferList"))
			return soap->error;
	}
	else
	if (soap_out_PointerToTransferList(soap, "TransferList", -1, &a->TransferList, "cwmp:QueuedTransferStruct"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _cwmp__GetQueuedTransfersResponse * SOAP_FMAC4 soap_in__cwmp__GetQueuedTransfersResponse(struct soap *soap, const char *tag, struct _cwmp__GetQueuedTransfersResponse *a, const char *type)
{
	size_t soap_flag_TransferList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _cwmp__GetQueuedTransfersResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__cwmp__GetQueuedTransfersResponse, sizeof(struct _cwmp__GetQueuedTransfersResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__cwmp__GetQueuedTransfersResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TransferList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToTransferList(soap, "TransferList", &a->TransferList, "cwmp:QueuedTransferStruct"))
				{	soap_flag_TransferList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->TransferList))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _cwmp__GetQueuedTransfersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__cwmp__GetQueuedTransfersResponse, SOAP_TYPE__cwmp__GetQueuedTransfersResponse, sizeof(struct _cwmp__GetQueuedTransfersResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _cwmp__GetQueuedTransfersResponse * SOAP_FMAC4 soap_new__cwmp__GetQueuedTransfersResponse(struct soap *soap, int n)
{
	struct _cwmp__GetQueuedTransfersResponse *p;
	struct _cwmp__GetQueuedTransfersResponse *a = (struct _cwmp__GetQueuedTransfersResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _cwmp__GetQueuedTransfersResponse));
	for (p = a; p && n--; p++)
		soap_default__cwmp__GetQueuedTransfersResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__cwmp__GetQueuedTransfersResponse(struct soap *soap, const struct _cwmp__GetQueuedTransfersResponse *a, const char *tag, const char *type)
{
	if (soap_out__cwmp__GetQueuedTransfersResponse(soap, tag ? tag : "cwmp:GetQueuedTransfersResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _cwmp__GetQueuedTransfersResponse * SOAP_FMAC4 soap_get__cwmp__GetQueuedTransfersResponse(struct soap *soap, struct _cwmp__GetQueuedTransfersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__cwmp__GetQueuedTransfersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__cwmp__GetQueuedTransfers(struct soap *soap, struct _cwmp__GetQueuedTransfers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__cwmp__GetQueuedTransfers(struct soap *soap, const struct _cwmp__GetQueuedTransfers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__cwmp__GetQueuedTransfers(struct soap *soap, const char *tag, int id, const struct _cwmp__GetQueuedTransfers *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__cwmp__GetQueuedTransfers), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _cwmp__GetQueuedTransfers * SOAP_FMAC4 soap_in__cwmp__GetQueuedTransfers(struct soap *soap, const char *tag, struct _cwmp__GetQueuedTransfers *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _cwmp__GetQueuedTransfers *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__cwmp__GetQueuedTransfers, sizeof(struct _cwmp__GetQueuedTransfers), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__cwmp__GetQueuedTransfers(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _cwmp__GetQueuedTransfers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__cwmp__GetQueuedTransfers, SOAP_TYPE__cwmp__GetQueuedTransfers, sizeof(struct _cwmp__GetQueuedTransfers), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _cwmp__GetQueuedTransfers * SOAP_FMAC4 soap_new__cwmp__GetQueuedTransfers(struct soap *soap, int n)
{
	struct _cwmp__GetQueuedTransfers *p;
	struct _cwmp__GetQueuedTransfers *a = (struct _cwmp__GetQueuedTransfers*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _cwmp__GetQueuedTransfers));
	for (p = a; p && n--; p++)
		soap_default__cwmp__GetQueuedTransfers(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__cwmp__GetQueuedTransfers(struct soap *soap, const struct _cwmp__GetQueuedTransfers *a, const char *tag, const char *type)
{
	if (soap_out__cwmp__GetQueuedTransfers(soap, tag ? tag : "cwmp:GetQueuedTransfers", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _cwmp__GetQueuedTransfers * SOAP_FMAC4 soap_get__cwmp__GetQueuedTransfers(struct soap *soap, struct _cwmp__GetQueuedTransfers *p, const char *tag, const char *type)
{
	if ((p = soap_in__cwmp__GetQueuedTransfers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__cwmp__RebootResponse(struct soap *soap, struct _cwmp__RebootResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__cwmp__RebootResponse(struct soap *soap, const struct _cwmp__RebootResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__cwmp__RebootResponse(struct soap *soap, const char *tag, int id, const struct _cwmp__RebootResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__cwmp__RebootResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _cwmp__RebootResponse * SOAP_FMAC4 soap_in__cwmp__RebootResponse(struct soap *soap, const char *tag, struct _cwmp__RebootResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _cwmp__RebootResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__cwmp__RebootResponse, sizeof(struct _cwmp__RebootResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__cwmp__RebootResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _cwmp__RebootResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__cwmp__RebootResponse, SOAP_TYPE__cwmp__RebootResponse, sizeof(struct _cwmp__RebootResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _cwmp__RebootResponse * SOAP_FMAC4 soap_new__cwmp__RebootResponse(struct soap *soap, int n)
{
	struct _cwmp__RebootResponse *p;
	struct _cwmp__RebootResponse *a = (struct _cwmp__RebootResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _cwmp__RebootResponse));
	for (p = a; p && n--; p++)
		soap_default__cwmp__RebootResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__cwmp__RebootResponse(struct soap *soap, const struct _cwmp__RebootResponse *a, const char *tag, const char *type)
{
	if (soap_out__cwmp__RebootResponse(soap, tag ? tag : "cwmp:RebootResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _cwmp__RebootResponse * SOAP_FMAC4 soap_get__cwmp__RebootResponse(struct soap *soap, struct _cwmp__RebootResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__cwmp__RebootResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__cwmp__Reboot(struct soap *soap, struct _cwmp__Reboot *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_cwmp__CommandKeyType(soap, &a->CommandKey);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__cwmp__Reboot(struct soap *soap, const struct _cwmp__Reboot *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_cwmp__CommandKeyType(soap, (char*const*)&a->CommandKey);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__cwmp__Reboot(struct soap *soap, const char *tag, int id, const struct _cwmp__Reboot *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__cwmp__Reboot), type))
		return soap->error;
	if (!a->CommandKey)
	{	if (soap_element_empty(soap, "CommandKey"))
			return soap->error;
	}
	else
	if (soap_out_cwmp__CommandKeyType(soap, "CommandKey", -1, (char*const*)&a->CommandKey, "cwmp:CommandKeyType"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _cwmp__Reboot * SOAP_FMAC4 soap_in__cwmp__Reboot(struct soap *soap, const char *tag, struct _cwmp__Reboot *a, const char *type)
{
	size_t soap_flag_CommandKey = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _cwmp__Reboot *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__cwmp__Reboot, sizeof(struct _cwmp__Reboot), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__cwmp__Reboot(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CommandKey && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_cwmp__CommandKeyType(soap, "CommandKey", (char**)&a->CommandKey, "cwmp:CommandKeyType"))
				{	soap_flag_CommandKey--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->CommandKey))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _cwmp__Reboot *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__cwmp__Reboot, SOAP_TYPE__cwmp__Reboot, sizeof(struct _cwmp__Reboot), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _cwmp__Reboot * SOAP_FMAC4 soap_new__cwmp__Reboot(struct soap *soap, int n)
{
	struct _cwmp__Reboot *p;
	struct _cwmp__Reboot *a = (struct _cwmp__Reboot*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _cwmp__Reboot));
	for (p = a; p && n--; p++)
		soap_default__cwmp__Reboot(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__cwmp__Reboot(struct soap *soap, const struct _cwmp__Reboot *a, const char *tag, const char *type)
{
	if (soap_out__cwmp__Reboot(soap, tag ? tag : "cwmp:Reboot", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _cwmp__Reboot * SOAP_FMAC4 soap_get__cwmp__Reboot(struct soap *soap, struct _cwmp__Reboot *p, const char *tag, const char *type)
{
	if ((p = soap_in__cwmp__Reboot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__cwmp__DownloadResponse(struct soap *soap, struct _cwmp__DownloadResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__cwmp__DownloadResponse_Status(soap, &a->Status);
	soap_default_dateTime(soap, &a->StartTime);
	soap_default_dateTime(soap, &a->CompleteTime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__cwmp__DownloadResponse(struct soap *soap, const struct _cwmp__DownloadResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->StartTime, SOAP_TYPE_dateTime);
	soap_embedded(soap, &a->CompleteTime, SOAP_TYPE_dateTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__cwmp__DownloadResponse(struct soap *soap, const char *tag, int id, const struct _cwmp__DownloadResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__cwmp__DownloadResponse), type))
		return soap->error;
	if (soap_out__cwmp__DownloadResponse_Status(soap, "Status", -1, &a->Status, "cwmp:DownloadResponse-Status"))
		return soap->error;
	if (soap_out_dateTime(soap, "StartTime", -1, &a->StartTime, "xsd:dateTime"))
		return soap->error;
	if (soap_out_dateTime(soap, "CompleteTime", -1, &a->CompleteTime, "xsd:dateTime"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _cwmp__DownloadResponse * SOAP_FMAC4 soap_in__cwmp__DownloadResponse(struct soap *soap, const char *tag, struct _cwmp__DownloadResponse *a, const char *type)
{
	size_t soap_flag_Status = 1;
	size_t soap_flag_StartTime = 1;
	size_t soap_flag_CompleteTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _cwmp__DownloadResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__cwmp__DownloadResponse, sizeof(struct _cwmp__DownloadResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__cwmp__DownloadResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__cwmp__DownloadResponse_Status(soap, "Status", &a->Status, "cwmp:DownloadResponse-Status"))
				{	soap_flag_Status--;
					continue;
				}
			if (soap_flag_StartTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_dateTime(soap, "StartTime", &a->StartTime, "xsd:dateTime"))
				{	soap_flag_StartTime--;
					continue;
				}
			if (soap_flag_CompleteTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_dateTime(soap, "CompleteTime", &a->CompleteTime, "xsd:dateTime"))
				{	soap_flag_CompleteTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Status > 0 || soap_flag_StartTime > 0 || soap_flag_CompleteTime > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _cwmp__DownloadResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__cwmp__DownloadResponse, SOAP_TYPE__cwmp__DownloadResponse, sizeof(struct _cwmp__DownloadResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _cwmp__DownloadResponse * SOAP_FMAC4 soap_new__cwmp__DownloadResponse(struct soap *soap, int n)
{
	struct _cwmp__DownloadResponse *p;
	struct _cwmp__DownloadResponse *a = (struct _cwmp__DownloadResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _cwmp__DownloadResponse));
	for (p = a; p && n--; p++)
		soap_default__cwmp__DownloadResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__cwmp__DownloadResponse(struct soap *soap, const struct _cwmp__DownloadResponse *a, const char *tag, const char *type)
{
	if (soap_out__cwmp__DownloadResponse(soap, tag ? tag : "cwmp:DownloadResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _cwmp__DownloadResponse * SOAP_FMAC4 soap_get__cwmp__DownloadResponse(struct soap *soap, struct _cwmp__DownloadResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__cwmp__DownloadResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__cwmp__Download(struct soap *soap, struct _cwmp__Download *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_cwmp__CommandKeyType(soap, &a->CommandKey);
	soap_default_string(soap, &a->FileType);
	soap_default_string(soap, &a->URL);
	soap_default_string(soap, &a->Username);
	soap_default_string(soap, &a->Password);
	soap_default_unsignedInt(soap, &a->FileSize);
	soap_default_string(soap, &a->TargetFileName);
	soap_default_unsignedInt(soap, &a->DelaySeconds);
	soap_default_string(soap, &a->SuccessURL);
	soap_default_string(soap, &a->FailureURL);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__cwmp__Download(struct soap *soap, const struct _cwmp__Download *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_cwmp__CommandKeyType(soap, (char*const*)&a->CommandKey);
	soap_serialize_string(soap, (char*const*)&a->FileType);
	soap_serialize_string(soap, (char*const*)&a->URL);
	soap_serialize_string(soap, (char*const*)&a->Username);
	soap_serialize_string(soap, (char*const*)&a->Password);
	soap_serialize_string(soap, (char*const*)&a->TargetFileName);
	soap_serialize_string(soap, (char*const*)&a->SuccessURL);
	soap_serialize_string(soap, (char*const*)&a->FailureURL);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__cwmp__Download(struct soap *soap, const char *tag, int id, const struct _cwmp__Download *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__cwmp__Download), type))
		return soap->error;
	if (!a->CommandKey)
	{	if (soap_element_empty(soap, "CommandKey"))
			return soap->error;
	}
	else
	if (soap_out_cwmp__CommandKeyType(soap, "CommandKey", -1, (char*const*)&a->CommandKey, "cwmp:CommandKeyType"))
		return soap->error;
	if (!a->FileType)
	{	if (soap_element_empty(soap, "FileType"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "FileType", -1, (char*const*)&a->FileType, "xsd:string"))
		return soap->error;
	if (!a->URL)
	{	if (soap_element_empty(soap, "URL"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "URL", -1, (char*const*)&a->URL, "xsd:string"))
		return soap->error;
	if (!a->Username)
	{	if (soap_element_empty(soap, "Username"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "Username", -1, (char*const*)&a->Username, "xsd:string"))
		return soap->error;
	if (!a->Password)
	{	if (soap_element_empty(soap, "Password"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "Password", -1, (char*const*)&a->Password, "xsd:string"))
		return soap->error;
	if (soap_out_unsignedInt(soap, "FileSize", -1, &a->FileSize, "xsd:unsignedInt"))
		return soap->error;
	if (!a->TargetFileName)
	{	if (soap_element_empty(soap, "TargetFileName"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "TargetFileName", -1, (char*const*)&a->TargetFileName, "xsd:string"))
		return soap->error;
	if (soap_out_unsignedInt(soap, "DelaySeconds", -1, &a->DelaySeconds, "xsd:unsignedInt"))
		return soap->error;
	if (!a->SuccessURL)
	{	if (soap_element_empty(soap, "SuccessURL"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "SuccessURL", -1, (char*const*)&a->SuccessURL, "xsd:string"))
		return soap->error;
	if (!a->FailureURL)
	{	if (soap_element_empty(soap, "FailureURL"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "FailureURL", -1, (char*const*)&a->FailureURL, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _cwmp__Download * SOAP_FMAC4 soap_in__cwmp__Download(struct soap *soap, const char *tag, struct _cwmp__Download *a, const char *type)
{
	size_t soap_flag_CommandKey = 1;
	size_t soap_flag_FileType = 1;
	size_t soap_flag_URL = 1;
	size_t soap_flag_Username = 1;
	size_t soap_flag_Password = 1;
	size_t soap_flag_FileSize = 1;
	size_t soap_flag_TargetFileName = 1;
	size_t soap_flag_DelaySeconds = 1;
	size_t soap_flag_SuccessURL = 1;
	size_t soap_flag_FailureURL = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _cwmp__Download *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__cwmp__Download, sizeof(struct _cwmp__Download), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__cwmp__Download(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CommandKey && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_cwmp__CommandKeyType(soap, "CommandKey", (char**)&a->CommandKey, "cwmp:CommandKeyType"))
				{	soap_flag_CommandKey--;
					continue;
				}
			if (soap_flag_FileType && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "FileType", (char**)&a->FileType, "xsd:string"))
				{	soap_flag_FileType--;
					continue;
				}
			if (soap_flag_URL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "URL", (char**)&a->URL, "xsd:string"))
				{	soap_flag_URL--;
					continue;
				}
			if (soap_flag_Username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Username", (char**)&a->Username, "xsd:string"))
				{	soap_flag_Username--;
					continue;
				}
			if (soap_flag_Password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Password", (char**)&a->Password, "xsd:string"))
				{	soap_flag_Password--;
					continue;
				}
			if (soap_flag_FileSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "FileSize", &a->FileSize, "xsd:unsignedInt"))
				{	soap_flag_FileSize--;
					continue;
				}
			if (soap_flag_TargetFileName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "TargetFileName", (char**)&a->TargetFileName, "xsd:string"))
				{	soap_flag_TargetFileName--;
					continue;
				}
			if (soap_flag_DelaySeconds && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "DelaySeconds", &a->DelaySeconds, "xsd:unsignedInt"))
				{	soap_flag_DelaySeconds--;
					continue;
				}
			if (soap_flag_SuccessURL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SuccessURL", (char**)&a->SuccessURL, "xsd:string"))
				{	soap_flag_SuccessURL--;
					continue;
				}
			if (soap_flag_FailureURL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "FailureURL", (char**)&a->FailureURL, "xsd:string"))
				{	soap_flag_FailureURL--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->CommandKey || !a->FileType || !a->URL || !a->Username || !a->Password || soap_flag_FileSize > 0 || !a->TargetFileName || soap_flag_DelaySeconds > 0 || !a->SuccessURL || !a->FailureURL))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _cwmp__Download *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__cwmp__Download, SOAP_TYPE__cwmp__Download, sizeof(struct _cwmp__Download), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _cwmp__Download * SOAP_FMAC4 soap_new__cwmp__Download(struct soap *soap, int n)
{
	struct _cwmp__Download *p;
	struct _cwmp__Download *a = (struct _cwmp__Download*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _cwmp__Download));
	for (p = a; p && n--; p++)
		soap_default__cwmp__Download(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__cwmp__Download(struct soap *soap, const struct _cwmp__Download *a, const char *tag, const char *type)
{
	if (soap_out__cwmp__Download(soap, tag ? tag : "cwmp:Download", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _cwmp__Download * SOAP_FMAC4 soap_get__cwmp__Download(struct soap *soap, struct _cwmp__Download *p, const char *tag, const char *type)
{
	if ((p = soap_in__cwmp__Download(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__cwmp__DeleteObjectResponse(struct soap *soap, struct _cwmp__DeleteObjectResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__cwmp__DeleteObjectResponse_Status(soap, &a->Status);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__cwmp__DeleteObjectResponse(struct soap *soap, const struct _cwmp__DeleteObjectResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__cwmp__DeleteObjectResponse(struct soap *soap, const char *tag, int id, const struct _cwmp__DeleteObjectResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__cwmp__DeleteObjectResponse), type))
		return soap->error;
	if (soap_out__cwmp__DeleteObjectResponse_Status(soap, "Status", -1, &a->Status, "cwmp:DeleteObjectResponse-Status"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _cwmp__DeleteObjectResponse * SOAP_FMAC4 soap_in__cwmp__DeleteObjectResponse(struct soap *soap, const char *tag, struct _cwmp__DeleteObjectResponse *a, const char *type)
{
	size_t soap_flag_Status = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _cwmp__DeleteObjectResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__cwmp__DeleteObjectResponse, sizeof(struct _cwmp__DeleteObjectResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__cwmp__DeleteObjectResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__cwmp__DeleteObjectResponse_Status(soap, "Status", &a->Status, "cwmp:DeleteObjectResponse-Status"))
				{	soap_flag_Status--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Status > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _cwmp__DeleteObjectResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__cwmp__DeleteObjectResponse, SOAP_TYPE__cwmp__DeleteObjectResponse, sizeof(struct _cwmp__DeleteObjectResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _cwmp__DeleteObjectResponse * SOAP_FMAC4 soap_new__cwmp__DeleteObjectResponse(struct soap *soap, int n)
{
	struct _cwmp__DeleteObjectResponse *p;
	struct _cwmp__DeleteObjectResponse *a = (struct _cwmp__DeleteObjectResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _cwmp__DeleteObjectResponse));
	for (p = a; p && n--; p++)
		soap_default__cwmp__DeleteObjectResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__cwmp__DeleteObjectResponse(struct soap *soap, const struct _cwmp__DeleteObjectResponse *a, const char *tag, const char *type)
{
	if (soap_out__cwmp__DeleteObjectResponse(soap, tag ? tag : "cwmp:DeleteObjectResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _cwmp__DeleteObjectResponse * SOAP_FMAC4 soap_get__cwmp__DeleteObjectResponse(struct soap *soap, struct _cwmp__DeleteObjectResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__cwmp__DeleteObjectResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__cwmp__DeleteObject(struct soap *soap, struct _cwmp__DeleteObject *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_cwmp__ObjectNameType(soap, &a->ObjectName);
	soap_default_cwmp__ParameterKeyType(soap, &a->ParameterKey);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__cwmp__DeleteObject(struct soap *soap, const struct _cwmp__DeleteObject *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_cwmp__ObjectNameType(soap, (char*const*)&a->ObjectName);
	soap_serialize_cwmp__ParameterKeyType(soap, (char*const*)&a->ParameterKey);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__cwmp__DeleteObject(struct soap *soap, const char *tag, int id, const struct _cwmp__DeleteObject *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__cwmp__DeleteObject), type))
		return soap->error;
	if (!a->ObjectName)
	{	if (soap_element_empty(soap, "ObjectName"))
			return soap->error;
	}
	else
	if (soap_out_cwmp__ObjectNameType(soap, "ObjectName", -1, (char*const*)&a->ObjectName, "cwmp:ObjectNameType"))
		return soap->error;
	if (!a->ParameterKey)
	{	if (soap_element_empty(soap, "ParameterKey"))
			return soap->error;
	}
	else
	if (soap_out_cwmp__ParameterKeyType(soap, "ParameterKey", -1, (char*const*)&a->ParameterKey, "cwmp:ParameterKeyType"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _cwmp__DeleteObject * SOAP_FMAC4 soap_in__cwmp__DeleteObject(struct soap *soap, const char *tag, struct _cwmp__DeleteObject *a, const char *type)
{
	size_t soap_flag_ObjectName = 1;
	size_t soap_flag_ParameterKey = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _cwmp__DeleteObject *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__cwmp__DeleteObject, sizeof(struct _cwmp__DeleteObject), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__cwmp__DeleteObject(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ObjectName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_cwmp__ObjectNameType(soap, "ObjectName", (char**)&a->ObjectName, "cwmp:ObjectNameType"))
				{	soap_flag_ObjectName--;
					continue;
				}
			if (soap_flag_ParameterKey && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_cwmp__ParameterKeyType(soap, "ParameterKey", (char**)&a->ParameterKey, "cwmp:ParameterKeyType"))
				{	soap_flag_ParameterKey--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ObjectName || !a->ParameterKey))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _cwmp__DeleteObject *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__cwmp__DeleteObject, SOAP_TYPE__cwmp__DeleteObject, sizeof(struct _cwmp__DeleteObject), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _cwmp__DeleteObject * SOAP_FMAC4 soap_new__cwmp__DeleteObject(struct soap *soap, int n)
{
	struct _cwmp__DeleteObject *p;
	struct _cwmp__DeleteObject *a = (struct _cwmp__DeleteObject*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _cwmp__DeleteObject));
	for (p = a; p && n--; p++)
		soap_default__cwmp__DeleteObject(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__cwmp__DeleteObject(struct soap *soap, const struct _cwmp__DeleteObject *a, const char *tag, const char *type)
{
	if (soap_out__cwmp__DeleteObject(soap, tag ? tag : "cwmp:DeleteObject", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _cwmp__DeleteObject * SOAP_FMAC4 soap_get__cwmp__DeleteObject(struct soap *soap, struct _cwmp__DeleteObject *p, const char *tag, const char *type)
{
	if ((p = soap_in__cwmp__DeleteObject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__cwmp__AddObjectResponse(struct soap *soap, struct _cwmp__AddObjectResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_unsignedInt(soap, &a->InstanceNumber);
	soap_default__cwmp__AddObjectResponse_Status(soap, &a->Status);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__cwmp__AddObjectResponse(struct soap *soap, const struct _cwmp__AddObjectResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__cwmp__AddObjectResponse(struct soap *soap, const char *tag, int id, const struct _cwmp__AddObjectResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__cwmp__AddObjectResponse), type))
		return soap->error;
	if (soap_out_unsignedInt(soap, "InstanceNumber", -1, &a->InstanceNumber, "xsd:unsignedInt"))
		return soap->error;
	if (soap_out__cwmp__AddObjectResponse_Status(soap, "Status", -1, &a->Status, "cwmp:AddObjectResponse-Status"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _cwmp__AddObjectResponse * SOAP_FMAC4 soap_in__cwmp__AddObjectResponse(struct soap *soap, const char *tag, struct _cwmp__AddObjectResponse *a, const char *type)
{
	size_t soap_flag_InstanceNumber = 1;
	size_t soap_flag_Status = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _cwmp__AddObjectResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__cwmp__AddObjectResponse, sizeof(struct _cwmp__AddObjectResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__cwmp__AddObjectResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InstanceNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "InstanceNumber", &a->InstanceNumber, "xsd:unsignedInt"))
				{	soap_flag_InstanceNumber--;
					continue;
				}
			if (soap_flag_Status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__cwmp__AddObjectResponse_Status(soap, "Status", &a->Status, "cwmp:AddObjectResponse-Status"))
				{	soap_flag_Status--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_InstanceNumber > 0 || soap_flag_Status > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _cwmp__AddObjectResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__cwmp__AddObjectResponse, SOAP_TYPE__cwmp__AddObjectResponse, sizeof(struct _cwmp__AddObjectResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _cwmp__AddObjectResponse * SOAP_FMAC4 soap_new__cwmp__AddObjectResponse(struct soap *soap, int n)
{
	struct _cwmp__AddObjectResponse *p;
	struct _cwmp__AddObjectResponse *a = (struct _cwmp__AddObjectResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _cwmp__AddObjectResponse));
	for (p = a; p && n--; p++)
		soap_default__cwmp__AddObjectResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__cwmp__AddObjectResponse(struct soap *soap, const struct _cwmp__AddObjectResponse *a, const char *tag, const char *type)
{
	if (soap_out__cwmp__AddObjectResponse(soap, tag ? tag : "cwmp:AddObjectResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _cwmp__AddObjectResponse * SOAP_FMAC4 soap_get__cwmp__AddObjectResponse(struct soap *soap, struct _cwmp__AddObjectResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__cwmp__AddObjectResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__cwmp__AddObject(struct soap *soap, struct _cwmp__AddObject *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_cwmp__ObjectNameType(soap, &a->ObjectName);
	soap_default_cwmp__ParameterKeyType(soap, &a->ParameterKey);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__cwmp__AddObject(struct soap *soap, const struct _cwmp__AddObject *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_cwmp__ObjectNameType(soap, (char*const*)&a->ObjectName);
	soap_serialize_cwmp__ParameterKeyType(soap, (char*const*)&a->ParameterKey);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__cwmp__AddObject(struct soap *soap, const char *tag, int id, const struct _cwmp__AddObject *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__cwmp__AddObject), type))
		return soap->error;
	if (!a->ObjectName)
	{	if (soap_element_empty(soap, "ObjectName"))
			return soap->error;
	}
	else
	if (soap_out_cwmp__ObjectNameType(soap, "ObjectName", -1, (char*const*)&a->ObjectName, "cwmp:ObjectNameType"))
		return soap->error;
	if (!a->ParameterKey)
	{	if (soap_element_empty(soap, "ParameterKey"))
			return soap->error;
	}
	else
	if (soap_out_cwmp__ParameterKeyType(soap, "ParameterKey", -1, (char*const*)&a->ParameterKey, "cwmp:ParameterKeyType"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _cwmp__AddObject * SOAP_FMAC4 soap_in__cwmp__AddObject(struct soap *soap, const char *tag, struct _cwmp__AddObject *a, const char *type)
{
	size_t soap_flag_ObjectName = 1;
	size_t soap_flag_ParameterKey = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _cwmp__AddObject *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__cwmp__AddObject, sizeof(struct _cwmp__AddObject), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__cwmp__AddObject(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ObjectName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_cwmp__ObjectNameType(soap, "ObjectName", (char**)&a->ObjectName, "cwmp:ObjectNameType"))
				{	soap_flag_ObjectName--;
					continue;
				}
			if (soap_flag_ParameterKey && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_cwmp__ParameterKeyType(soap, "ParameterKey", (char**)&a->ParameterKey, "cwmp:ParameterKeyType"))
				{	soap_flag_ParameterKey--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ObjectName || !a->ParameterKey))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _cwmp__AddObject *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__cwmp__AddObject, SOAP_TYPE__cwmp__AddObject, sizeof(struct _cwmp__AddObject), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _cwmp__AddObject * SOAP_FMAC4 soap_new__cwmp__AddObject(struct soap *soap, int n)
{
	struct _cwmp__AddObject *p;
	struct _cwmp__AddObject *a = (struct _cwmp__AddObject*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _cwmp__AddObject));
	for (p = a; p && n--; p++)
		soap_default__cwmp__AddObject(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__cwmp__AddObject(struct soap *soap, const struct _cwmp__AddObject *a, const char *tag, const char *type)
{
	if (soap_out__cwmp__AddObject(soap, tag ? tag : "cwmp:AddObject", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _cwmp__AddObject * SOAP_FMAC4 soap_get__cwmp__AddObject(struct soap *soap, struct _cwmp__AddObject *p, const char *tag, const char *type)
{
	if ((p = soap_in__cwmp__AddObject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ParameterAttributeList(struct soap *soap, struct ParameterAttributeList *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__ptrParameterAttributeStruct = NULL;
	a->__size = 0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ParameterAttributeList(struct soap *soap, const struct ParameterAttributeList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__ptrParameterAttributeStruct && !soap_array_reference(soap, a, a->__ptrParameterAttributeStruct, a->__size, SOAP_TYPE_ParameterAttributeList))
	{	int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTocwmp__ParameterAttributeStruct(soap, a->__ptrParameterAttributeStruct + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ParameterAttributeList(struct soap *soap, const char *tag, int id, const struct ParameterAttributeList *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptrParameterAttributeStruct ? soap_putsizesoffsets(soap, "cwmp:ParameterAttributeStruct", &a->__size, NULL, 1) : NULL;
	id = soap_element_id(soap, tag, id, a, a->__ptrParameterAttributeStruct, a->__size, type, SOAP_TYPE_ParameterAttributeList, NULL);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTocwmp__ParameterAttributeStruct(soap, "ParameterAttributeStruct", -1, &a->__ptrParameterAttributeStruct[i], "cwmp:ParameterAttributeStruct");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ParameterAttributeList * SOAP_FMAC4 soap_in_ParameterAttributeList(struct soap *soap, const char *tag, struct ParameterAttributeList *a, const char *type)
{	int i, j;
	struct cwmp__ParameterAttributeStruct **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ParameterAttributeList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ParameterAttributeList, sizeof(struct ParameterAttributeList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ParameterAttributeList(soap, a);
	if (soap->body && !*soap->href)
	{
		if (*soap->arraySize)
		{
			soap_getsizes(soap->arraySize, &a->__size, 1);
			a->__size -= j = soap_getoffsets(soap->arrayOffset, &a->__size, NULL, 1);
			if ((size_t)a->__size > soap->maxoccurs)
			{	soap->error = SOAP_OCCURS;
				return NULL;
			}
			a->__ptrParameterAttributeStruct = (struct cwmp__ParameterAttributeStruct **)soap_malloc(soap, sizeof(struct cwmp__ParameterAttributeStruct *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptrParameterAttributeStruct[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTocwmp__ParameterAttributeStruct(soap, NULL, a->__ptrParameterAttributeStruct + i, "cwmp:ParameterAttributeStruct"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_alloc_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct cwmp__ParameterAttributeStruct **)soap_push_block(soap, NULL, sizeof(struct cwmp__ParameterAttributeStruct *));
				if (!p)
					break;
				*p = NULL;
				if (!soap_in_PointerTocwmp__ParameterAttributeStruct(soap, NULL, p, "cwmp:ParameterAttributeStruct"))
				{	if (soap->error == SOAP_NO_TAG)
						soap->error = SOAP_OK;
					soap_pop_block(soap, NULL);
					break;
				}
				if ((size_t)a->__size > soap->maxoccurs)
				{	soap->error = SOAP_OCCURS;
					return NULL;
				}
			}
			a->__ptrParameterAttributeStruct = (struct cwmp__ParameterAttributeStruct **)soap_save_block(soap, NULL, NULL, 1);
		}
		if (soap->error || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ParameterAttributeList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ParameterAttributeList, SOAP_TYPE_ParameterAttributeList, sizeof(struct ParameterAttributeList), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ParameterAttributeList * SOAP_FMAC4 soap_new_ParameterAttributeList(struct soap *soap, int n)
{
	struct ParameterAttributeList *p;
	struct ParameterAttributeList *a = (struct ParameterAttributeList*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ParameterAttributeList));
	for (p = a; p && n--; p++)
		soap_default_ParameterAttributeList(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ParameterAttributeList(struct soap *soap, const struct ParameterAttributeList *a, const char *tag, const char *type)
{
	if (soap_out_ParameterAttributeList(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ParameterAttributeList * SOAP_FMAC4 soap_get_ParameterAttributeList(struct soap *soap, struct ParameterAttributeList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ParameterAttributeList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__cwmp__GetParameterAttributesResponse(struct soap *soap, struct _cwmp__GetParameterAttributesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ParameterList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__cwmp__GetParameterAttributesResponse(struct soap *soap, const struct _cwmp__GetParameterAttributesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToParameterAttributeList(soap, &a->ParameterList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__cwmp__GetParameterAttributesResponse(struct soap *soap, const char *tag, int id, const struct _cwmp__GetParameterAttributesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__cwmp__GetParameterAttributesResponse), type))
		return soap->error;
	if (!a->ParameterList)
	{	if (soap_element_empty(soap, "ParameterList"))
			return soap->error;
	}
	else
	if (soap_out_PointerToParameterAttributeList(soap, "ParameterList", -1, &a->ParameterList, "cwmp:ParameterAttributeStruct"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _cwmp__GetParameterAttributesResponse * SOAP_FMAC4 soap_in__cwmp__GetParameterAttributesResponse(struct soap *soap, const char *tag, struct _cwmp__GetParameterAttributesResponse *a, const char *type)
{
	size_t soap_flag_ParameterList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _cwmp__GetParameterAttributesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__cwmp__GetParameterAttributesResponse, sizeof(struct _cwmp__GetParameterAttributesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__cwmp__GetParameterAttributesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ParameterList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToParameterAttributeList(soap, "ParameterList", &a->ParameterList, "cwmp:ParameterAttributeStruct"))
				{	soap_flag_ParameterList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ParameterList))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _cwmp__GetParameterAttributesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__cwmp__GetParameterAttributesResponse, SOAP_TYPE__cwmp__GetParameterAttributesResponse, sizeof(struct _cwmp__GetParameterAttributesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _cwmp__GetParameterAttributesResponse * SOAP_FMAC4 soap_new__cwmp__GetParameterAttributesResponse(struct soap *soap, int n)
{
	struct _cwmp__GetParameterAttributesResponse *p;
	struct _cwmp__GetParameterAttributesResponse *a = (struct _cwmp__GetParameterAttributesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _cwmp__GetParameterAttributesResponse));
	for (p = a; p && n--; p++)
		soap_default__cwmp__GetParameterAttributesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__cwmp__GetParameterAttributesResponse(struct soap *soap, const struct _cwmp__GetParameterAttributesResponse *a, const char *tag, const char *type)
{
	if (soap_out__cwmp__GetParameterAttributesResponse(soap, tag ? tag : "cwmp:GetParameterAttributesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _cwmp__GetParameterAttributesResponse * SOAP_FMAC4 soap_get__cwmp__GetParameterAttributesResponse(struct soap *soap, struct _cwmp__GetParameterAttributesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__cwmp__GetParameterAttributesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__cwmp__GetParameterAttributes(struct soap *soap, struct _cwmp__GetParameterAttributes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ParameterNames = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__cwmp__GetParameterAttributes(struct soap *soap, const struct _cwmp__GetParameterAttributes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToParameterNames(soap, &a->ParameterNames);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__cwmp__GetParameterAttributes(struct soap *soap, const char *tag, int id, const struct _cwmp__GetParameterAttributes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__cwmp__GetParameterAttributes), type))
		return soap->error;
	if (!a->ParameterNames)
	{	if (soap_element_empty(soap, "ParameterNames"))
			return soap->error;
	}
	else
	if (soap_out_PointerToParameterNames(soap, "ParameterNames", -1, &a->ParameterNames, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _cwmp__GetParameterAttributes * SOAP_FMAC4 soap_in__cwmp__GetParameterAttributes(struct soap *soap, const char *tag, struct _cwmp__GetParameterAttributes *a, const char *type)
{
	size_t soap_flag_ParameterNames = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _cwmp__GetParameterAttributes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__cwmp__GetParameterAttributes, sizeof(struct _cwmp__GetParameterAttributes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__cwmp__GetParameterAttributes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ParameterNames && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToParameterNames(soap, "ParameterNames", &a->ParameterNames, "xsd:string"))
				{	soap_flag_ParameterNames--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ParameterNames))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _cwmp__GetParameterAttributes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__cwmp__GetParameterAttributes, SOAP_TYPE__cwmp__GetParameterAttributes, sizeof(struct _cwmp__GetParameterAttributes), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _cwmp__GetParameterAttributes * SOAP_FMAC4 soap_new__cwmp__GetParameterAttributes(struct soap *soap, int n)
{
	struct _cwmp__GetParameterAttributes *p;
	struct _cwmp__GetParameterAttributes *a = (struct _cwmp__GetParameterAttributes*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _cwmp__GetParameterAttributes));
	for (p = a; p && n--; p++)
		soap_default__cwmp__GetParameterAttributes(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__cwmp__GetParameterAttributes(struct soap *soap, const struct _cwmp__GetParameterAttributes *a, const char *tag, const char *type)
{
	if (soap_out__cwmp__GetParameterAttributes(soap, tag ? tag : "cwmp:GetParameterAttributes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _cwmp__GetParameterAttributes * SOAP_FMAC4 soap_get__cwmp__GetParameterAttributes(struct soap *soap, struct _cwmp__GetParameterAttributes *p, const char *tag, const char *type)
{
	if ((p = soap_in__cwmp__GetParameterAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__cwmp__SetParameterAttributesResponse(struct soap *soap, struct _cwmp__SetParameterAttributesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__cwmp__SetParameterAttributesResponse(struct soap *soap, const struct _cwmp__SetParameterAttributesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__cwmp__SetParameterAttributesResponse(struct soap *soap, const char *tag, int id, const struct _cwmp__SetParameterAttributesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__cwmp__SetParameterAttributesResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _cwmp__SetParameterAttributesResponse * SOAP_FMAC4 soap_in__cwmp__SetParameterAttributesResponse(struct soap *soap, const char *tag, struct _cwmp__SetParameterAttributesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _cwmp__SetParameterAttributesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__cwmp__SetParameterAttributesResponse, sizeof(struct _cwmp__SetParameterAttributesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__cwmp__SetParameterAttributesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _cwmp__SetParameterAttributesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__cwmp__SetParameterAttributesResponse, SOAP_TYPE__cwmp__SetParameterAttributesResponse, sizeof(struct _cwmp__SetParameterAttributesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _cwmp__SetParameterAttributesResponse * SOAP_FMAC4 soap_new__cwmp__SetParameterAttributesResponse(struct soap *soap, int n)
{
	struct _cwmp__SetParameterAttributesResponse *p;
	struct _cwmp__SetParameterAttributesResponse *a = (struct _cwmp__SetParameterAttributesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _cwmp__SetParameterAttributesResponse));
	for (p = a; p && n--; p++)
		soap_default__cwmp__SetParameterAttributesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__cwmp__SetParameterAttributesResponse(struct soap *soap, const struct _cwmp__SetParameterAttributesResponse *a, const char *tag, const char *type)
{
	if (soap_out__cwmp__SetParameterAttributesResponse(soap, tag ? tag : "cwmp:SetParameterAttributesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _cwmp__SetParameterAttributesResponse * SOAP_FMAC4 soap_get__cwmp__SetParameterAttributesResponse(struct soap *soap, struct _cwmp__SetParameterAttributesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__cwmp__SetParameterAttributesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SetParameterAttributesList(struct soap *soap, struct SetParameterAttributesList *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__ptrSetParameterAttributesStruct = NULL;
	a->__size = 0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SetParameterAttributesList(struct soap *soap, const struct SetParameterAttributesList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__ptrSetParameterAttributesStruct && !soap_array_reference(soap, a, a->__ptrSetParameterAttributesStruct, a->__size, SOAP_TYPE_SetParameterAttributesList))
	{	int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTocwmp__SetParameterAttributesStruct(soap, a->__ptrSetParameterAttributesStruct + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SetParameterAttributesList(struct soap *soap, const char *tag, int id, const struct SetParameterAttributesList *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptrSetParameterAttributesStruct ? soap_putsizesoffsets(soap, "cwmp:SetParameterAttributesStruct", &a->__size, NULL, 1) : NULL;
	id = soap_element_id(soap, tag, id, a, a->__ptrSetParameterAttributesStruct, a->__size, type, SOAP_TYPE_SetParameterAttributesList, NULL);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTocwmp__SetParameterAttributesStruct(soap, "SetParameterAttributesStruct", -1, &a->__ptrSetParameterAttributesStruct[i], "cwmp:SetParameterAttributesStruct");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SetParameterAttributesList * SOAP_FMAC4 soap_in_SetParameterAttributesList(struct soap *soap, const char *tag, struct SetParameterAttributesList *a, const char *type)
{	int i, j;
	struct cwmp__SetParameterAttributesStruct **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct SetParameterAttributesList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SetParameterAttributesList, sizeof(struct SetParameterAttributesList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SetParameterAttributesList(soap, a);
	if (soap->body && !*soap->href)
	{
		if (*soap->arraySize)
		{
			soap_getsizes(soap->arraySize, &a->__size, 1);
			a->__size -= j = soap_getoffsets(soap->arrayOffset, &a->__size, NULL, 1);
			if ((size_t)a->__size > soap->maxoccurs)
			{	soap->error = SOAP_OCCURS;
				return NULL;
			}
			a->__ptrSetParameterAttributesStruct = (struct cwmp__SetParameterAttributesStruct **)soap_malloc(soap, sizeof(struct cwmp__SetParameterAttributesStruct *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptrSetParameterAttributesStruct[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTocwmp__SetParameterAttributesStruct(soap, NULL, a->__ptrSetParameterAttributesStruct + i, "cwmp:SetParameterAttributesStruct"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_alloc_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct cwmp__SetParameterAttributesStruct **)soap_push_block(soap, NULL, sizeof(struct cwmp__SetParameterAttributesStruct *));
				if (!p)
					break;
				*p = NULL;
				if (!soap_in_PointerTocwmp__SetParameterAttributesStruct(soap, NULL, p, "cwmp:SetParameterAttributesStruct"))
				{	if (soap->error == SOAP_NO_TAG)
						soap->error = SOAP_OK;
					soap_pop_block(soap, NULL);
					break;
				}
				if ((size_t)a->__size > soap->maxoccurs)
				{	soap->error = SOAP_OCCURS;
					return NULL;
				}
			}
			a->__ptrSetParameterAttributesStruct = (struct cwmp__SetParameterAttributesStruct **)soap_save_block(soap, NULL, NULL, 1);
		}
		if (soap->error || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SetParameterAttributesList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SetParameterAttributesList, SOAP_TYPE_SetParameterAttributesList, sizeof(struct SetParameterAttributesList), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SetParameterAttributesList * SOAP_FMAC4 soap_new_SetParameterAttributesList(struct soap *soap, int n)
{
	struct SetParameterAttributesList *p;
	struct SetParameterAttributesList *a = (struct SetParameterAttributesList*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct SetParameterAttributesList));
	for (p = a; p && n--; p++)
		soap_default_SetParameterAttributesList(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SetParameterAttributesList(struct soap *soap, const struct SetParameterAttributesList *a, const char *tag, const char *type)
{
	if (soap_out_SetParameterAttributesList(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SetParameterAttributesList * SOAP_FMAC4 soap_get_SetParameterAttributesList(struct soap *soap, struct SetParameterAttributesList *p, const char *tag, const char *type)
{
	if ((p = soap_in_SetParameterAttributesList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__cwmp__SetParameterAttributes(struct soap *soap, struct _cwmp__SetParameterAttributes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ParameterList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__cwmp__SetParameterAttributes(struct soap *soap, const struct _cwmp__SetParameterAttributes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToSetParameterAttributesList(soap, &a->ParameterList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__cwmp__SetParameterAttributes(struct soap *soap, const char *tag, int id, const struct _cwmp__SetParameterAttributes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__cwmp__SetParameterAttributes), type))
		return soap->error;
	if (!a->ParameterList)
	{	if (soap_element_empty(soap, "ParameterList"))
			return soap->error;
	}
	else
	if (soap_out_PointerToSetParameterAttributesList(soap, "ParameterList", -1, &a->ParameterList, "cwmp:SetParameterAttributesStruct"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _cwmp__SetParameterAttributes * SOAP_FMAC4 soap_in__cwmp__SetParameterAttributes(struct soap *soap, const char *tag, struct _cwmp__SetParameterAttributes *a, const char *type)
{
	size_t soap_flag_ParameterList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _cwmp__SetParameterAttributes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__cwmp__SetParameterAttributes, sizeof(struct _cwmp__SetParameterAttributes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__cwmp__SetParameterAttributes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ParameterList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSetParameterAttributesList(soap, "ParameterList", &a->ParameterList, "cwmp:SetParameterAttributesStruct"))
				{	soap_flag_ParameterList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ParameterList))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _cwmp__SetParameterAttributes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__cwmp__SetParameterAttributes, SOAP_TYPE__cwmp__SetParameterAttributes, sizeof(struct _cwmp__SetParameterAttributes), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _cwmp__SetParameterAttributes * SOAP_FMAC4 soap_new__cwmp__SetParameterAttributes(struct soap *soap, int n)
{
	struct _cwmp__SetParameterAttributes *p;
	struct _cwmp__SetParameterAttributes *a = (struct _cwmp__SetParameterAttributes*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _cwmp__SetParameterAttributes));
	for (p = a; p && n--; p++)
		soap_default__cwmp__SetParameterAttributes(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__cwmp__SetParameterAttributes(struct soap *soap, const struct _cwmp__SetParameterAttributes *a, const char *tag, const char *type)
{
	if (soap_out__cwmp__SetParameterAttributes(soap, tag ? tag : "cwmp:SetParameterAttributes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _cwmp__SetParameterAttributes * SOAP_FMAC4 soap_get__cwmp__SetParameterAttributes(struct soap *soap, struct _cwmp__SetParameterAttributes *p, const char *tag, const char *type)
{
	if ((p = soap_in__cwmp__SetParameterAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ParameterInfoList(struct soap *soap, struct ParameterInfoList *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__ptrParameterInfoStruct = NULL;
	a->__size = 0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ParameterInfoList(struct soap *soap, const struct ParameterInfoList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__ptrParameterInfoStruct && !soap_array_reference(soap, a, a->__ptrParameterInfoStruct, a->__size, SOAP_TYPE_ParameterInfoList))
	{	int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTocwmp__ParameterInfoStruct(soap, a->__ptrParameterInfoStruct + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ParameterInfoList(struct soap *soap, const char *tag, int id, const struct ParameterInfoList *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptrParameterInfoStruct ? soap_putsizesoffsets(soap, "cwmp:ParameterInfoStruct", &a->__size, NULL, 1) : NULL;
	id = soap_element_id(soap, tag, id, a, a->__ptrParameterInfoStruct, a->__size, type, SOAP_TYPE_ParameterInfoList, NULL);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTocwmp__ParameterInfoStruct(soap, "ParameterInfoStruct", -1, &a->__ptrParameterInfoStruct[i], "cwmp:ParameterInfoStruct");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ParameterInfoList * SOAP_FMAC4 soap_in_ParameterInfoList(struct soap *soap, const char *tag, struct ParameterInfoList *a, const char *type)
{	int i, j;
	struct cwmp__ParameterInfoStruct **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ParameterInfoList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ParameterInfoList, sizeof(struct ParameterInfoList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ParameterInfoList(soap, a);
	if (soap->body && !*soap->href)
	{
		if (*soap->arraySize)
		{
			soap_getsizes(soap->arraySize, &a->__size, 1);
			a->__size -= j = soap_getoffsets(soap->arrayOffset, &a->__size, NULL, 1);
			if ((size_t)a->__size > soap->maxoccurs)
			{	soap->error = SOAP_OCCURS;
				return NULL;
			}
			a->__ptrParameterInfoStruct = (struct cwmp__ParameterInfoStruct **)soap_malloc(soap, sizeof(struct cwmp__ParameterInfoStruct *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptrParameterInfoStruct[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTocwmp__ParameterInfoStruct(soap, NULL, a->__ptrParameterInfoStruct + i, "cwmp:ParameterInfoStruct"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_alloc_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct cwmp__ParameterInfoStruct **)soap_push_block(soap, NULL, sizeof(struct cwmp__ParameterInfoStruct *));
				if (!p)
					break;
				*p = NULL;
				if (!soap_in_PointerTocwmp__ParameterInfoStruct(soap, NULL, p, "cwmp:ParameterInfoStruct"))
				{	if (soap->error == SOAP_NO_TAG)
						soap->error = SOAP_OK;
					soap_pop_block(soap, NULL);
					break;
				}
				if ((size_t)a->__size > soap->maxoccurs)
				{	soap->error = SOAP_OCCURS;
					return NULL;
				}
			}
			a->__ptrParameterInfoStruct = (struct cwmp__ParameterInfoStruct **)soap_save_block(soap, NULL, NULL, 1);
		}
		if (soap->error || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ParameterInfoList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ParameterInfoList, SOAP_TYPE_ParameterInfoList, sizeof(struct ParameterInfoList), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ParameterInfoList * SOAP_FMAC4 soap_new_ParameterInfoList(struct soap *soap, int n)
{
	struct ParameterInfoList *p;
	struct ParameterInfoList *a = (struct ParameterInfoList*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ParameterInfoList));
	for (p = a; p && n--; p++)
		soap_default_ParameterInfoList(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ParameterInfoList(struct soap *soap, const struct ParameterInfoList *a, const char *tag, const char *type)
{
	if (soap_out_ParameterInfoList(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ParameterInfoList * SOAP_FMAC4 soap_get_ParameterInfoList(struct soap *soap, struct ParameterInfoList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ParameterInfoList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__cwmp__GetParameterNamesResponse(struct soap *soap, struct _cwmp__GetParameterNamesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ParameterList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__cwmp__GetParameterNamesResponse(struct soap *soap, const struct _cwmp__GetParameterNamesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToParameterInfoList(soap, &a->ParameterList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__cwmp__GetParameterNamesResponse(struct soap *soap, const char *tag, int id, const struct _cwmp__GetParameterNamesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__cwmp__GetParameterNamesResponse), type))
		return soap->error;
	if (!a->ParameterList)
	{	if (soap_element_empty(soap, "ParameterList"))
			return soap->error;
	}
	else
	if (soap_out_PointerToParameterInfoList(soap, "ParameterList", -1, &a->ParameterList, "cwmp:ParameterInfoStruct"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _cwmp__GetParameterNamesResponse * SOAP_FMAC4 soap_in__cwmp__GetParameterNamesResponse(struct soap *soap, const char *tag, struct _cwmp__GetParameterNamesResponse *a, const char *type)
{
	size_t soap_flag_ParameterList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _cwmp__GetParameterNamesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__cwmp__GetParameterNamesResponse, sizeof(struct _cwmp__GetParameterNamesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__cwmp__GetParameterNamesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ParameterList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToParameterInfoList(soap, "ParameterList", &a->ParameterList, "cwmp:ParameterInfoStruct"))
				{	soap_flag_ParameterList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ParameterList))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _cwmp__GetParameterNamesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__cwmp__GetParameterNamesResponse, SOAP_TYPE__cwmp__GetParameterNamesResponse, sizeof(struct _cwmp__GetParameterNamesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _cwmp__GetParameterNamesResponse * SOAP_FMAC4 soap_new__cwmp__GetParameterNamesResponse(struct soap *soap, int n)
{
	struct _cwmp__GetParameterNamesResponse *p;
	struct _cwmp__GetParameterNamesResponse *a = (struct _cwmp__GetParameterNamesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _cwmp__GetParameterNamesResponse));
	for (p = a; p && n--; p++)
		soap_default__cwmp__GetParameterNamesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__cwmp__GetParameterNamesResponse(struct soap *soap, const struct _cwmp__GetParameterNamesResponse *a, const char *tag, const char *type)
{
	if (soap_out__cwmp__GetParameterNamesResponse(soap, tag ? tag : "cwmp:GetParameterNamesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _cwmp__GetParameterNamesResponse * SOAP_FMAC4 soap_get__cwmp__GetParameterNamesResponse(struct soap *soap, struct _cwmp__GetParameterNamesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__cwmp__GetParameterNamesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__cwmp__GetParameterNames(struct soap *soap, struct _cwmp__GetParameterNames *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ParameterPath = NULL;
	soap_default_xsd__boolean(soap, &a->NextLevel);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__cwmp__GetParameterNames(struct soap *soap, const struct _cwmp__GetParameterNames *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostring(soap, &a->ParameterPath);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__cwmp__GetParameterNames(struct soap *soap, const char *tag, int id, const struct _cwmp__GetParameterNames *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__cwmp__GetParameterNames), type))
		return soap->error;
	if (!a->ParameterPath)
	{	if (soap_element_nil(soap, "ParameterPath"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostring(soap, "ParameterPath", -1, &a->ParameterPath, "xsd:string"))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "NextLevel", -1, &a->NextLevel, "xsd:boolean"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _cwmp__GetParameterNames * SOAP_FMAC4 soap_in__cwmp__GetParameterNames(struct soap *soap, const char *tag, struct _cwmp__GetParameterNames *a, const char *type)
{
	size_t soap_flag_ParameterPath = 1;
	size_t soap_flag_NextLevel = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _cwmp__GetParameterNames *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__cwmp__GetParameterNames, sizeof(struct _cwmp__GetParameterNames), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__cwmp__GetParameterNames(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ParameterPath && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, "ParameterPath", &a->ParameterPath, "xsd:string"))
				{	soap_flag_ParameterPath--;
					continue;
				}
			if (soap_flag_NextLevel && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "NextLevel", &a->NextLevel, "xsd:boolean"))
				{	soap_flag_NextLevel--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ParameterPath > 0 || soap_flag_NextLevel > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _cwmp__GetParameterNames *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__cwmp__GetParameterNames, SOAP_TYPE__cwmp__GetParameterNames, sizeof(struct _cwmp__GetParameterNames), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _cwmp__GetParameterNames * SOAP_FMAC4 soap_new__cwmp__GetParameterNames(struct soap *soap, int n)
{
	struct _cwmp__GetParameterNames *p;
	struct _cwmp__GetParameterNames *a = (struct _cwmp__GetParameterNames*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _cwmp__GetParameterNames));
	for (p = a; p && n--; p++)
		soap_default__cwmp__GetParameterNames(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__cwmp__GetParameterNames(struct soap *soap, const struct _cwmp__GetParameterNames *a, const char *tag, const char *type)
{
	if (soap_out__cwmp__GetParameterNames(soap, tag ? tag : "cwmp:GetParameterNames", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _cwmp__GetParameterNames * SOAP_FMAC4 soap_get__cwmp__GetParameterNames(struct soap *soap, struct _cwmp__GetParameterNames *p, const char *tag, const char *type)
{
	if ((p = soap_in__cwmp__GetParameterNames(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__cwmp__GetParameterValuesResponse(struct soap *soap, struct _cwmp__GetParameterValuesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ParameterList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__cwmp__GetParameterValuesResponse(struct soap *soap, const struct _cwmp__GetParameterValuesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToParameterValueList(soap, &a->ParameterList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__cwmp__GetParameterValuesResponse(struct soap *soap, const char *tag, int id, const struct _cwmp__GetParameterValuesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__cwmp__GetParameterValuesResponse), type))
		return soap->error;
	if (!a->ParameterList)
	{	if (soap_element_empty(soap, "ParameterList"))
			return soap->error;
	}
	else
	if (soap_out_PointerToParameterValueList(soap, "ParameterList", -1, &a->ParameterList, "cwmp:ParameterValueStruct"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _cwmp__GetParameterValuesResponse * SOAP_FMAC4 soap_in__cwmp__GetParameterValuesResponse(struct soap *soap, const char *tag, struct _cwmp__GetParameterValuesResponse *a, const char *type)
{
	size_t soap_flag_ParameterList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _cwmp__GetParameterValuesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__cwmp__GetParameterValuesResponse, sizeof(struct _cwmp__GetParameterValuesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__cwmp__GetParameterValuesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ParameterList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToParameterValueList(soap, "ParameterList", &a->ParameterList, "cwmp:ParameterValueStruct"))
				{	soap_flag_ParameterList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ParameterList))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _cwmp__GetParameterValuesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__cwmp__GetParameterValuesResponse, SOAP_TYPE__cwmp__GetParameterValuesResponse, sizeof(struct _cwmp__GetParameterValuesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _cwmp__GetParameterValuesResponse * SOAP_FMAC4 soap_new__cwmp__GetParameterValuesResponse(struct soap *soap, int n)
{
	struct _cwmp__GetParameterValuesResponse *p;
	struct _cwmp__GetParameterValuesResponse *a = (struct _cwmp__GetParameterValuesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _cwmp__GetParameterValuesResponse));
	for (p = a; p && n--; p++)
		soap_default__cwmp__GetParameterValuesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__cwmp__GetParameterValuesResponse(struct soap *soap, const struct _cwmp__GetParameterValuesResponse *a, const char *tag, const char *type)
{
	if (soap_out__cwmp__GetParameterValuesResponse(soap, tag ? tag : "cwmp:GetParameterValuesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _cwmp__GetParameterValuesResponse * SOAP_FMAC4 soap_get__cwmp__GetParameterValuesResponse(struct soap *soap, struct _cwmp__GetParameterValuesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__cwmp__GetParameterValuesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ParameterNames(struct soap *soap, struct ParameterNames *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__ptrstring = NULL;
	a->__size = 0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ParameterNames(struct soap *soap, const struct ParameterNames *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__ptrstring && !soap_array_reference(soap, a, a->__ptrstring, a->__size, SOAP_TYPE_ParameterNames))
	{	int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_string(soap, (char*const*)(a->__ptrstring + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ParameterNames(struct soap *soap, const char *tag, int id, const struct ParameterNames *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptrstring ? soap_putsizesoffsets(soap, "xsd:string", &a->__size, NULL, 1) : NULL;
	id = soap_element_id(soap, tag, id, a, a->__ptrstring, a->__size, type, SOAP_TYPE_ParameterNames, NULL);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_string(soap, "string", -1, (char*const*)&a->__ptrstring[i], "xsd:string");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ParameterNames * SOAP_FMAC4 soap_in_ParameterNames(struct soap *soap, const char *tag, struct ParameterNames *a, const char *type)
{	int i, j;
	char **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ParameterNames *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ParameterNames, sizeof(struct ParameterNames), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ParameterNames(soap, a);
	if (soap->body && !*soap->href)
	{
		if (*soap->arraySize)
		{
			soap_getsizes(soap->arraySize, &a->__size, 1);
			a->__size -= j = soap_getoffsets(soap->arrayOffset, &a->__size, NULL, 1);
			if ((size_t)a->__size > soap->maxoccurs)
			{	soap->error = SOAP_OCCURS;
				return NULL;
			}
			a->__ptrstring = (char **)soap_malloc(soap, sizeof(char *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptrstring[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_string(soap, NULL, (char**)(a->__ptrstring + i), "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_alloc_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (char **)soap_push_block(soap, NULL, sizeof(char *));
				if (!p)
					break;
				*p = NULL;
				if (!soap_in_string(soap, NULL, p, "xsd:string"))
				{	if (soap->error == SOAP_NO_TAG)
						soap->error = SOAP_OK;
					soap_pop_block(soap, NULL);
					break;
				}
				if ((size_t)a->__size > soap->maxoccurs)
				{	soap->error = SOAP_OCCURS;
					return NULL;
				}
			}
			a->__ptrstring = (char **)soap_save_block(soap, NULL, NULL, 1);
		}
		if (soap->error || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ParameterNames *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ParameterNames, SOAP_TYPE_ParameterNames, sizeof(struct ParameterNames), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ParameterNames * SOAP_FMAC4 soap_new_ParameterNames(struct soap *soap, int n)
{
	struct ParameterNames *p;
	struct ParameterNames *a = (struct ParameterNames*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ParameterNames));
	for (p = a; p && n--; p++)
		soap_default_ParameterNames(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ParameterNames(struct soap *soap, const struct ParameterNames *a, const char *tag, const char *type)
{
	if (soap_out_ParameterNames(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ParameterNames * SOAP_FMAC4 soap_get_ParameterNames(struct soap *soap, struct ParameterNames *p, const char *tag, const char *type)
{
	if ((p = soap_in_ParameterNames(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__cwmp__GetParameterValues(struct soap *soap, struct _cwmp__GetParameterValues *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ParameterNames = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__cwmp__GetParameterValues(struct soap *soap, const struct _cwmp__GetParameterValues *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToParameterNames(soap, &a->ParameterNames);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__cwmp__GetParameterValues(struct soap *soap, const char *tag, int id, const struct _cwmp__GetParameterValues *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__cwmp__GetParameterValues), type))
		return soap->error;
	if (!a->ParameterNames)
	{	if (soap_element_empty(soap, "ParameterNames"))
			return soap->error;
	}
	else
	if (soap_out_PointerToParameterNames(soap, "ParameterNames", -1, &a->ParameterNames, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _cwmp__GetParameterValues * SOAP_FMAC4 soap_in__cwmp__GetParameterValues(struct soap *soap, const char *tag, struct _cwmp__GetParameterValues *a, const char *type)
{
	size_t soap_flag_ParameterNames = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _cwmp__GetParameterValues *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__cwmp__GetParameterValues, sizeof(struct _cwmp__GetParameterValues), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__cwmp__GetParameterValues(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ParameterNames && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToParameterNames(soap, "ParameterNames", &a->ParameterNames, "xsd:string"))
				{	soap_flag_ParameterNames--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ParameterNames))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _cwmp__GetParameterValues *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__cwmp__GetParameterValues, SOAP_TYPE__cwmp__GetParameterValues, sizeof(struct _cwmp__GetParameterValues), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _cwmp__GetParameterValues * SOAP_FMAC4 soap_new__cwmp__GetParameterValues(struct soap *soap, int n)
{
	struct _cwmp__GetParameterValues *p;
	struct _cwmp__GetParameterValues *a = (struct _cwmp__GetParameterValues*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _cwmp__GetParameterValues));
	for (p = a; p && n--; p++)
		soap_default__cwmp__GetParameterValues(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__cwmp__GetParameterValues(struct soap *soap, const struct _cwmp__GetParameterValues *a, const char *tag, const char *type)
{
	if (soap_out__cwmp__GetParameterValues(soap, tag ? tag : "cwmp:GetParameterValues", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _cwmp__GetParameterValues * SOAP_FMAC4 soap_get__cwmp__GetParameterValues(struct soap *soap, struct _cwmp__GetParameterValues *p, const char *tag, const char *type)
{
	if ((p = soap_in__cwmp__GetParameterValues(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__cwmp__SetParameterValuesResponse(struct soap *soap, struct _cwmp__SetParameterValuesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__cwmp__SetParameterValuesResponse_Status(soap, &a->Status);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__cwmp__SetParameterValuesResponse(struct soap *soap, const struct _cwmp__SetParameterValuesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__cwmp__SetParameterValuesResponse(struct soap *soap, const char *tag, int id, const struct _cwmp__SetParameterValuesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__cwmp__SetParameterValuesResponse), type))
		return soap->error;
	if (soap_out__cwmp__SetParameterValuesResponse_Status(soap, "Status", -1, &a->Status, "cwmp:SetParameterValuesResponse-Status"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _cwmp__SetParameterValuesResponse * SOAP_FMAC4 soap_in__cwmp__SetParameterValuesResponse(struct soap *soap, const char *tag, struct _cwmp__SetParameterValuesResponse *a, const char *type)
{
	size_t soap_flag_Status = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _cwmp__SetParameterValuesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__cwmp__SetParameterValuesResponse, sizeof(struct _cwmp__SetParameterValuesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__cwmp__SetParameterValuesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__cwmp__SetParameterValuesResponse_Status(soap, "Status", &a->Status, "cwmp:SetParameterValuesResponse-Status"))
				{	soap_flag_Status--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Status > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _cwmp__SetParameterValuesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__cwmp__SetParameterValuesResponse, SOAP_TYPE__cwmp__SetParameterValuesResponse, sizeof(struct _cwmp__SetParameterValuesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _cwmp__SetParameterValuesResponse * SOAP_FMAC4 soap_new__cwmp__SetParameterValuesResponse(struct soap *soap, int n)
{
	struct _cwmp__SetParameterValuesResponse *p;
	struct _cwmp__SetParameterValuesResponse *a = (struct _cwmp__SetParameterValuesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _cwmp__SetParameterValuesResponse));
	for (p = a; p && n--; p++)
		soap_default__cwmp__SetParameterValuesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__cwmp__SetParameterValuesResponse(struct soap *soap, const struct _cwmp__SetParameterValuesResponse *a, const char *tag, const char *type)
{
	if (soap_out__cwmp__SetParameterValuesResponse(soap, tag ? tag : "cwmp:SetParameterValuesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _cwmp__SetParameterValuesResponse * SOAP_FMAC4 soap_get__cwmp__SetParameterValuesResponse(struct soap *soap, struct _cwmp__SetParameterValuesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__cwmp__SetParameterValuesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ParameterValueList(struct soap *soap, struct ParameterValueList *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__ptrParameterValueStruct = NULL;
	a->__size = 0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ParameterValueList(struct soap *soap, const struct ParameterValueList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__ptrParameterValueStruct && !soap_array_reference(soap, a, a->__ptrParameterValueStruct, a->__size, SOAP_TYPE_ParameterValueList))
	{	int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTocwmp__ParameterValueStruct(soap, a->__ptrParameterValueStruct + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ParameterValueList(struct soap *soap, const char *tag, int id, const struct ParameterValueList *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptrParameterValueStruct ? soap_putsizesoffsets(soap, "cwmp:ParameterValueStruct", &a->__size, NULL, 1) : NULL;
	id = soap_element_id(soap, tag, id, a, a->__ptrParameterValueStruct, a->__size, type, SOAP_TYPE_ParameterValueList, NULL);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTocwmp__ParameterValueStruct(soap, "ParameterValueStruct", -1, &a->__ptrParameterValueStruct[i], "cwmp:ParameterValueStruct");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ParameterValueList * SOAP_FMAC4 soap_in_ParameterValueList(struct soap *soap, const char *tag, struct ParameterValueList *a, const char *type)
{	int i, j;
	struct cwmp__ParameterValueStruct **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ParameterValueList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ParameterValueList, sizeof(struct ParameterValueList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ParameterValueList(soap, a);
	if (soap->body && !*soap->href)
	{
		if (*soap->arraySize)
		{
			soap_getsizes(soap->arraySize, &a->__size, 1);
			a->__size -= j = soap_getoffsets(soap->arrayOffset, &a->__size, NULL, 1);
			if ((size_t)a->__size > soap->maxoccurs)
			{	soap->error = SOAP_OCCURS;
				return NULL;
			}
			a->__ptrParameterValueStruct = (struct cwmp__ParameterValueStruct **)soap_malloc(soap, sizeof(struct cwmp__ParameterValueStruct *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptrParameterValueStruct[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTocwmp__ParameterValueStruct(soap, NULL, a->__ptrParameterValueStruct + i, "cwmp:ParameterValueStruct"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_alloc_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct cwmp__ParameterValueStruct **)soap_push_block(soap, NULL, sizeof(struct cwmp__ParameterValueStruct *));
				if (!p)
					break;
				*p = NULL;
				if (!soap_in_PointerTocwmp__ParameterValueStruct(soap, NULL, p, "cwmp:ParameterValueStruct"))
				{	if (soap->error == SOAP_NO_TAG)
						soap->error = SOAP_OK;
					soap_pop_block(soap, NULL);
					break;
				}
				if ((size_t)a->__size > soap->maxoccurs)
				{	soap->error = SOAP_OCCURS;
					return NULL;
				}
			}
			a->__ptrParameterValueStruct = (struct cwmp__ParameterValueStruct **)soap_save_block(soap, NULL, NULL, 1);
		}
		if (soap->error || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ParameterValueList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ParameterValueList, SOAP_TYPE_ParameterValueList, sizeof(struct ParameterValueList), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ParameterValueList * SOAP_FMAC4 soap_new_ParameterValueList(struct soap *soap, int n)
{
	struct ParameterValueList *p;
	struct ParameterValueList *a = (struct ParameterValueList*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ParameterValueList));
	for (p = a; p && n--; p++)
		soap_default_ParameterValueList(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ParameterValueList(struct soap *soap, const struct ParameterValueList *a, const char *tag, const char *type)
{
	if (soap_out_ParameterValueList(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ParameterValueList * SOAP_FMAC4 soap_get_ParameterValueList(struct soap *soap, struct ParameterValueList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ParameterValueList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__cwmp__SetParameterValues(struct soap *soap, struct _cwmp__SetParameterValues *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ParameterList = NULL;
	soap_default_cwmp__ParameterKeyType(soap, &a->ParameterKey);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__cwmp__SetParameterValues(struct soap *soap, const struct _cwmp__SetParameterValues *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToParameterValueList(soap, &a->ParameterList);
	soap_serialize_cwmp__ParameterKeyType(soap, (char*const*)&a->ParameterKey);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__cwmp__SetParameterValues(struct soap *soap, const char *tag, int id, const struct _cwmp__SetParameterValues *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__cwmp__SetParameterValues), type))
		return soap->error;
	if (!a->ParameterList)
	{	if (soap_element_empty(soap, "ParameterList"))
			return soap->error;
	}
	else
	if (soap_out_PointerToParameterValueList(soap, "ParameterList", -1, &a->ParameterList, "cwmp:ParameterValueStruct"))
		return soap->error;
	if (!a->ParameterKey)
	{	if (soap_element_empty(soap, "ParameterKey"))
			return soap->error;
	}
	else
	if (soap_out_cwmp__ParameterKeyType(soap, "ParameterKey", -1, (char*const*)&a->ParameterKey, "cwmp:ParameterKeyType"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _cwmp__SetParameterValues * SOAP_FMAC4 soap_in__cwmp__SetParameterValues(struct soap *soap, const char *tag, struct _cwmp__SetParameterValues *a, const char *type)
{
	size_t soap_flag_ParameterList = 1;
	size_t soap_flag_ParameterKey = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _cwmp__SetParameterValues *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__cwmp__SetParameterValues, sizeof(struct _cwmp__SetParameterValues), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__cwmp__SetParameterValues(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ParameterList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToParameterValueList(soap, "ParameterList", &a->ParameterList, "cwmp:ParameterValueStruct"))
				{	soap_flag_ParameterList--;
					continue;
				}
			if (soap_flag_ParameterKey && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_cwmp__ParameterKeyType(soap, "ParameterKey", (char**)&a->ParameterKey, "cwmp:ParameterKeyType"))
				{	soap_flag_ParameterKey--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ParameterList || !a->ParameterKey))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _cwmp__SetParameterValues *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__cwmp__SetParameterValues, SOAP_TYPE__cwmp__SetParameterValues, sizeof(struct _cwmp__SetParameterValues), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _cwmp__SetParameterValues * SOAP_FMAC4 soap_new__cwmp__SetParameterValues(struct soap *soap, int n)
{
	struct _cwmp__SetParameterValues *p;
	struct _cwmp__SetParameterValues *a = (struct _cwmp__SetParameterValues*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _cwmp__SetParameterValues));
	for (p = a; p && n--; p++)
		soap_default__cwmp__SetParameterValues(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__cwmp__SetParameterValues(struct soap *soap, const struct _cwmp__SetParameterValues *a, const char *tag, const char *type)
{
	if (soap_out__cwmp__SetParameterValues(soap, tag ? tag : "cwmp:SetParameterValues", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _cwmp__SetParameterValues * SOAP_FMAC4 soap_get__cwmp__SetParameterValues(struct soap *soap, struct _cwmp__SetParameterValues *p, const char *tag, const char *type)
{
	if ((p = soap_in__cwmp__SetParameterValues(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_MethodList(struct soap *soap, struct MethodList *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__ptrstring = NULL;
	a->__size = 0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_MethodList(struct soap *soap, const struct MethodList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__ptrstring && !soap_array_reference(soap, a, a->__ptrstring, a->__size, SOAP_TYPE_MethodList))
	{	int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_string(soap, (char*const*)(a->__ptrstring + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_MethodList(struct soap *soap, const char *tag, int id, const struct MethodList *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptrstring ? soap_putsizesoffsets(soap, "xsd:string", &a->__size, NULL, 1) : NULL;
	id = soap_element_id(soap, tag, id, a, a->__ptrstring, a->__size, type, SOAP_TYPE_MethodList, NULL);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_string(soap, "string", -1, (char*const*)&a->__ptrstring[i], "xsd:string");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct MethodList * SOAP_FMAC4 soap_in_MethodList(struct soap *soap, const char *tag, struct MethodList *a, const char *type)
{	int i, j;
	char **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct MethodList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_MethodList, sizeof(struct MethodList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_MethodList(soap, a);
	if (soap->body && !*soap->href)
	{
		if (*soap->arraySize)
		{
			soap_getsizes(soap->arraySize, &a->__size, 1);
			a->__size -= j = soap_getoffsets(soap->arrayOffset, &a->__size, NULL, 1);
			if ((size_t)a->__size > soap->maxoccurs)
			{	soap->error = SOAP_OCCURS;
				return NULL;
			}
			a->__ptrstring = (char **)soap_malloc(soap, sizeof(char *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptrstring[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_string(soap, NULL, (char**)(a->__ptrstring + i), "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_alloc_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (char **)soap_push_block(soap, NULL, sizeof(char *));
				if (!p)
					break;
				*p = NULL;
				if (!soap_in_string(soap, NULL, p, "xsd:string"))
				{	if (soap->error == SOAP_NO_TAG)
						soap->error = SOAP_OK;
					soap_pop_block(soap, NULL);
					break;
				}
				if ((size_t)a->__size > soap->maxoccurs)
				{	soap->error = SOAP_OCCURS;
					return NULL;
				}
			}
			a->__ptrstring = (char **)soap_save_block(soap, NULL, NULL, 1);
		}
		if (soap->error || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct MethodList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_MethodList, SOAP_TYPE_MethodList, sizeof(struct MethodList), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct MethodList * SOAP_FMAC4 soap_new_MethodList(struct soap *soap, int n)
{
	struct MethodList *p;
	struct MethodList *a = (struct MethodList*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct MethodList));
	for (p = a; p && n--; p++)
		soap_default_MethodList(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_MethodList(struct soap *soap, const struct MethodList *a, const char *tag, const char *type)
{
	if (soap_out_MethodList(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct MethodList * SOAP_FMAC4 soap_get_MethodList(struct soap *soap, struct MethodList *p, const char *tag, const char *type)
{
	if ((p = soap_in_MethodList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__cwmp__GetRPCMethodsResponse(struct soap *soap, struct _cwmp__GetRPCMethodsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MethodList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__cwmp__GetRPCMethodsResponse(struct soap *soap, const struct _cwmp__GetRPCMethodsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToMethodList(soap, &a->MethodList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__cwmp__GetRPCMethodsResponse(struct soap *soap, const char *tag, int id, const struct _cwmp__GetRPCMethodsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__cwmp__GetRPCMethodsResponse), type))
		return soap->error;
	if (!a->MethodList)
	{	if (soap_element_empty(soap, "MethodList"))
			return soap->error;
	}
	else
	if (soap_out_PointerToMethodList(soap, "MethodList", -1, &a->MethodList, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _cwmp__GetRPCMethodsResponse * SOAP_FMAC4 soap_in__cwmp__GetRPCMethodsResponse(struct soap *soap, const char *tag, struct _cwmp__GetRPCMethodsResponse *a, const char *type)
{
	size_t soap_flag_MethodList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _cwmp__GetRPCMethodsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__cwmp__GetRPCMethodsResponse, sizeof(struct _cwmp__GetRPCMethodsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__cwmp__GetRPCMethodsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MethodList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToMethodList(soap, "MethodList", &a->MethodList, "xsd:string"))
				{	soap_flag_MethodList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->MethodList))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _cwmp__GetRPCMethodsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__cwmp__GetRPCMethodsResponse, SOAP_TYPE__cwmp__GetRPCMethodsResponse, sizeof(struct _cwmp__GetRPCMethodsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _cwmp__GetRPCMethodsResponse * SOAP_FMAC4 soap_new__cwmp__GetRPCMethodsResponse(struct soap *soap, int n)
{
	struct _cwmp__GetRPCMethodsResponse *p;
	struct _cwmp__GetRPCMethodsResponse *a = (struct _cwmp__GetRPCMethodsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _cwmp__GetRPCMethodsResponse));
	for (p = a; p && n--; p++)
		soap_default__cwmp__GetRPCMethodsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__cwmp__GetRPCMethodsResponse(struct soap *soap, const struct _cwmp__GetRPCMethodsResponse *a, const char *tag, const char *type)
{
	if (soap_out__cwmp__GetRPCMethodsResponse(soap, tag ? tag : "cwmp:GetRPCMethodsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _cwmp__GetRPCMethodsResponse * SOAP_FMAC4 soap_get__cwmp__GetRPCMethodsResponse(struct soap *soap, struct _cwmp__GetRPCMethodsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__cwmp__GetRPCMethodsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__cwmp__GetRPCMethods(struct soap *soap, struct _cwmp__GetRPCMethods *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__cwmp__GetRPCMethods(struct soap *soap, const struct _cwmp__GetRPCMethods *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__cwmp__GetRPCMethods(struct soap *soap, const char *tag, int id, const struct _cwmp__GetRPCMethods *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__cwmp__GetRPCMethods), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _cwmp__GetRPCMethods * SOAP_FMAC4 soap_in__cwmp__GetRPCMethods(struct soap *soap, const char *tag, struct _cwmp__GetRPCMethods *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _cwmp__GetRPCMethods *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__cwmp__GetRPCMethods, sizeof(struct _cwmp__GetRPCMethods), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__cwmp__GetRPCMethods(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _cwmp__GetRPCMethods *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__cwmp__GetRPCMethods, SOAP_TYPE__cwmp__GetRPCMethods, sizeof(struct _cwmp__GetRPCMethods), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _cwmp__GetRPCMethods * SOAP_FMAC4 soap_new__cwmp__GetRPCMethods(struct soap *soap, int n)
{
	struct _cwmp__GetRPCMethods *p;
	struct _cwmp__GetRPCMethods *a = (struct _cwmp__GetRPCMethods*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _cwmp__GetRPCMethods));
	for (p = a; p && n--; p++)
		soap_default__cwmp__GetRPCMethods(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__cwmp__GetRPCMethods(struct soap *soap, const struct _cwmp__GetRPCMethods *a, const char *tag, const char *type)
{
	if (soap_out__cwmp__GetRPCMethods(soap, tag ? tag : "cwmp:GetRPCMethods", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _cwmp__GetRPCMethods * SOAP_FMAC4 soap_get__cwmp__GetRPCMethods(struct soap *soap, struct _cwmp__GetRPCMethods *p, const char *tag, const char *type)
{
	if ((p = soap_in__cwmp__GetRPCMethods(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__cwmp__Fault_SetParameterValuesFault(struct soap *soap, struct _cwmp__Fault_SetParameterValuesFault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->ParameterName);
	soap_default_cwmp__FaultCodeType(soap, &a->FaultCode);
	soap_default_string(soap, &a->FaultString);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__cwmp__Fault_SetParameterValuesFault(struct soap *soap, const struct _cwmp__Fault_SetParameterValuesFault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->ParameterName);
	soap_serialize_cwmp__FaultCodeType(soap, (char*const*)&a->FaultCode);
	soap_serialize_string(soap, (char*const*)&a->FaultString);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__cwmp__Fault_SetParameterValuesFault(struct soap *soap, const char *tag, int id, const struct _cwmp__Fault_SetParameterValuesFault *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__cwmp__Fault_SetParameterValuesFault), type))
		return soap->error;
	if (!a->ParameterName)
	{	if (soap_element_empty(soap, "ParameterName"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ParameterName", -1, (char*const*)&a->ParameterName, "xsd:string"))
		return soap->error;
	if (!a->FaultCode)
	{	if (soap_element_empty(soap, "FaultCode"))
			return soap->error;
	}
	else
	if (soap_out_cwmp__FaultCodeType(soap, "FaultCode", -1, (char*const*)&a->FaultCode, "cwmp:FaultCodeType"))
		return soap->error;
	if (soap_out_string(soap, "FaultString", -1, (char*const*)&a->FaultString, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _cwmp__Fault_SetParameterValuesFault * SOAP_FMAC4 soap_in__cwmp__Fault_SetParameterValuesFault(struct soap *soap, const char *tag, struct _cwmp__Fault_SetParameterValuesFault *a, const char *type)
{
	size_t soap_flag_ParameterName = 1;
	size_t soap_flag_FaultCode = 1;
	size_t soap_flag_FaultString = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _cwmp__Fault_SetParameterValuesFault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__cwmp__Fault_SetParameterValuesFault, sizeof(struct _cwmp__Fault_SetParameterValuesFault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__cwmp__Fault_SetParameterValuesFault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ParameterName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ParameterName", (char**)&a->ParameterName, "xsd:string"))
				{	soap_flag_ParameterName--;
					continue;
				}
			if (soap_flag_FaultCode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_cwmp__FaultCodeType(soap, "FaultCode", (char**)&a->FaultCode, "cwmp:FaultCodeType"))
				{	soap_flag_FaultCode--;
					continue;
				}
			if (soap_flag_FaultString && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "FaultString", (char**)&a->FaultString, "xsd:string"))
				{	soap_flag_FaultString--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->ParameterName || !a->FaultCode))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _cwmp__Fault_SetParameterValuesFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__cwmp__Fault_SetParameterValuesFault, SOAP_TYPE__cwmp__Fault_SetParameterValuesFault, sizeof(struct _cwmp__Fault_SetParameterValuesFault), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _cwmp__Fault_SetParameterValuesFault * SOAP_FMAC4 soap_new__cwmp__Fault_SetParameterValuesFault(struct soap *soap, int n)
{
	struct _cwmp__Fault_SetParameterValuesFault *p;
	struct _cwmp__Fault_SetParameterValuesFault *a = (struct _cwmp__Fault_SetParameterValuesFault*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _cwmp__Fault_SetParameterValuesFault));
	for (p = a; p && n--; p++)
		soap_default__cwmp__Fault_SetParameterValuesFault(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__cwmp__Fault_SetParameterValuesFault(struct soap *soap, const struct _cwmp__Fault_SetParameterValuesFault *a, const char *tag, const char *type)
{
	if (soap_out__cwmp__Fault_SetParameterValuesFault(soap, tag ? tag : "cwmp:Fault-SetParameterValuesFault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _cwmp__Fault_SetParameterValuesFault * SOAP_FMAC4 soap_get__cwmp__Fault_SetParameterValuesFault(struct soap *soap, struct _cwmp__Fault_SetParameterValuesFault *p, const char *tag, const char *type)
{
	if ((p = soap_in__cwmp__Fault_SetParameterValuesFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__cwmp__Fault(struct soap *soap, struct _cwmp__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_cwmp__FaultCodeType(soap, &a->FaultCode);
	soap_default_string(soap, &a->FaultString);
	a->__sizeSetParameterValuesFault = 0;
	a->SetParameterValuesFault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__cwmp__Fault(struct soap *soap, const struct _cwmp__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_cwmp__FaultCodeType(soap, (char*const*)&a->FaultCode);
	soap_serialize_string(soap, (char*const*)&a->FaultString);
	if (a->SetParameterValuesFault)
	{	int i;
		for (i = 0; i < (int)a->__sizeSetParameterValuesFault; i++)
		{
			soap_embedded(soap, a->SetParameterValuesFault + i, SOAP_TYPE__cwmp__Fault_SetParameterValuesFault);
			soap_serialize__cwmp__Fault_SetParameterValuesFault(soap, a->SetParameterValuesFault + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__cwmp__Fault(struct soap *soap, const char *tag, int id, const struct _cwmp__Fault *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__cwmp__Fault), type))
		return soap->error;
	if (!a->FaultCode)
	{	if (soap_element_empty(soap, "FaultCode"))
			return soap->error;
	}
	else
	if (soap_out_cwmp__FaultCodeType(soap, "FaultCode", -1, (char*const*)&a->FaultCode, "cwmp:FaultCodeType"))
		return soap->error;
	if (soap_out_string(soap, "FaultString", -1, (char*const*)&a->FaultString, "xsd:string"))
		return soap->error;
	if (a->SetParameterValuesFault)
	{	int i;
		for (i = 0; i < (int)a->__sizeSetParameterValuesFault; i++)
			if (soap_out__cwmp__Fault_SetParameterValuesFault(soap, "SetParameterValuesFault", -1, a->SetParameterValuesFault + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _cwmp__Fault * SOAP_FMAC4 soap_in__cwmp__Fault(struct soap *soap, const char *tag, struct _cwmp__Fault *a, const char *type)
{
	size_t soap_flag_FaultCode = 1;
	size_t soap_flag_FaultString = 1;
	struct soap_blist *soap_blist_SetParameterValuesFault = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _cwmp__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__cwmp__Fault, sizeof(struct _cwmp__Fault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__cwmp__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FaultCode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_cwmp__FaultCodeType(soap, "FaultCode", (char**)&a->FaultCode, "cwmp:FaultCodeType"))
				{	soap_flag_FaultCode--;
					continue;
				}
			if (soap_flag_FaultString && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "FaultString", (char**)&a->FaultString, "xsd:string"))
				{	soap_flag_FaultString--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "SetParameterValuesFault", 1, NULL))
			{	if (a->SetParameterValuesFault == NULL)
				{	if (soap_blist_SetParameterValuesFault == NULL)
						soap_blist_SetParameterValuesFault = soap_alloc_block(soap);
					a->SetParameterValuesFault = (struct _cwmp__Fault_SetParameterValuesFault *)soap_push_block_max(soap, soap_blist_SetParameterValuesFault, sizeof(struct _cwmp__Fault_SetParameterValuesFault));
					if (a->SetParameterValuesFault == NULL)
						return NULL;
					soap_default__cwmp__Fault_SetParameterValuesFault(soap, a->SetParameterValuesFault);
				}
				soap_revert(soap);
				if (soap_in__cwmp__Fault_SetParameterValuesFault(soap, "SetParameterValuesFault", a->SetParameterValuesFault, ""))
				{	a->__sizeSetParameterValuesFault++;
					a->SetParameterValuesFault = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->SetParameterValuesFault)
			soap_pop_block(soap, soap_blist_SetParameterValuesFault);
		if (a->__sizeSetParameterValuesFault)
		{	a->SetParameterValuesFault = (struct _cwmp__Fault_SetParameterValuesFault *)soap_save_block(soap, soap_blist_SetParameterValuesFault, NULL, 1);
		}
		else
		{	a->SetParameterValuesFault = NULL;
			if (soap_blist_SetParameterValuesFault)
				soap_end_block(soap, soap_blist_SetParameterValuesFault);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->FaultCode))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _cwmp__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__cwmp__Fault, SOAP_TYPE__cwmp__Fault, sizeof(struct _cwmp__Fault), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _cwmp__Fault * SOAP_FMAC4 soap_new__cwmp__Fault(struct soap *soap, int n)
{
	struct _cwmp__Fault *p;
	struct _cwmp__Fault *a = (struct _cwmp__Fault*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _cwmp__Fault));
	for (p = a; p && n--; p++)
		soap_default__cwmp__Fault(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__cwmp__Fault(struct soap *soap, const struct _cwmp__Fault *a, const char *tag, const char *type)
{
	if (soap_out__cwmp__Fault(soap, tag ? tag : "cwmp:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _cwmp__Fault * SOAP_FMAC4 soap_get__cwmp__Fault(struct soap *soap, struct _cwmp__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in__cwmp__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_cwmp__ArgStruct(struct soap *soap, struct cwmp__ArgStruct *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Name);
	soap_default_string(soap, &a->Value);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_cwmp__ArgStruct(struct soap *soap, const struct cwmp__ArgStruct *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Name);
	soap_serialize_string(soap, (char*const*)&a->Value);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_cwmp__ArgStruct(struct soap *soap, const char *tag, int id, const struct cwmp__ArgStruct *a, const char *type)
{
	if (!type)
		type = "cwmp:ArgStruct";
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cwmp__ArgStruct), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_empty(soap, "Name"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "Name", -1, (char*const*)&a->Name, "xsd:string"))
		return soap->error;
	if (!a->Value)
	{	if (soap_element_empty(soap, "Value"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "Value", -1, (char*const*)&a->Value, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct cwmp__ArgStruct * SOAP_FMAC4 soap_in_cwmp__ArgStruct(struct soap *soap, const char *tag, struct cwmp__ArgStruct *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_Value = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct cwmp__ArgStruct *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cwmp__ArgStruct, sizeof(struct cwmp__ArgStruct), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_cwmp__ArgStruct(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Name", (char**)&a->Name, "xsd:string"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Value", (char**)&a->Value, "xsd:string"))
				{	soap_flag_Value--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Name || !a->Value))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct cwmp__ArgStruct *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_cwmp__ArgStruct, SOAP_TYPE_cwmp__ArgStruct, sizeof(struct cwmp__ArgStruct), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct cwmp__ArgStruct * SOAP_FMAC4 soap_new_cwmp__ArgStruct(struct soap *soap, int n)
{
	struct cwmp__ArgStruct *p;
	struct cwmp__ArgStruct *a = (struct cwmp__ArgStruct*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct cwmp__ArgStruct));
	for (p = a; p && n--; p++)
		soap_default_cwmp__ArgStruct(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_cwmp__ArgStruct(struct soap *soap, const struct cwmp__ArgStruct *a, const char *tag, const char *type)
{
	if (soap_out_cwmp__ArgStruct(soap, tag ? tag : "cwmp:ArgStruct", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct cwmp__ArgStruct * SOAP_FMAC4 soap_get_cwmp__ArgStruct(struct soap *soap, struct cwmp__ArgStruct *p, const char *tag, const char *type)
{
	if ((p = soap_in_cwmp__ArgStruct(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_cwmp__OptionStruct(struct soap *soap, struct cwmp__OptionStruct *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->OptionName);
	soap_default_unsignedInt(soap, &a->VoucherSN);
	soap_default__cwmp__OptionStruct_State(soap, &a->State);
	soap_default__cwmp__OptionStruct_Mode(soap, &a->Mode);
	soap_default_dateTime(soap, &a->StartDate);
	a->ExpirationDate = NULL;
	soap_default__cwmp__OptionStruct_IsTransferable(soap, &a->IsTransferable);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_cwmp__OptionStruct(struct soap *soap, const struct cwmp__OptionStruct *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->OptionName);
	soap_embedded(soap, &a->StartDate, SOAP_TYPE_dateTime);
	soap_serialize_PointerTodateTime(soap, &a->ExpirationDate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_cwmp__OptionStruct(struct soap *soap, const char *tag, int id, const struct cwmp__OptionStruct *a, const char *type)
{
	if (!type)
		type = "cwmp:OptionStruct";
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cwmp__OptionStruct), type))
		return soap->error;
	if (!a->OptionName)
	{	if (soap_element_empty(soap, "OptionName"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "OptionName", -1, (char*const*)&a->OptionName, "xsd:string"))
		return soap->error;
	if (soap_out_unsignedInt(soap, "VoucherSN", -1, &a->VoucherSN, "xsd:unsignedInt"))
		return soap->error;
	if (soap_out__cwmp__OptionStruct_State(soap, "State", -1, &a->State, "cwmp:OptionStruct-State"))
		return soap->error;
	if (soap_out__cwmp__OptionStruct_Mode(soap, "Mode", -1, &a->Mode, "cwmp:OptionStruct-Mode"))
		return soap->error;
	if (soap_out_dateTime(soap, "StartDate", -1, &a->StartDate, "xsd:dateTime"))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "ExpirationDate", -1, &a->ExpirationDate, "xsd:dateTime"))
		return soap->error;
	if (soap_out__cwmp__OptionStruct_IsTransferable(soap, "IsTransferable", -1, &a->IsTransferable, "cwmp:OptionStruct-IsTransferable"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct cwmp__OptionStruct * SOAP_FMAC4 soap_in_cwmp__OptionStruct(struct soap *soap, const char *tag, struct cwmp__OptionStruct *a, const char *type)
{
	size_t soap_flag_OptionName = 1;
	size_t soap_flag_VoucherSN = 1;
	size_t soap_flag_State = 1;
	size_t soap_flag_Mode = 1;
	size_t soap_flag_StartDate = 1;
	size_t soap_flag_ExpirationDate = 1;
	size_t soap_flag_IsTransferable = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct cwmp__OptionStruct *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cwmp__OptionStruct, sizeof(struct cwmp__OptionStruct), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_cwmp__OptionStruct(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OptionName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "OptionName", (char**)&a->OptionName, "xsd:string"))
				{	soap_flag_OptionName--;
					continue;
				}
			if (soap_flag_VoucherSN && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "VoucherSN", &a->VoucherSN, "xsd:unsignedInt"))
				{	soap_flag_VoucherSN--;
					continue;
				}
			if (soap_flag_State && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__cwmp__OptionStruct_State(soap, "State", &a->State, "cwmp:OptionStruct-State"))
				{	soap_flag_State--;
					continue;
				}
			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__cwmp__OptionStruct_Mode(soap, "Mode", &a->Mode, "cwmp:OptionStruct-Mode"))
				{	soap_flag_Mode--;
					continue;
				}
			if (soap_flag_StartDate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_dateTime(soap, "StartDate", &a->StartDate, "xsd:dateTime"))
				{	soap_flag_StartDate--;
					continue;
				}
			if (soap_flag_ExpirationDate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodateTime(soap, "ExpirationDate", &a->ExpirationDate, "xsd:dateTime"))
				{	soap_flag_ExpirationDate--;
					continue;
				}
			if (soap_flag_IsTransferable && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__cwmp__OptionStruct_IsTransferable(soap, "IsTransferable", &a->IsTransferable, "cwmp:OptionStruct-IsTransferable"))
				{	soap_flag_IsTransferable--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->OptionName || soap_flag_VoucherSN > 0 || soap_flag_State > 0 || soap_flag_Mode > 0 || soap_flag_StartDate > 0 || soap_flag_IsTransferable > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct cwmp__OptionStruct *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_cwmp__OptionStruct, SOAP_TYPE_cwmp__OptionStruct, sizeof(struct cwmp__OptionStruct), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct cwmp__OptionStruct * SOAP_FMAC4 soap_new_cwmp__OptionStruct(struct soap *soap, int n)
{
	struct cwmp__OptionStruct *p;
	struct cwmp__OptionStruct *a = (struct cwmp__OptionStruct*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct cwmp__OptionStruct));
	for (p = a; p && n--; p++)
		soap_default_cwmp__OptionStruct(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_cwmp__OptionStruct(struct soap *soap, const struct cwmp__OptionStruct *a, const char *tag, const char *type)
{
	if (soap_out_cwmp__OptionStruct(soap, tag ? tag : "cwmp:OptionStruct", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct cwmp__OptionStruct * SOAP_FMAC4 soap_get_cwmp__OptionStruct(struct soap *soap, struct cwmp__OptionStruct *p, const char *tag, const char *type)
{
	if ((p = soap_in_cwmp__OptionStruct(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_cwmp__QueuedTransferStruct(struct soap *soap, struct cwmp__QueuedTransferStruct *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_cwmp__CommandKeyType(soap, &a->CommandKey);
	soap_default__cwmp__QueuedTransferStruct_State(soap, &a->State);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_cwmp__QueuedTransferStruct(struct soap *soap, const struct cwmp__QueuedTransferStruct *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_cwmp__CommandKeyType(soap, (char*const*)&a->CommandKey);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_cwmp__QueuedTransferStruct(struct soap *soap, const char *tag, int id, const struct cwmp__QueuedTransferStruct *a, const char *type)
{
	if (!type)
		type = "cwmp:QueuedTransferStruct";
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cwmp__QueuedTransferStruct), type))
		return soap->error;
	if (!a->CommandKey)
	{	if (soap_element_empty(soap, "CommandKey"))
			return soap->error;
	}
	else
	if (soap_out_cwmp__CommandKeyType(soap, "CommandKey", -1, (char*const*)&a->CommandKey, "cwmp:CommandKeyType"))
		return soap->error;
	if (soap_out__cwmp__QueuedTransferStruct_State(soap, "State", -1, &a->State, "cwmp:QueuedTransferStruct-State"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct cwmp__QueuedTransferStruct * SOAP_FMAC4 soap_in_cwmp__QueuedTransferStruct(struct soap *soap, const char *tag, struct cwmp__QueuedTransferStruct *a, const char *type)
{
	size_t soap_flag_CommandKey = 1;
	size_t soap_flag_State = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct cwmp__QueuedTransferStruct *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cwmp__QueuedTransferStruct, sizeof(struct cwmp__QueuedTransferStruct), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_cwmp__QueuedTransferStruct(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CommandKey && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_cwmp__CommandKeyType(soap, "CommandKey", (char**)&a->CommandKey, "cwmp:CommandKeyType"))
				{	soap_flag_CommandKey--;
					continue;
				}
			if (soap_flag_State && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__cwmp__QueuedTransferStruct_State(soap, "State", &a->State, "cwmp:QueuedTransferStruct-State"))
				{	soap_flag_State--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->CommandKey || soap_flag_State > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct cwmp__QueuedTransferStruct *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_cwmp__QueuedTransferStruct, SOAP_TYPE_cwmp__QueuedTransferStruct, sizeof(struct cwmp__QueuedTransferStruct), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct cwmp__QueuedTransferStruct * SOAP_FMAC4 soap_new_cwmp__QueuedTransferStruct(struct soap *soap, int n)
{
	struct cwmp__QueuedTransferStruct *p;
	struct cwmp__QueuedTransferStruct *a = (struct cwmp__QueuedTransferStruct*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct cwmp__QueuedTransferStruct));
	for (p = a; p && n--; p++)
		soap_default_cwmp__QueuedTransferStruct(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_cwmp__QueuedTransferStruct(struct soap *soap, const struct cwmp__QueuedTransferStruct *a, const char *tag, const char *type)
{
	if (soap_out_cwmp__QueuedTransferStruct(soap, tag ? tag : "cwmp:QueuedTransferStruct", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct cwmp__QueuedTransferStruct * SOAP_FMAC4 soap_get_cwmp__QueuedTransferStruct(struct soap *soap, struct cwmp__QueuedTransferStruct *p, const char *tag, const char *type)
{
	if ((p = soap_in_cwmp__QueuedTransferStruct(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_cwmp__ParameterAttributeStruct(struct soap *soap, struct cwmp__ParameterAttributeStruct *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Name);
	soap_default__cwmp__ParameterAttributeStruct_Notification(soap, &a->Notification);
	a->AccessList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_cwmp__ParameterAttributeStruct(struct soap *soap, const struct cwmp__ParameterAttributeStruct *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Name);
	soap_serialize_PointerToAccessList(soap, &a->AccessList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_cwmp__ParameterAttributeStruct(struct soap *soap, const char *tag, int id, const struct cwmp__ParameterAttributeStruct *a, const char *type)
{
	if (!type)
		type = "cwmp:ParameterAttributeStruct";
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cwmp__ParameterAttributeStruct), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_empty(soap, "Name"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "Name", -1, (char*const*)&a->Name, "xsd:string"))
		return soap->error;
	if (soap_out__cwmp__ParameterAttributeStruct_Notification(soap, "Notification", -1, &a->Notification, "cwmp:ParameterAttributeStruct-Notification"))
		return soap->error;
	if (!a->AccessList)
	{	if (soap_element_empty(soap, "AccessList"))
			return soap->error;
	}
	else
	if (soap_out_PointerToAccessList(soap, "AccessList", -1, &a->AccessList, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct cwmp__ParameterAttributeStruct * SOAP_FMAC4 soap_in_cwmp__ParameterAttributeStruct(struct soap *soap, const char *tag, struct cwmp__ParameterAttributeStruct *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_Notification = 1;
	size_t soap_flag_AccessList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct cwmp__ParameterAttributeStruct *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cwmp__ParameterAttributeStruct, sizeof(struct cwmp__ParameterAttributeStruct), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_cwmp__ParameterAttributeStruct(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Name", (char**)&a->Name, "xsd:string"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_Notification && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__cwmp__ParameterAttributeStruct_Notification(soap, "Notification", &a->Notification, "cwmp:ParameterAttributeStruct-Notification"))
				{	soap_flag_Notification--;
					continue;
				}
			if (soap_flag_AccessList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToAccessList(soap, "AccessList", &a->AccessList, "xsd:string"))
				{	soap_flag_AccessList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Name || soap_flag_Notification > 0 || !a->AccessList))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct cwmp__ParameterAttributeStruct *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_cwmp__ParameterAttributeStruct, SOAP_TYPE_cwmp__ParameterAttributeStruct, sizeof(struct cwmp__ParameterAttributeStruct), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct cwmp__ParameterAttributeStruct * SOAP_FMAC4 soap_new_cwmp__ParameterAttributeStruct(struct soap *soap, int n)
{
	struct cwmp__ParameterAttributeStruct *p;
	struct cwmp__ParameterAttributeStruct *a = (struct cwmp__ParameterAttributeStruct*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct cwmp__ParameterAttributeStruct));
	for (p = a; p && n--; p++)
		soap_default_cwmp__ParameterAttributeStruct(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_cwmp__ParameterAttributeStruct(struct soap *soap, const struct cwmp__ParameterAttributeStruct *a, const char *tag, const char *type)
{
	if (soap_out_cwmp__ParameterAttributeStruct(soap, tag ? tag : "cwmp:ParameterAttributeStruct", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct cwmp__ParameterAttributeStruct * SOAP_FMAC4 soap_get_cwmp__ParameterAttributeStruct(struct soap *soap, struct cwmp__ParameterAttributeStruct *p, const char *tag, const char *type)
{
	if ((p = soap_in_cwmp__ParameterAttributeStruct(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_AccessList(struct soap *soap, struct AccessList *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__ptrstring = NULL;
	a->__size = 0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_AccessList(struct soap *soap, const struct AccessList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__ptrstring && !soap_array_reference(soap, a, a->__ptrstring, a->__size, SOAP_TYPE_AccessList))
	{	int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_string(soap, (char*const*)(a->__ptrstring + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_AccessList(struct soap *soap, const char *tag, int id, const struct AccessList *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptrstring ? soap_putsizesoffsets(soap, "xsd:string", &a->__size, NULL, 1) : NULL;
	id = soap_element_id(soap, tag, id, a, a->__ptrstring, a->__size, type, SOAP_TYPE_AccessList, NULL);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_string(soap, "string", -1, (char*const*)&a->__ptrstring[i], "xsd:string");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct AccessList * SOAP_FMAC4 soap_in_AccessList(struct soap *soap, const char *tag, struct AccessList *a, const char *type)
{	int i, j;
	char **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct AccessList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_AccessList, sizeof(struct AccessList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_AccessList(soap, a);
	if (soap->body && !*soap->href)
	{
		if (*soap->arraySize)
		{
			soap_getsizes(soap->arraySize, &a->__size, 1);
			a->__size -= j = soap_getoffsets(soap->arrayOffset, &a->__size, NULL, 1);
			if ((size_t)a->__size > soap->maxoccurs)
			{	soap->error = SOAP_OCCURS;
				return NULL;
			}
			a->__ptrstring = (char **)soap_malloc(soap, sizeof(char *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptrstring[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_string(soap, NULL, (char**)(a->__ptrstring + i), "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_alloc_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (char **)soap_push_block(soap, NULL, sizeof(char *));
				if (!p)
					break;
				*p = NULL;
				if (!soap_in_string(soap, NULL, p, "xsd:string"))
				{	if (soap->error == SOAP_NO_TAG)
						soap->error = SOAP_OK;
					soap_pop_block(soap, NULL);
					break;
				}
				if ((size_t)a->__size > soap->maxoccurs)
				{	soap->error = SOAP_OCCURS;
					return NULL;
				}
			}
			a->__ptrstring = (char **)soap_save_block(soap, NULL, NULL, 1);
		}
		if (soap->error || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct AccessList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_AccessList, SOAP_TYPE_AccessList, sizeof(struct AccessList), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct AccessList * SOAP_FMAC4 soap_new_AccessList(struct soap *soap, int n)
{
	struct AccessList *p;
	struct AccessList *a = (struct AccessList*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct AccessList));
	for (p = a; p && n--; p++)
		soap_default_AccessList(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_AccessList(struct soap *soap, const struct AccessList *a, const char *tag, const char *type)
{
	if (soap_out_AccessList(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct AccessList * SOAP_FMAC4 soap_get_AccessList(struct soap *soap, struct AccessList *p, const char *tag, const char *type)
{
	if ((p = soap_in_AccessList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_cwmp__SetParameterAttributesStruct(struct soap *soap, struct cwmp__SetParameterAttributesStruct *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Name = NULL;
	soap_default_xsd__boolean(soap, &a->NotificationChange);
	soap_default__cwmp__SetParameterAttributesStruct_Notification(soap, &a->Notification);
	soap_default_xsd__boolean(soap, &a->AccessListChange);
	a->AccessList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_cwmp__SetParameterAttributesStruct(struct soap *soap, const struct cwmp__SetParameterAttributesStruct *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostring(soap, &a->Name);
	soap_serialize_PointerToAccessList(soap, &a->AccessList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_cwmp__SetParameterAttributesStruct(struct soap *soap, const char *tag, int id, const struct cwmp__SetParameterAttributesStruct *a, const char *type)
{
	if (!type)
		type = "cwmp:SetParameterAttributesStruct";
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cwmp__SetParameterAttributesStruct), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_nil(soap, "Name"))
			return soap->error;
	}
	else
	if (soap_out_PointerTostring(soap, "Name", -1, &a->Name, "xsd:string"))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "NotificationChange", -1, &a->NotificationChange, "xsd:boolean"))
		return soap->error;
	if (soap_out__cwmp__SetParameterAttributesStruct_Notification(soap, "Notification", -1, &a->Notification, "cwmp:SetParameterAttributesStruct-Notification"))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "AccessListChange", -1, &a->AccessListChange, "xsd:boolean"))
		return soap->error;
	if (!a->AccessList)
	{	if (soap_element_empty(soap, "AccessList"))
			return soap->error;
	}
	else
	if (soap_out_PointerToAccessList(soap, "AccessList", -1, &a->AccessList, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct cwmp__SetParameterAttributesStruct * SOAP_FMAC4 soap_in_cwmp__SetParameterAttributesStruct(struct soap *soap, const char *tag, struct cwmp__SetParameterAttributesStruct *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_NotificationChange = 1;
	size_t soap_flag_Notification = 1;
	size_t soap_flag_AccessListChange = 1;
	size_t soap_flag_AccessList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct cwmp__SetParameterAttributesStruct *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cwmp__SetParameterAttributesStruct, sizeof(struct cwmp__SetParameterAttributesStruct), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_cwmp__SetParameterAttributesStruct(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, "Name", &a->Name, "xsd:string"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_NotificationChange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "NotificationChange", &a->NotificationChange, "xsd:boolean"))
				{	soap_flag_NotificationChange--;
					continue;
				}
			if (soap_flag_Notification && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__cwmp__SetParameterAttributesStruct_Notification(soap, "Notification", &a->Notification, "cwmp:SetParameterAttributesStruct-Notification"))
				{	soap_flag_Notification--;
					continue;
				}
			if (soap_flag_AccessListChange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "AccessListChange", &a->AccessListChange, "xsd:boolean"))
				{	soap_flag_AccessListChange--;
					continue;
				}
			if (soap_flag_AccessList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToAccessList(soap, "AccessList", &a->AccessList, "xsd:string"))
				{	soap_flag_AccessList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0 || soap_flag_NotificationChange > 0 || soap_flag_Notification > 0 || soap_flag_AccessListChange > 0 || !a->AccessList))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct cwmp__SetParameterAttributesStruct *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_cwmp__SetParameterAttributesStruct, SOAP_TYPE_cwmp__SetParameterAttributesStruct, sizeof(struct cwmp__SetParameterAttributesStruct), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct cwmp__SetParameterAttributesStruct * SOAP_FMAC4 soap_new_cwmp__SetParameterAttributesStruct(struct soap *soap, int n)
{
	struct cwmp__SetParameterAttributesStruct *p;
	struct cwmp__SetParameterAttributesStruct *a = (struct cwmp__SetParameterAttributesStruct*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct cwmp__SetParameterAttributesStruct));
	for (p = a; p && n--; p++)
		soap_default_cwmp__SetParameterAttributesStruct(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_cwmp__SetParameterAttributesStruct(struct soap *soap, const struct cwmp__SetParameterAttributesStruct *a, const char *tag, const char *type)
{
	if (soap_out_cwmp__SetParameterAttributesStruct(soap, tag ? tag : "cwmp:SetParameterAttributesStruct", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct cwmp__SetParameterAttributesStruct * SOAP_FMAC4 soap_get_cwmp__SetParameterAttributesStruct(struct soap *soap, struct cwmp__SetParameterAttributesStruct *p, const char *tag, const char *type)
{
	if ((p = soap_in_cwmp__SetParameterAttributesStruct(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_cwmp__ParameterInfoStruct(struct soap *soap, struct cwmp__ParameterInfoStruct *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Name);
	soap_default_xsd__boolean(soap, &a->Writable);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_cwmp__ParameterInfoStruct(struct soap *soap, const struct cwmp__ParameterInfoStruct *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Name);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_cwmp__ParameterInfoStruct(struct soap *soap, const char *tag, int id, const struct cwmp__ParameterInfoStruct *a, const char *type)
{
	if (!type)
		type = "cwmp:ParameterInfoStruct";
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cwmp__ParameterInfoStruct), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_empty(soap, "Name"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "Name", -1, (char*const*)&a->Name, "xsd:string"))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "Writable", -1, &a->Writable, "xsd:boolean"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct cwmp__ParameterInfoStruct * SOAP_FMAC4 soap_in_cwmp__ParameterInfoStruct(struct soap *soap, const char *tag, struct cwmp__ParameterInfoStruct *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_Writable = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct cwmp__ParameterInfoStruct *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cwmp__ParameterInfoStruct, sizeof(struct cwmp__ParameterInfoStruct), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_cwmp__ParameterInfoStruct(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Name", (char**)&a->Name, "xsd:string"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_Writable && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "Writable", &a->Writable, "xsd:boolean"))
				{	soap_flag_Writable--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Name || soap_flag_Writable > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct cwmp__ParameterInfoStruct *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_cwmp__ParameterInfoStruct, SOAP_TYPE_cwmp__ParameterInfoStruct, sizeof(struct cwmp__ParameterInfoStruct), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct cwmp__ParameterInfoStruct * SOAP_FMAC4 soap_new_cwmp__ParameterInfoStruct(struct soap *soap, int n)
{
	struct cwmp__ParameterInfoStruct *p;
	struct cwmp__ParameterInfoStruct *a = (struct cwmp__ParameterInfoStruct*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct cwmp__ParameterInfoStruct));
	for (p = a; p && n--; p++)
		soap_default_cwmp__ParameterInfoStruct(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_cwmp__ParameterInfoStruct(struct soap *soap, const struct cwmp__ParameterInfoStruct *a, const char *tag, const char *type)
{
	if (soap_out_cwmp__ParameterInfoStruct(soap, tag ? tag : "cwmp:ParameterInfoStruct", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct cwmp__ParameterInfoStruct * SOAP_FMAC4 soap_get_cwmp__ParameterInfoStruct(struct soap *soap, struct cwmp__ParameterInfoStruct *p, const char *tag, const char *type)
{
	if ((p = soap_in_cwmp__ParameterInfoStruct(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_cwmp__ParameterValueStruct(struct soap *soap, struct cwmp__ParameterValueStruct *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Name);
	soap_default_xsd__anySimpleType(soap, &a->Value);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_cwmp__ParameterValueStruct(struct soap *soap, const struct cwmp__ParameterValueStruct *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Name);
	soap_serialize_xsd__anySimpleType(soap, (char*const*)&a->Value);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_cwmp__ParameterValueStruct(struct soap *soap, const char *tag, int id, const struct cwmp__ParameterValueStruct *a, const char *type)
{
	if (!type)
		type = "cwmp:ParameterValueStruct";
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cwmp__ParameterValueStruct), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_empty(soap, "Name"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "Name", -1, (char*const*)&a->Name, "xsd:string"))
		return soap->error;
	if (!a->Value)
	{	if (soap_element_empty(soap, "Value"))
			return soap->error;
	}
	else
	if (soap_out_xsd__anySimpleType(soap, "Value", -1, (char*const*)&a->Value, "xsd:anySimpleType"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct cwmp__ParameterValueStruct * SOAP_FMAC4 soap_in_cwmp__ParameterValueStruct(struct soap *soap, const char *tag, struct cwmp__ParameterValueStruct *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_Value = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct cwmp__ParameterValueStruct *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cwmp__ParameterValueStruct, sizeof(struct cwmp__ParameterValueStruct), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_cwmp__ParameterValueStruct(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Name", (char**)&a->Name, "xsd:string"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anySimpleType(soap, "Value", (char**)&a->Value, "xsd:anySimpleType"))
				{	soap_flag_Value--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Name || !a->Value))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct cwmp__ParameterValueStruct *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_cwmp__ParameterValueStruct, SOAP_TYPE_cwmp__ParameterValueStruct, sizeof(struct cwmp__ParameterValueStruct), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct cwmp__ParameterValueStruct * SOAP_FMAC4 soap_new_cwmp__ParameterValueStruct(struct soap *soap, int n)
{
	struct cwmp__ParameterValueStruct *p;
	struct cwmp__ParameterValueStruct *a = (struct cwmp__ParameterValueStruct*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct cwmp__ParameterValueStruct));
	for (p = a; p && n--; p++)
		soap_default_cwmp__ParameterValueStruct(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_cwmp__ParameterValueStruct(struct soap *soap, const struct cwmp__ParameterValueStruct *a, const char *tag, const char *type)
{
	if (soap_out_cwmp__ParameterValueStruct(soap, tag ? tag : "cwmp:ParameterValueStruct", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct cwmp__ParameterValueStruct * SOAP_FMAC4 soap_get_cwmp__ParameterValueStruct(struct soap *soap, struct cwmp__ParameterValueStruct *p, const char *tag, const char *type)
{
	if ((p = soap_in_cwmp__ParameterValueStruct(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_cwmp__EventStruct(struct soap *soap, struct cwmp__EventStruct *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->EventCode);
	soap_default_cwmp__CommandKeyType(soap, &a->CommandKey);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_cwmp__EventStruct(struct soap *soap, const struct cwmp__EventStruct *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->EventCode);
	soap_serialize_cwmp__CommandKeyType(soap, (char*const*)&a->CommandKey);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_cwmp__EventStruct(struct soap *soap, const char *tag, int id, const struct cwmp__EventStruct *a, const char *type)
{
	if (!type)
		type = "cwmp:EventStruct";
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cwmp__EventStruct), type))
		return soap->error;
	if (!a->EventCode)
	{	if (soap_element_empty(soap, "EventCode"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "EventCode", -1, (char*const*)&a->EventCode, "xsd:string"))
		return soap->error;
	if (!a->CommandKey)
	{	if (soap_element_empty(soap, "CommandKey"))
			return soap->error;
	}
	else
	if (soap_out_cwmp__CommandKeyType(soap, "CommandKey", -1, (char*const*)&a->CommandKey, "cwmp:CommandKeyType"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct cwmp__EventStruct * SOAP_FMAC4 soap_in_cwmp__EventStruct(struct soap *soap, const char *tag, struct cwmp__EventStruct *a, const char *type)
{
	size_t soap_flag_EventCode = 1;
	size_t soap_flag_CommandKey = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct cwmp__EventStruct *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cwmp__EventStruct, sizeof(struct cwmp__EventStruct), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_cwmp__EventStruct(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EventCode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "EventCode", (char**)&a->EventCode, "xsd:string"))
				{	soap_flag_EventCode--;
					continue;
				}
			if (soap_flag_CommandKey && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_cwmp__CommandKeyType(soap, "CommandKey", (char**)&a->CommandKey, "cwmp:CommandKeyType"))
				{	soap_flag_CommandKey--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->EventCode || !a->CommandKey))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct cwmp__EventStruct *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_cwmp__EventStruct, SOAP_TYPE_cwmp__EventStruct, sizeof(struct cwmp__EventStruct), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct cwmp__EventStruct * SOAP_FMAC4 soap_new_cwmp__EventStruct(struct soap *soap, int n)
{
	struct cwmp__EventStruct *p;
	struct cwmp__EventStruct *a = (struct cwmp__EventStruct*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct cwmp__EventStruct));
	for (p = a; p && n--; p++)
		soap_default_cwmp__EventStruct(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_cwmp__EventStruct(struct soap *soap, const struct cwmp__EventStruct *a, const char *tag, const char *type)
{
	if (soap_out_cwmp__EventStruct(soap, tag ? tag : "cwmp:EventStruct", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct cwmp__EventStruct * SOAP_FMAC4 soap_get_cwmp__EventStruct(struct soap *soap, struct cwmp__EventStruct *p, const char *tag, const char *type)
{
	if ((p = soap_in_cwmp__EventStruct(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_cwmp__DeviceIdStruct(struct soap *soap, struct cwmp__DeviceIdStruct *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Manufacturer);
	soap_default_string(soap, &a->OUI);
	soap_default_string(soap, &a->ProductClass);
	soap_default_string(soap, &a->SerialNumber);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_cwmp__DeviceIdStruct(struct soap *soap, const struct cwmp__DeviceIdStruct *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Manufacturer);
	soap_serialize_string(soap, (char*const*)&a->OUI);
	soap_serialize_string(soap, (char*const*)&a->ProductClass);
	soap_serialize_string(soap, (char*const*)&a->SerialNumber);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_cwmp__DeviceIdStruct(struct soap *soap, const char *tag, int id, const struct cwmp__DeviceIdStruct *a, const char *type)
{
	if (!type)
		type = "cwmp:DeviceIdStruct";
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cwmp__DeviceIdStruct), type))
		return soap->error;
	if (!a->Manufacturer)
	{	if (soap_element_empty(soap, "Manufacturer"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "Manufacturer", -1, (char*const*)&a->Manufacturer, "xsd:string"))
		return soap->error;
	if (!a->OUI)
	{	if (soap_element_empty(soap, "OUI"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "OUI", -1, (char*const*)&a->OUI, "xsd:string"))
		return soap->error;
	if (!a->ProductClass)
	{	if (soap_element_empty(soap, "ProductClass"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ProductClass", -1, (char*const*)&a->ProductClass, "xsd:string"))
		return soap->error;
	if (!a->SerialNumber)
	{	if (soap_element_empty(soap, "SerialNumber"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "SerialNumber", -1, (char*const*)&a->SerialNumber, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct cwmp__DeviceIdStruct * SOAP_FMAC4 soap_in_cwmp__DeviceIdStruct(struct soap *soap, const char *tag, struct cwmp__DeviceIdStruct *a, const char *type)
{
	size_t soap_flag_Manufacturer = 1;
	size_t soap_flag_OUI = 1;
	size_t soap_flag_ProductClass = 1;
	size_t soap_flag_SerialNumber = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct cwmp__DeviceIdStruct *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cwmp__DeviceIdStruct, sizeof(struct cwmp__DeviceIdStruct), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_cwmp__DeviceIdStruct(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Manufacturer && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Manufacturer", (char**)&a->Manufacturer, "xsd:string"))
				{	soap_flag_Manufacturer--;
					continue;
				}
			if (soap_flag_OUI && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "OUI", (char**)&a->OUI, "xsd:string"))
				{	soap_flag_OUI--;
					continue;
				}
			if (soap_flag_ProductClass && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ProductClass", (char**)&a->ProductClass, "xsd:string"))
				{	soap_flag_ProductClass--;
					continue;
				}
			if (soap_flag_SerialNumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SerialNumber", (char**)&a->SerialNumber, "xsd:string"))
				{	soap_flag_SerialNumber--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Manufacturer || !a->OUI || !a->ProductClass || !a->SerialNumber))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct cwmp__DeviceIdStruct *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_cwmp__DeviceIdStruct, SOAP_TYPE_cwmp__DeviceIdStruct, sizeof(struct cwmp__DeviceIdStruct), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct cwmp__DeviceIdStruct * SOAP_FMAC4 soap_new_cwmp__DeviceIdStruct(struct soap *soap, int n)
{
	struct cwmp__DeviceIdStruct *p;
	struct cwmp__DeviceIdStruct *a = (struct cwmp__DeviceIdStruct*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct cwmp__DeviceIdStruct));
	for (p = a; p && n--; p++)
		soap_default_cwmp__DeviceIdStruct(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_cwmp__DeviceIdStruct(struct soap *soap, const struct cwmp__DeviceIdStruct *a, const char *tag, const char *type)
{
	if (soap_out_cwmp__DeviceIdStruct(soap, tag ? tag : "cwmp:DeviceIdStruct", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct cwmp__DeviceIdStruct * SOAP_FMAC4 soap_get_cwmp__DeviceIdStruct(struct soap *soap, struct cwmp__DeviceIdStruct *p, const char *tag, const char *type)
{
	if ((p = soap_in_cwmp__DeviceIdStruct(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_cwmp__FaultStruct(struct soap *soap, struct cwmp__FaultStruct *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__cwmp__FaultStruct_FaultCode(soap, &a->FaultCode);
	soap_default_string(soap, &a->FaultString);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_cwmp__FaultStruct(struct soap *soap, const struct cwmp__FaultStruct *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->FaultString);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_cwmp__FaultStruct(struct soap *soap, const char *tag, int id, const struct cwmp__FaultStruct *a, const char *type)
{
	if (!type)
		type = "cwmp:FaultStruct";
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cwmp__FaultStruct), type))
		return soap->error;
	if (soap_out__cwmp__FaultStruct_FaultCode(soap, "FaultCode", -1, &a->FaultCode, "cwmp:FaultStruct-FaultCode"))
		return soap->error;
	if (!a->FaultString)
	{	if (soap_element_empty(soap, "FaultString"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "FaultString", -1, (char*const*)&a->FaultString, "xsd:string"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct cwmp__FaultStruct * SOAP_FMAC4 soap_in_cwmp__FaultStruct(struct soap *soap, const char *tag, struct cwmp__FaultStruct *a, const char *type)
{
	size_t soap_flag_FaultCode = 1;
	size_t soap_flag_FaultString = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct cwmp__FaultStruct *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cwmp__FaultStruct, sizeof(struct cwmp__FaultStruct), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_cwmp__FaultStruct(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FaultCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__cwmp__FaultStruct_FaultCode(soap, "FaultCode", &a->FaultCode, "cwmp:FaultStruct-FaultCode"))
				{	soap_flag_FaultCode--;
					continue;
				}
			if (soap_flag_FaultString && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "FaultString", (char**)&a->FaultString, "xsd:string"))
				{	soap_flag_FaultString--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FaultCode > 0 || !a->FaultString))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct cwmp__FaultStruct *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_cwmp__FaultStruct, SOAP_TYPE_cwmp__FaultStruct, sizeof(struct cwmp__FaultStruct), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct cwmp__FaultStruct * SOAP_FMAC4 soap_new_cwmp__FaultStruct(struct soap *soap, int n)
{
	struct cwmp__FaultStruct *p;
	struct cwmp__FaultStruct *a = (struct cwmp__FaultStruct*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct cwmp__FaultStruct));
	for (p = a; p && n--; p++)
		soap_default_cwmp__FaultStruct(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_cwmp__FaultStruct(struct soap *soap, const struct cwmp__FaultStruct *a, const char *tag, const char *type)
{
	if (soap_out_cwmp__FaultStruct(soap, tag ? tag : "cwmp:FaultStruct", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct cwmp__FaultStruct * SOAP_FMAC4 soap_get_cwmp__FaultStruct(struct soap *soap, struct cwmp__FaultStruct *p, const char *tag, const char *type)
{
	if ((p = soap_in_cwmp__FaultStruct(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENC__base64(struct soap *soap, struct SOAP_ENC__base64 *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__ptr = NULL;
	a->__size = 0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENC__base64(struct soap *soap, const struct SOAP_ENC__base64 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__ptr)
		soap_array_reference(soap, a, a->__ptr, a->__size, SOAP_TYPE_SOAP_ENC__base64);
#endif
}

SOAP_FMAC3S const char* SOAP_FMAC4S soap_SOAP_ENC__base642s(struct soap *soap, struct SOAP_ENC__base64 a)
{
	return soap_s2base64(soap, a.__ptr, NULL, a.__size);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENC__base64(struct soap *soap, const char *tag, int id, const struct SOAP_ENC__base64 *a, const char *type)
{
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_SOAP_ENC__base64, NULL);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2SOAP_ENC__base64(struct soap *soap, const char *s, struct SOAP_ENC__base64 *a)
{
	a->__ptr = (unsigned char*)soap_base642s(soap, s, NULL, 0, &a->__size);
	if (!a->__ptr)
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENC__base64 * SOAP_FMAC4 soap_in_SOAP_ENC__base64(struct soap *soap, const char *tag, struct SOAP_ENC__base64 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct SOAP_ENC__base64 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENC__base64, sizeof(struct SOAP_ENC__base64), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENC__base64(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENC__base64 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENC__base64, SOAP_TYPE_SOAP_ENC__base64, sizeof(struct SOAP_ENC__base64), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENC__base64 * SOAP_FMAC4 soap_new_SOAP_ENC__base64(struct soap *soap, int n)
{
	struct SOAP_ENC__base64 *p;
	struct SOAP_ENC__base64 *a = (struct SOAP_ENC__base64*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct SOAP_ENC__base64));
	for (p = a; p && n--; p++)
		soap_default_SOAP_ENC__base64(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENC__base64(struct soap *soap, const struct SOAP_ENC__base64 *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENC__base64(soap, tag ? tag : "SOAP-ENC:base64", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENC__base64 * SOAP_FMAC4 soap_get_SOAP_ENC__base64(struct soap *soap, struct SOAP_ENC__base64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENC__base64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code, &mark);
	if (id < 0)
		return soap->error;
	soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTocwmp__InformResponse(struct soap *soap, struct cwmp__InformResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_cwmp__InformResponse))
		soap_serialize_cwmp__InformResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTocwmp__InformResponse(struct soap *soap, const char *tag, int id, struct cwmp__InformResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cwmp__InformResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_cwmp__InformResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct cwmp__InformResponse ** SOAP_FMAC4 soap_in_PointerTocwmp__InformResponse(struct soap *soap, const char *tag, struct cwmp__InformResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct cwmp__InformResponse **)soap_malloc(soap, sizeof(struct cwmp__InformResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_cwmp__InformResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct cwmp__InformResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cwmp__InformResponse, sizeof(struct cwmp__InformResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTocwmp__InformResponse(struct soap *soap, struct cwmp__InformResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTocwmp__InformResponse(soap, tag ? tag : "cwmp:InformResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct cwmp__InformResponse ** SOAP_FMAC4 soap_get_PointerTocwmp__InformResponse(struct soap *soap, struct cwmp__InformResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTocwmp__InformResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTocwmp__ArgStruct(struct soap *soap, struct cwmp__ArgStruct **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTocwmp__ArgStruct))
		soap_serialize_PointerTocwmp__ArgStruct(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTocwmp__ArgStruct(struct soap *soap, const char *tag, int id, struct cwmp__ArgStruct **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTocwmp__ArgStruct, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTocwmp__ArgStruct(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct cwmp__ArgStruct *** SOAP_FMAC4 soap_in_PointerToPointerTocwmp__ArgStruct(struct soap *soap, const char *tag, struct cwmp__ArgStruct ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct cwmp__ArgStruct ***)soap_malloc(soap, sizeof(struct cwmp__ArgStruct **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTocwmp__ArgStruct(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct cwmp__ArgStruct ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cwmp__ArgStruct, sizeof(struct cwmp__ArgStruct), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTocwmp__ArgStruct(struct soap *soap, struct cwmp__ArgStruct **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTocwmp__ArgStruct(soap, tag ? tag : "cwmp:ArgStruct", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct cwmp__ArgStruct *** SOAP_FMAC4 soap_get_PointerToPointerTocwmp__ArgStruct(struct soap *soap, struct cwmp__ArgStruct ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTocwmp__ArgStruct(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTocwmp__ArgStruct(struct soap *soap, struct cwmp__ArgStruct *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_cwmp__ArgStruct))
		soap_serialize_cwmp__ArgStruct(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTocwmp__ArgStruct(struct soap *soap, const char *tag, int id, struct cwmp__ArgStruct *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cwmp__ArgStruct, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_cwmp__ArgStruct(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct cwmp__ArgStruct ** SOAP_FMAC4 soap_in_PointerTocwmp__ArgStruct(struct soap *soap, const char *tag, struct cwmp__ArgStruct **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct cwmp__ArgStruct **)soap_malloc(soap, sizeof(struct cwmp__ArgStruct *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_cwmp__ArgStruct(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct cwmp__ArgStruct **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cwmp__ArgStruct, sizeof(struct cwmp__ArgStruct), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTocwmp__ArgStruct(struct soap *soap, struct cwmp__ArgStruct *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTocwmp__ArgStruct(soap, tag ? tag : "cwmp:ArgStruct", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct cwmp__ArgStruct ** SOAP_FMAC4 soap_get_PointerTocwmp__ArgStruct(struct soap *soap, struct cwmp__ArgStruct **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTocwmp__ArgStruct(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTocwmp__OptionStruct(struct soap *soap, struct cwmp__OptionStruct **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTocwmp__OptionStruct))
		soap_serialize_PointerTocwmp__OptionStruct(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTocwmp__OptionStruct(struct soap *soap, const char *tag, int id, struct cwmp__OptionStruct **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTocwmp__OptionStruct, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTocwmp__OptionStruct(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct cwmp__OptionStruct *** SOAP_FMAC4 soap_in_PointerToPointerTocwmp__OptionStruct(struct soap *soap, const char *tag, struct cwmp__OptionStruct ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct cwmp__OptionStruct ***)soap_malloc(soap, sizeof(struct cwmp__OptionStruct **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTocwmp__OptionStruct(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct cwmp__OptionStruct ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cwmp__OptionStruct, sizeof(struct cwmp__OptionStruct), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTocwmp__OptionStruct(struct soap *soap, struct cwmp__OptionStruct **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTocwmp__OptionStruct(soap, tag ? tag : "cwmp:OptionStruct", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct cwmp__OptionStruct *** SOAP_FMAC4 soap_get_PointerToPointerTocwmp__OptionStruct(struct soap *soap, struct cwmp__OptionStruct ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTocwmp__OptionStruct(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTocwmp__OptionStruct(struct soap *soap, struct cwmp__OptionStruct *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_cwmp__OptionStruct))
		soap_serialize_cwmp__OptionStruct(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTocwmp__OptionStruct(struct soap *soap, const char *tag, int id, struct cwmp__OptionStruct *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cwmp__OptionStruct, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_cwmp__OptionStruct(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct cwmp__OptionStruct ** SOAP_FMAC4 soap_in_PointerTocwmp__OptionStruct(struct soap *soap, const char *tag, struct cwmp__OptionStruct **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct cwmp__OptionStruct **)soap_malloc(soap, sizeof(struct cwmp__OptionStruct *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_cwmp__OptionStruct(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct cwmp__OptionStruct **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cwmp__OptionStruct, sizeof(struct cwmp__OptionStruct), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTocwmp__OptionStruct(struct soap *soap, struct cwmp__OptionStruct *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTocwmp__OptionStruct(soap, tag ? tag : "cwmp:OptionStruct", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct cwmp__OptionStruct ** SOAP_FMAC4 soap_get_PointerTocwmp__OptionStruct(struct soap *soap, struct cwmp__OptionStruct **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTocwmp__OptionStruct(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENC__base64(struct soap *soap, struct SOAP_ENC__base64 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		soap_serialize_SOAP_ENC__base64(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENC__base64(struct soap *soap, const char *tag, int id, struct SOAP_ENC__base64 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptr : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_SOAP_ENC__base64, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENC__base64(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENC__base64 ** SOAP_FMAC4 soap_in_PointerToSOAP_ENC__base64(struct soap *soap, const char *tag, struct SOAP_ENC__base64 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENC__base64 **)soap_malloc(soap, sizeof(struct SOAP_ENC__base64 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENC__base64(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENC__base64 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENC__base64, sizeof(struct SOAP_ENC__base64), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENC__base64(struct soap *soap, struct SOAP_ENC__base64 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENC__base64(soap, tag ? tag : "SOAP-ENC:base64", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENC__base64 ** SOAP_FMAC4 soap_get_PointerToSOAP_ENC__base64(struct soap *soap, struct SOAP_ENC__base64 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENC__base64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTocwmp__QueuedTransferStruct(struct soap *soap, struct cwmp__QueuedTransferStruct **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTocwmp__QueuedTransferStruct))
		soap_serialize_PointerTocwmp__QueuedTransferStruct(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTocwmp__QueuedTransferStruct(struct soap *soap, const char *tag, int id, struct cwmp__QueuedTransferStruct **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTocwmp__QueuedTransferStruct, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTocwmp__QueuedTransferStruct(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct cwmp__QueuedTransferStruct *** SOAP_FMAC4 soap_in_PointerToPointerTocwmp__QueuedTransferStruct(struct soap *soap, const char *tag, struct cwmp__QueuedTransferStruct ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct cwmp__QueuedTransferStruct ***)soap_malloc(soap, sizeof(struct cwmp__QueuedTransferStruct **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTocwmp__QueuedTransferStruct(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct cwmp__QueuedTransferStruct ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cwmp__QueuedTransferStruct, sizeof(struct cwmp__QueuedTransferStruct), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTocwmp__QueuedTransferStruct(struct soap *soap, struct cwmp__QueuedTransferStruct **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTocwmp__QueuedTransferStruct(soap, tag ? tag : "cwmp:QueuedTransferStruct", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct cwmp__QueuedTransferStruct *** SOAP_FMAC4 soap_get_PointerToPointerTocwmp__QueuedTransferStruct(struct soap *soap, struct cwmp__QueuedTransferStruct ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTocwmp__QueuedTransferStruct(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTocwmp__QueuedTransferStruct(struct soap *soap, struct cwmp__QueuedTransferStruct *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_cwmp__QueuedTransferStruct))
		soap_serialize_cwmp__QueuedTransferStruct(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTocwmp__QueuedTransferStruct(struct soap *soap, const char *tag, int id, struct cwmp__QueuedTransferStruct *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cwmp__QueuedTransferStruct, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_cwmp__QueuedTransferStruct(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct cwmp__QueuedTransferStruct ** SOAP_FMAC4 soap_in_PointerTocwmp__QueuedTransferStruct(struct soap *soap, const char *tag, struct cwmp__QueuedTransferStruct **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct cwmp__QueuedTransferStruct **)soap_malloc(soap, sizeof(struct cwmp__QueuedTransferStruct *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_cwmp__QueuedTransferStruct(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct cwmp__QueuedTransferStruct **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cwmp__QueuedTransferStruct, sizeof(struct cwmp__QueuedTransferStruct), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTocwmp__QueuedTransferStruct(struct soap *soap, struct cwmp__QueuedTransferStruct *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTocwmp__QueuedTransferStruct(soap, tag ? tag : "cwmp:QueuedTransferStruct", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct cwmp__QueuedTransferStruct ** SOAP_FMAC4 soap_get_PointerTocwmp__QueuedTransferStruct(struct soap *soap, struct cwmp__QueuedTransferStruct **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTocwmp__QueuedTransferStruct(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTocwmp__ParameterAttributeStruct(struct soap *soap, struct cwmp__ParameterAttributeStruct **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTocwmp__ParameterAttributeStruct))
		soap_serialize_PointerTocwmp__ParameterAttributeStruct(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTocwmp__ParameterAttributeStruct(struct soap *soap, const char *tag, int id, struct cwmp__ParameterAttributeStruct **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTocwmp__ParameterAttributeStruct, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTocwmp__ParameterAttributeStruct(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct cwmp__ParameterAttributeStruct *** SOAP_FMAC4 soap_in_PointerToPointerTocwmp__ParameterAttributeStruct(struct soap *soap, const char *tag, struct cwmp__ParameterAttributeStruct ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct cwmp__ParameterAttributeStruct ***)soap_malloc(soap, sizeof(struct cwmp__ParameterAttributeStruct **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTocwmp__ParameterAttributeStruct(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct cwmp__ParameterAttributeStruct ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cwmp__ParameterAttributeStruct, sizeof(struct cwmp__ParameterAttributeStruct), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTocwmp__ParameterAttributeStruct(struct soap *soap, struct cwmp__ParameterAttributeStruct **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTocwmp__ParameterAttributeStruct(soap, tag ? tag : "cwmp:ParameterAttributeStruct", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct cwmp__ParameterAttributeStruct *** SOAP_FMAC4 soap_get_PointerToPointerTocwmp__ParameterAttributeStruct(struct soap *soap, struct cwmp__ParameterAttributeStruct ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTocwmp__ParameterAttributeStruct(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTocwmp__ParameterAttributeStruct(struct soap *soap, struct cwmp__ParameterAttributeStruct *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_cwmp__ParameterAttributeStruct))
		soap_serialize_cwmp__ParameterAttributeStruct(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTocwmp__ParameterAttributeStruct(struct soap *soap, const char *tag, int id, struct cwmp__ParameterAttributeStruct *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cwmp__ParameterAttributeStruct, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_cwmp__ParameterAttributeStruct(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct cwmp__ParameterAttributeStruct ** SOAP_FMAC4 soap_in_PointerTocwmp__ParameterAttributeStruct(struct soap *soap, const char *tag, struct cwmp__ParameterAttributeStruct **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct cwmp__ParameterAttributeStruct **)soap_malloc(soap, sizeof(struct cwmp__ParameterAttributeStruct *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_cwmp__ParameterAttributeStruct(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct cwmp__ParameterAttributeStruct **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cwmp__ParameterAttributeStruct, sizeof(struct cwmp__ParameterAttributeStruct), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTocwmp__ParameterAttributeStruct(struct soap *soap, struct cwmp__ParameterAttributeStruct *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTocwmp__ParameterAttributeStruct(soap, tag ? tag : "cwmp:ParameterAttributeStruct", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct cwmp__ParameterAttributeStruct ** SOAP_FMAC4 soap_get_PointerTocwmp__ParameterAttributeStruct(struct soap *soap, struct cwmp__ParameterAttributeStruct **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTocwmp__ParameterAttributeStruct(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTocwmp__SetParameterAttributesStruct(struct soap *soap, struct cwmp__SetParameterAttributesStruct **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTocwmp__SetParameterAttributesStruct))
		soap_serialize_PointerTocwmp__SetParameterAttributesStruct(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTocwmp__SetParameterAttributesStruct(struct soap *soap, const char *tag, int id, struct cwmp__SetParameterAttributesStruct **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTocwmp__SetParameterAttributesStruct, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTocwmp__SetParameterAttributesStruct(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct cwmp__SetParameterAttributesStruct *** SOAP_FMAC4 soap_in_PointerToPointerTocwmp__SetParameterAttributesStruct(struct soap *soap, const char *tag, struct cwmp__SetParameterAttributesStruct ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct cwmp__SetParameterAttributesStruct ***)soap_malloc(soap, sizeof(struct cwmp__SetParameterAttributesStruct **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTocwmp__SetParameterAttributesStruct(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct cwmp__SetParameterAttributesStruct ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cwmp__SetParameterAttributesStruct, sizeof(struct cwmp__SetParameterAttributesStruct), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTocwmp__SetParameterAttributesStruct(struct soap *soap, struct cwmp__SetParameterAttributesStruct **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTocwmp__SetParameterAttributesStruct(soap, tag ? tag : "cwmp:SetParameterAttributesStruct", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct cwmp__SetParameterAttributesStruct *** SOAP_FMAC4 soap_get_PointerToPointerTocwmp__SetParameterAttributesStruct(struct soap *soap, struct cwmp__SetParameterAttributesStruct ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTocwmp__SetParameterAttributesStruct(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTocwmp__SetParameterAttributesStruct(struct soap *soap, struct cwmp__SetParameterAttributesStruct *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_cwmp__SetParameterAttributesStruct))
		soap_serialize_cwmp__SetParameterAttributesStruct(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTocwmp__SetParameterAttributesStruct(struct soap *soap, const char *tag, int id, struct cwmp__SetParameterAttributesStruct *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cwmp__SetParameterAttributesStruct, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_cwmp__SetParameterAttributesStruct(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct cwmp__SetParameterAttributesStruct ** SOAP_FMAC4 soap_in_PointerTocwmp__SetParameterAttributesStruct(struct soap *soap, const char *tag, struct cwmp__SetParameterAttributesStruct **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct cwmp__SetParameterAttributesStruct **)soap_malloc(soap, sizeof(struct cwmp__SetParameterAttributesStruct *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_cwmp__SetParameterAttributesStruct(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct cwmp__SetParameterAttributesStruct **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cwmp__SetParameterAttributesStruct, sizeof(struct cwmp__SetParameterAttributesStruct), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTocwmp__SetParameterAttributesStruct(struct soap *soap, struct cwmp__SetParameterAttributesStruct *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTocwmp__SetParameterAttributesStruct(soap, tag ? tag : "cwmp:SetParameterAttributesStruct", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct cwmp__SetParameterAttributesStruct ** SOAP_FMAC4 soap_get_PointerTocwmp__SetParameterAttributesStruct(struct soap *soap, struct cwmp__SetParameterAttributesStruct **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTocwmp__SetParameterAttributesStruct(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTocwmp__ParameterInfoStruct(struct soap *soap, struct cwmp__ParameterInfoStruct **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTocwmp__ParameterInfoStruct))
		soap_serialize_PointerTocwmp__ParameterInfoStruct(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTocwmp__ParameterInfoStruct(struct soap *soap, const char *tag, int id, struct cwmp__ParameterInfoStruct **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTocwmp__ParameterInfoStruct, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTocwmp__ParameterInfoStruct(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct cwmp__ParameterInfoStruct *** SOAP_FMAC4 soap_in_PointerToPointerTocwmp__ParameterInfoStruct(struct soap *soap, const char *tag, struct cwmp__ParameterInfoStruct ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct cwmp__ParameterInfoStruct ***)soap_malloc(soap, sizeof(struct cwmp__ParameterInfoStruct **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTocwmp__ParameterInfoStruct(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct cwmp__ParameterInfoStruct ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cwmp__ParameterInfoStruct, sizeof(struct cwmp__ParameterInfoStruct), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTocwmp__ParameterInfoStruct(struct soap *soap, struct cwmp__ParameterInfoStruct **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTocwmp__ParameterInfoStruct(soap, tag ? tag : "cwmp:ParameterInfoStruct", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct cwmp__ParameterInfoStruct *** SOAP_FMAC4 soap_get_PointerToPointerTocwmp__ParameterInfoStruct(struct soap *soap, struct cwmp__ParameterInfoStruct ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTocwmp__ParameterInfoStruct(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTocwmp__ParameterInfoStruct(struct soap *soap, struct cwmp__ParameterInfoStruct *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_cwmp__ParameterInfoStruct))
		soap_serialize_cwmp__ParameterInfoStruct(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTocwmp__ParameterInfoStruct(struct soap *soap, const char *tag, int id, struct cwmp__ParameterInfoStruct *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cwmp__ParameterInfoStruct, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_cwmp__ParameterInfoStruct(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct cwmp__ParameterInfoStruct ** SOAP_FMAC4 soap_in_PointerTocwmp__ParameterInfoStruct(struct soap *soap, const char *tag, struct cwmp__ParameterInfoStruct **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct cwmp__ParameterInfoStruct **)soap_malloc(soap, sizeof(struct cwmp__ParameterInfoStruct *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_cwmp__ParameterInfoStruct(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct cwmp__ParameterInfoStruct **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cwmp__ParameterInfoStruct, sizeof(struct cwmp__ParameterInfoStruct), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTocwmp__ParameterInfoStruct(struct soap *soap, struct cwmp__ParameterInfoStruct *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTocwmp__ParameterInfoStruct(soap, tag ? tag : "cwmp:ParameterInfoStruct", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct cwmp__ParameterInfoStruct ** SOAP_FMAC4 soap_get_PointerTocwmp__ParameterInfoStruct(struct soap *soap, struct cwmp__ParameterInfoStruct **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTocwmp__ParameterInfoStruct(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTocwmp__ParameterValueStruct(struct soap *soap, struct cwmp__ParameterValueStruct **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTocwmp__ParameterValueStruct))
		soap_serialize_PointerTocwmp__ParameterValueStruct(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTocwmp__ParameterValueStruct(struct soap *soap, const char *tag, int id, struct cwmp__ParameterValueStruct **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTocwmp__ParameterValueStruct, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTocwmp__ParameterValueStruct(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct cwmp__ParameterValueStruct *** SOAP_FMAC4 soap_in_PointerToPointerTocwmp__ParameterValueStruct(struct soap *soap, const char *tag, struct cwmp__ParameterValueStruct ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct cwmp__ParameterValueStruct ***)soap_malloc(soap, sizeof(struct cwmp__ParameterValueStruct **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTocwmp__ParameterValueStruct(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct cwmp__ParameterValueStruct ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cwmp__ParameterValueStruct, sizeof(struct cwmp__ParameterValueStruct), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTocwmp__ParameterValueStruct(struct soap *soap, struct cwmp__ParameterValueStruct **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTocwmp__ParameterValueStruct(soap, tag ? tag : "cwmp:ParameterValueStruct", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct cwmp__ParameterValueStruct *** SOAP_FMAC4 soap_get_PointerToPointerTocwmp__ParameterValueStruct(struct soap *soap, struct cwmp__ParameterValueStruct ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTocwmp__ParameterValueStruct(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTocwmp__ParameterValueStruct(struct soap *soap, struct cwmp__ParameterValueStruct *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_cwmp__ParameterValueStruct))
		soap_serialize_cwmp__ParameterValueStruct(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTocwmp__ParameterValueStruct(struct soap *soap, const char *tag, int id, struct cwmp__ParameterValueStruct *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cwmp__ParameterValueStruct, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_cwmp__ParameterValueStruct(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct cwmp__ParameterValueStruct ** SOAP_FMAC4 soap_in_PointerTocwmp__ParameterValueStruct(struct soap *soap, const char *tag, struct cwmp__ParameterValueStruct **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct cwmp__ParameterValueStruct **)soap_malloc(soap, sizeof(struct cwmp__ParameterValueStruct *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_cwmp__ParameterValueStruct(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct cwmp__ParameterValueStruct **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cwmp__ParameterValueStruct, sizeof(struct cwmp__ParameterValueStruct), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTocwmp__ParameterValueStruct(struct soap *soap, struct cwmp__ParameterValueStruct *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTocwmp__ParameterValueStruct(soap, tag ? tag : "cwmp:ParameterValueStruct", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct cwmp__ParameterValueStruct ** SOAP_FMAC4 soap_get_PointerTocwmp__ParameterValueStruct(struct soap *soap, struct cwmp__ParameterValueStruct **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTocwmp__ParameterValueStruct(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTocwmp__EventStruct(struct soap *soap, struct cwmp__EventStruct **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTocwmp__EventStruct))
		soap_serialize_PointerTocwmp__EventStruct(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTocwmp__EventStruct(struct soap *soap, const char *tag, int id, struct cwmp__EventStruct **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTocwmp__EventStruct, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTocwmp__EventStruct(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct cwmp__EventStruct *** SOAP_FMAC4 soap_in_PointerToPointerTocwmp__EventStruct(struct soap *soap, const char *tag, struct cwmp__EventStruct ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct cwmp__EventStruct ***)soap_malloc(soap, sizeof(struct cwmp__EventStruct **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTocwmp__EventStruct(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct cwmp__EventStruct ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cwmp__EventStruct, sizeof(struct cwmp__EventStruct), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTocwmp__EventStruct(struct soap *soap, struct cwmp__EventStruct **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTocwmp__EventStruct(soap, tag ? tag : "cwmp:EventStruct", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct cwmp__EventStruct *** SOAP_FMAC4 soap_get_PointerToPointerTocwmp__EventStruct(struct soap *soap, struct cwmp__EventStruct ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTocwmp__EventStruct(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTocwmp__EventStruct(struct soap *soap, struct cwmp__EventStruct *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_cwmp__EventStruct))
		soap_serialize_cwmp__EventStruct(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTocwmp__EventStruct(struct soap *soap, const char *tag, int id, struct cwmp__EventStruct *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cwmp__EventStruct, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_cwmp__EventStruct(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct cwmp__EventStruct ** SOAP_FMAC4 soap_in_PointerTocwmp__EventStruct(struct soap *soap, const char *tag, struct cwmp__EventStruct **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct cwmp__EventStruct **)soap_malloc(soap, sizeof(struct cwmp__EventStruct *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_cwmp__EventStruct(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct cwmp__EventStruct **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cwmp__EventStruct, sizeof(struct cwmp__EventStruct), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTocwmp__EventStruct(struct soap *soap, struct cwmp__EventStruct *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTocwmp__EventStruct(soap, tag ? tag : "cwmp:EventStruct", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct cwmp__EventStruct ** SOAP_FMAC4 soap_get_PointerTocwmp__EventStruct(struct soap *soap, struct cwmp__EventStruct **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTocwmp__EventStruct(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToFileTypeArg(struct soap *soap, struct FileTypeArg *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		soap_serialize_FileTypeArg(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToFileTypeArg(struct soap *soap, const char *tag, int id, struct FileTypeArg *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptrArgStruct : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_FileTypeArg, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_FileTypeArg(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct FileTypeArg ** SOAP_FMAC4 soap_in_PointerToFileTypeArg(struct soap *soap, const char *tag, struct FileTypeArg **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct FileTypeArg **)soap_malloc(soap, sizeof(struct FileTypeArg *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_FileTypeArg(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct FileTypeArg **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_FileTypeArg, sizeof(struct FileTypeArg), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToFileTypeArg(struct soap *soap, struct FileTypeArg *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToFileTypeArg(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct FileTypeArg ** SOAP_FMAC4 soap_get_PointerToFileTypeArg(struct soap *soap, struct FileTypeArg **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToFileTypeArg(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTocwmp__FaultStruct(struct soap *soap, struct cwmp__FaultStruct *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_cwmp__FaultStruct))
		soap_serialize_cwmp__FaultStruct(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTocwmp__FaultStruct(struct soap *soap, const char *tag, int id, struct cwmp__FaultStruct *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cwmp__FaultStruct, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_cwmp__FaultStruct(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct cwmp__FaultStruct ** SOAP_FMAC4 soap_in_PointerTocwmp__FaultStruct(struct soap *soap, const char *tag, struct cwmp__FaultStruct **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct cwmp__FaultStruct **)soap_malloc(soap, sizeof(struct cwmp__FaultStruct *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_cwmp__FaultStruct(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct cwmp__FaultStruct **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cwmp__FaultStruct, sizeof(struct cwmp__FaultStruct), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTocwmp__FaultStruct(struct soap *soap, struct cwmp__FaultStruct *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTocwmp__FaultStruct(soap, tag ? tag : "cwmp:FaultStruct", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct cwmp__FaultStruct ** SOAP_FMAC4 soap_get_PointerTocwmp__FaultStruct(struct soap *soap, struct cwmp__FaultStruct **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTocwmp__FaultStruct(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToEventList(struct soap *soap, struct EventList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		soap_serialize_EventList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToEventList(struct soap *soap, const char *tag, int id, struct EventList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptrEventStruct : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_EventList, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_EventList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct EventList ** SOAP_FMAC4 soap_in_PointerToEventList(struct soap *soap, const char *tag, struct EventList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct EventList **)soap_malloc(soap, sizeof(struct EventList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_EventList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct EventList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_EventList, sizeof(struct EventList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToEventList(struct soap *soap, struct EventList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToEventList(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct EventList ** SOAP_FMAC4 soap_get_PointerToEventList(struct soap *soap, struct EventList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToEventList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTocwmp__DeviceIdStruct(struct soap *soap, struct cwmp__DeviceIdStruct *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_cwmp__DeviceIdStruct))
		soap_serialize_cwmp__DeviceIdStruct(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTocwmp__DeviceIdStruct(struct soap *soap, const char *tag, int id, struct cwmp__DeviceIdStruct *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_cwmp__DeviceIdStruct, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_cwmp__DeviceIdStruct(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct cwmp__DeviceIdStruct ** SOAP_FMAC4 soap_in_PointerTocwmp__DeviceIdStruct(struct soap *soap, const char *tag, struct cwmp__DeviceIdStruct **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct cwmp__DeviceIdStruct **)soap_malloc(soap, sizeof(struct cwmp__DeviceIdStruct *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_cwmp__DeviceIdStruct(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct cwmp__DeviceIdStruct **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_cwmp__DeviceIdStruct, sizeof(struct cwmp__DeviceIdStruct), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTocwmp__DeviceIdStruct(struct soap *soap, struct cwmp__DeviceIdStruct *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTocwmp__DeviceIdStruct(soap, tag ? tag : "cwmp:DeviceIdStruct", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct cwmp__DeviceIdStruct ** SOAP_FMAC4 soap_get_PointerTocwmp__DeviceIdStruct(struct soap *soap, struct cwmp__DeviceIdStruct **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTocwmp__DeviceIdStruct(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToOptionList(struct soap *soap, struct OptionList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		soap_serialize_OptionList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToOptionList(struct soap *soap, const char *tag, int id, struct OptionList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptrOptionStruct : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_OptionList, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_OptionList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct OptionList ** SOAP_FMAC4 soap_in_PointerToOptionList(struct soap *soap, const char *tag, struct OptionList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct OptionList **)soap_malloc(soap, sizeof(struct OptionList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_OptionList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct OptionList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_OptionList, sizeof(struct OptionList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToOptionList(struct soap *soap, struct OptionList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToOptionList(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct OptionList ** SOAP_FMAC4 soap_get_PointerToOptionList(struct soap *soap, struct OptionList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToOptionList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToVoucherList(struct soap *soap, struct VoucherList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		soap_serialize_VoucherList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToVoucherList(struct soap *soap, const char *tag, int id, struct VoucherList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptrbase64 : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_VoucherList, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_VoucherList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct VoucherList ** SOAP_FMAC4 soap_in_PointerToVoucherList(struct soap *soap, const char *tag, struct VoucherList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct VoucherList **)soap_malloc(soap, sizeof(struct VoucherList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_VoucherList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct VoucherList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_VoucherList, sizeof(struct VoucherList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToVoucherList(struct soap *soap, struct VoucherList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToVoucherList(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct VoucherList ** SOAP_FMAC4 soap_get_PointerToVoucherList(struct soap *soap, struct VoucherList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToVoucherList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTransferList(struct soap *soap, struct TransferList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		soap_serialize_TransferList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTransferList(struct soap *soap, const char *tag, int id, struct TransferList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptrQueuedTransferStruct : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_TransferList, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_TransferList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct TransferList ** SOAP_FMAC4 soap_in_PointerToTransferList(struct soap *soap, const char *tag, struct TransferList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct TransferList **)soap_malloc(soap, sizeof(struct TransferList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_TransferList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct TransferList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TransferList, sizeof(struct TransferList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTransferList(struct soap *soap, struct TransferList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToTransferList(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct TransferList ** SOAP_FMAC4 soap_get_PointerToTransferList(struct soap *soap, struct TransferList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTransferList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToParameterAttributeList(struct soap *soap, struct ParameterAttributeList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		soap_serialize_ParameterAttributeList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToParameterAttributeList(struct soap *soap, const char *tag, int id, struct ParameterAttributeList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptrParameterAttributeStruct : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_ParameterAttributeList, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ParameterAttributeList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ParameterAttributeList ** SOAP_FMAC4 soap_in_PointerToParameterAttributeList(struct soap *soap, const char *tag, struct ParameterAttributeList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ParameterAttributeList **)soap_malloc(soap, sizeof(struct ParameterAttributeList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ParameterAttributeList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ParameterAttributeList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ParameterAttributeList, sizeof(struct ParameterAttributeList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToParameterAttributeList(struct soap *soap, struct ParameterAttributeList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToParameterAttributeList(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ParameterAttributeList ** SOAP_FMAC4 soap_get_PointerToParameterAttributeList(struct soap *soap, struct ParameterAttributeList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToParameterAttributeList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSetParameterAttributesList(struct soap *soap, struct SetParameterAttributesList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		soap_serialize_SetParameterAttributesList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSetParameterAttributesList(struct soap *soap, const char *tag, int id, struct SetParameterAttributesList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptrSetParameterAttributesStruct : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_SetParameterAttributesList, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SetParameterAttributesList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SetParameterAttributesList ** SOAP_FMAC4 soap_in_PointerToSetParameterAttributesList(struct soap *soap, const char *tag, struct SetParameterAttributesList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SetParameterAttributesList **)soap_malloc(soap, sizeof(struct SetParameterAttributesList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SetParameterAttributesList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SetParameterAttributesList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SetParameterAttributesList, sizeof(struct SetParameterAttributesList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSetParameterAttributesList(struct soap *soap, struct SetParameterAttributesList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSetParameterAttributesList(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SetParameterAttributesList ** SOAP_FMAC4 soap_get_PointerToSetParameterAttributesList(struct soap *soap, struct SetParameterAttributesList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSetParameterAttributesList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToParameterInfoList(struct soap *soap, struct ParameterInfoList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		soap_serialize_ParameterInfoList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToParameterInfoList(struct soap *soap, const char *tag, int id, struct ParameterInfoList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptrParameterInfoStruct : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_ParameterInfoList, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ParameterInfoList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ParameterInfoList ** SOAP_FMAC4 soap_in_PointerToParameterInfoList(struct soap *soap, const char *tag, struct ParameterInfoList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ParameterInfoList **)soap_malloc(soap, sizeof(struct ParameterInfoList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ParameterInfoList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ParameterInfoList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ParameterInfoList, sizeof(struct ParameterInfoList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToParameterInfoList(struct soap *soap, struct ParameterInfoList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToParameterInfoList(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ParameterInfoList ** SOAP_FMAC4 soap_get_PointerToParameterInfoList(struct soap *soap, struct ParameterInfoList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToParameterInfoList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToParameterNames(struct soap *soap, struct ParameterNames *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		soap_serialize_ParameterNames(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToParameterNames(struct soap *soap, const char *tag, int id, struct ParameterNames *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptrstring : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_ParameterNames, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ParameterNames(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ParameterNames ** SOAP_FMAC4 soap_in_PointerToParameterNames(struct soap *soap, const char *tag, struct ParameterNames **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ParameterNames **)soap_malloc(soap, sizeof(struct ParameterNames *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ParameterNames(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ParameterNames **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ParameterNames, sizeof(struct ParameterNames), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToParameterNames(struct soap *soap, struct ParameterNames *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToParameterNames(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ParameterNames ** SOAP_FMAC4 soap_get_PointerToParameterNames(struct soap *soap, struct ParameterNames **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToParameterNames(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToParameterValueList(struct soap *soap, struct ParameterValueList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		soap_serialize_ParameterValueList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToParameterValueList(struct soap *soap, const char *tag, int id, struct ParameterValueList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptrParameterValueStruct : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_ParameterValueList, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ParameterValueList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ParameterValueList ** SOAP_FMAC4 soap_in_PointerToParameterValueList(struct soap *soap, const char *tag, struct ParameterValueList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ParameterValueList **)soap_malloc(soap, sizeof(struct ParameterValueList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ParameterValueList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ParameterValueList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ParameterValueList, sizeof(struct ParameterValueList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToParameterValueList(struct soap *soap, struct ParameterValueList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToParameterValueList(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ParameterValueList ** SOAP_FMAC4 soap_get_PointerToParameterValueList(struct soap *soap, struct ParameterValueList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToParameterValueList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToMethodList(struct soap *soap, struct MethodList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		soap_serialize_MethodList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToMethodList(struct soap *soap, const char *tag, int id, struct MethodList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptrstring : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_MethodList, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_MethodList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct MethodList ** SOAP_FMAC4 soap_in_PointerToMethodList(struct soap *soap, const char *tag, struct MethodList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct MethodList **)soap_malloc(soap, sizeof(struct MethodList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_MethodList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct MethodList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_MethodList, sizeof(struct MethodList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToMethodList(struct soap *soap, struct MethodList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToMethodList(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct MethodList ** SOAP_FMAC4 soap_get_PointerToMethodList(struct soap *soap, struct MethodList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToMethodList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_cwmp__Fault_SetParameterValuesFault(struct soap *soap, struct _cwmp__Fault_SetParameterValuesFault *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__cwmp__Fault_SetParameterValuesFault))
		soap_serialize__cwmp__Fault_SetParameterValuesFault(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_cwmp__Fault_SetParameterValuesFault(struct soap *soap, const char *tag, int id, struct _cwmp__Fault_SetParameterValuesFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__cwmp__Fault_SetParameterValuesFault, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__cwmp__Fault_SetParameterValuesFault(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _cwmp__Fault_SetParameterValuesFault ** SOAP_FMAC4 soap_in_PointerTo_cwmp__Fault_SetParameterValuesFault(struct soap *soap, const char *tag, struct _cwmp__Fault_SetParameterValuesFault **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _cwmp__Fault_SetParameterValuesFault **)soap_malloc(soap, sizeof(struct _cwmp__Fault_SetParameterValuesFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__cwmp__Fault_SetParameterValuesFault(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _cwmp__Fault_SetParameterValuesFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__cwmp__Fault_SetParameterValuesFault, sizeof(struct _cwmp__Fault_SetParameterValuesFault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_cwmp__Fault_SetParameterValuesFault(struct soap *soap, struct _cwmp__Fault_SetParameterValuesFault *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_cwmp__Fault_SetParameterValuesFault(soap, tag ? tag : "cwmp:Fault-SetParameterValuesFault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _cwmp__Fault_SetParameterValuesFault ** SOAP_FMAC4 soap_get_PointerTo_cwmp__Fault_SetParameterValuesFault(struct soap *soap, struct _cwmp__Fault_SetParameterValuesFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_cwmp__Fault_SetParameterValuesFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodateTime(struct soap *soap, time_t *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_dateTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTodateTime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dateTime, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_dateTime(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_in_PointerTodateTime(struct soap *soap, const char *tag, time_t **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_dateTime(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dateTime, sizeof(time_t), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodateTime(struct soap *soap, time_t *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTodateTime(soap, tag ? tag : "dateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTodateTime(struct soap *soap, time_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTodateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToAccessList(struct soap *soap, struct AccessList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		soap_serialize_AccessList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToAccessList(struct soap *soap, const char *tag, int id, struct AccessList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptrstring : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_AccessList, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_AccessList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct AccessList ** SOAP_FMAC4 soap_in_PointerToAccessList(struct soap *soap, const char *tag, struct AccessList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct AccessList **)soap_malloc(soap, sizeof(struct AccessList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_AccessList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct AccessList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_AccessList, sizeof(struct AccessList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToAccessList(struct soap *soap, struct AccessList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToAccessList(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct AccessList ** SOAP_FMAC4 soap_get_PointerToAccessList(struct soap *soap, struct AccessList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToAccessList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostring(struct soap *soap, char **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_string))
		soap_serialize_string(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostring(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_string, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_string(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTostring(struct soap *soap, const char *tag, char ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_string, sizeof(char *), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostring(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTostring(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTostring(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_cwmp__ObjectNameType(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_cwmp__ObjectNameType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_cwmp__ObjectNameType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_cwmp__ObjectNameType);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_cwmp__ObjectNameType(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_cwmp__ObjectNameType, 1, 0, 256, ".*\\.");
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_cwmp__ObjectNameType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_cwmp__ObjectNameType(soap, tag ? tag : "cwmp:ObjectNameType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_cwmp__ObjectNameType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_cwmp__ObjectNameType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_cwmp__CommandKeyType(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_cwmp__CommandKeyType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_cwmp__CommandKeyType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_cwmp__CommandKeyType);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_cwmp__CommandKeyType(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_cwmp__CommandKeyType, 1, 0, 32, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_cwmp__CommandKeyType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_cwmp__CommandKeyType(soap, tag ? tag : "cwmp:CommandKeyType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_cwmp__CommandKeyType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_cwmp__CommandKeyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_cwmp__ParameterKeyType(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_cwmp__ParameterKeyType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_cwmp__ParameterKeyType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_cwmp__ParameterKeyType);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_cwmp__ParameterKeyType(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_cwmp__ParameterKeyType, 1, 0, 32, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_cwmp__ParameterKeyType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_cwmp__ParameterKeyType(soap, tag ? tag : "cwmp:ParameterKeyType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_cwmp__ParameterKeyType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_cwmp__ParameterKeyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_cwmp__FaultCodeType(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_cwmp__FaultCodeType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_cwmp__FaultCodeType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_cwmp__FaultCodeType);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_cwmp__FaultCodeType(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_cwmp__FaultCodeType, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_cwmp__FaultCodeType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_cwmp__FaultCodeType(soap, tag ? tag : "cwmp:FaultCodeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_cwmp__FaultCodeType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_cwmp__FaultCodeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__anySimpleType(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_xsd__anySimpleType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anySimpleType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__anySimpleType);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__anySimpleType(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__anySimpleType, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anySimpleType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_xsd__anySimpleType(soap, tag ? tag : "xsd:anySimpleType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__anySimpleType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anySimpleType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedByte(struct soap *soap, unsigned char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_unsignedByte);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedByte(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedByte, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedByte(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTounsignedByte(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedByte(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedByte, sizeof(unsigned char), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedByte(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTounsignedByte(soap, tag ? tag : "unsignedByte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTounsignedByte(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__QName(soap, tag ? tag : "QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_new_string(struct soap *soap, int n)
{
	char * *p;
	char * *a = (char **)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(char *));
	for (p = a; p && n--; p++)
		soap_default_string(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.c */
